//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::*;
use crate::graph::{self, *};
use crate::graph_enums::*;
use crate::items::Item;
use crate::observe::*;
use crate::prices::Currency;
use crate::*;
use analyzer::context::Ctx;
use analyzer::matchertrie::IntegerObservation;
use analyzer::world::{self, World};
use rustc_hash::FxHashMap;

pub fn access_default(_ctx: &Context, _world: &graph::World) -> bool {
    true
}

pub fn access___defeat_ganon(ctx: &Context, world: &graph::World) -> bool {
    // [Defeat_Ganon]
    ctx.has(Item::Defeat_Ganon)
}
pub fn access___deku_lobby_web_kokiri_emerald(ctx: &Context, world: &graph::World) -> bool {
    // [Deku_Lobby_Web, Kokiri_Emerald]
    ctx.has(Item::Deku_Lobby_Web) && ctx.has(Item::Kokiri_Emerald)
}
pub fn access___invoke_nuts_or_invoke_can_use__slingshot_and_invoke_can_jumpslash(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ($Nuts or $can_use(Slingshot)) and $can_jumpslash
    ((helper__Nuts!(ctx, world) || helper__can_use!(ctx, world, Item::Slingshot))
        && helper__can_jumpslash!(ctx, world))
}
pub fn access___triforce_piece__triforce_count(ctx: &Context, world: &graph::World) -> bool {
    // [Triforce_Piece{triforce_count}]
    ctx.count(Item::Triforce_Piece) >= ctx.triforce_count()
}
pub fn access___victory_invoke_objective(ctx: &Context, world: &graph::World) -> bool {
    // [Victory, $objective]
    ctx.has(Item::Victory) && rule__objective!(ctx, world)
}
pub fn access_defeat_gohma(ctx: &Context, world: &graph::World) -> bool {
    // Defeat_Gohma
    ctx.has(Item::Defeat_Gohma)
}
pub fn access_deku_back_room_web_and_deku_back_room_wall(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Deku_Back_Room_Web and Deku_Back_Room_Wall
    (ctx.has(Item::Deku_Back_Room_Web) && ctx.has(Item::Deku_Back_Room_Wall))
}
pub fn access_deku_back_room_web_and_invoke_can_blast_or_smash(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Deku_Back_Room_Web and $can_blast_or_smash
    (ctx.has(Item::Deku_Back_Room_Web) && helper__can_blast_or_smash!(ctx, world))
}
pub fn access_deku_basement_block_and_invoke_is_child_and_invoke_sticks(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Deku_Basement_Block and $is_child and $Sticks
    ((ctx.has(Item::Deku_Basement_Block) && helper__is_child!(ctx, world))
        && helper__Sticks!(ctx, world))
}
pub fn access_deku_basement_scrubs(ctx: &Context, world: &graph::World) -> bool {
    // Deku_Basement_Scrubs
    ctx.has(Item::Deku_Basement_Scrubs)
}
pub fn access_deku_basement_switch(ctx: &Context, world: &graph::World) -> bool {
    // Deku_Basement_Switch
    ctx.has(Item::Deku_Basement_Switch)
}
pub fn access_deku_basement_web(ctx: &Context, world: &graph::World) -> bool {
    // Deku_Basement_Web
    ctx.has(Item::Deku_Basement_Web)
}
pub fn access_deku_lobby_web(ctx: &Context, world: &graph::World) -> bool {
    // Deku_Lobby_Web
    ctx.has(Item::Deku_Lobby_Web)
}
pub fn access_deku_lobby_web_and_logic_deku_b1_skip(ctx: &Context, world: &graph::World) -> bool {
    // Deku_Lobby_Web and logic_deku_b1_skip
    (ctx.has(Item::Deku_Lobby_Web) && world.logic_deku_b1_skip)
}
pub fn access_deku_slingshot_scrub(ctx: &Context, world: &graph::World) -> bool {
    // Deku_Slingshot_Scrub
    ctx.has(Item::Deku_Slingshot_Scrub)
}
pub fn access_deku_tree__compass_room__entry__ex__floor_3__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_torch
    ctx.deku_tree__compass_room__ctx__torch()
}
pub fn access_deku_tree__compass_room__entry__light_torch__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_child and $Sticks and not ^_torch
    ((helper__is_child!(ctx, world) && helper__Sticks!(ctx, world))
        && !ctx.deku_tree__compass_room__ctx__torch())
}
pub fn access_false(ctx: &Context, world: &graph::World) -> bool {
    // False
    false
}
pub fn access_gold_skulltula_token__10(ctx: &Context, world: &graph::World) -> bool {
    // Gold_Skulltula_Token{10}
    ctx.count(Item::Gold_Skulltula_Token) >= 10
}
pub fn access_invoke_can_play__minuet_of_forest(ctx: &Context, world: &graph::World) -> bool {
    // $can_play(Minuet_of_Forest)
    helper__can_play!(ctx, world, Item::Minuet_of_Forest)
}
pub fn access_invoke_can_use__boomerang_or_invoke_can_use__hookshot(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $can_use(Boomerang) or $can_use(Hookshot)
    (helper__can_use!(ctx, world, Item::Boomerang) || helper__can_use!(ctx, world, Item::Hookshot))
}
pub fn access_invoke_can_use__slingshot(ctx: &Context, world: &graph::World) -> bool {
    // $can_use(Slingshot)
    helper__can_use!(ctx, world, Item::Slingshot)
}
pub fn access_invoke_has_fire_source(ctx: &Context, world: &graph::World) -> bool {
    // $has_fire_source
    helper__has_fire_source!(ctx, world)
}
pub fn access_invoke_has_fire_source_with_torch_or_invoke_can_use__bow(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $has_fire_source_with_torch or $can_use(Bow)
    (helper__has_fire_source_with_torch!(ctx, world) || helper__can_use!(ctx, world, Item::Bow))
}
pub fn access_invoke_has_shield(ctx: &Context, world: &graph::World) -> bool {
    // $has_shield
    helper__has_shield!(ctx, world)
}
pub fn access_invoke_is_adult(ctx: &Context, world: &graph::World) -> bool {
    // $is_adult
    helper__is_adult!(ctx, world)
}
pub fn access_invoke_is_adult_or_deku_basement_block(ctx: &Context, world: &graph::World) -> bool {
    // $is_adult or Deku_Basement_Block
    (helper__is_adult!(ctx, world) || ctx.has(Item::Deku_Basement_Block))
}
pub fn access_invoke_is_adult_or_invoke_can_child_attack(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_adult or $can_child_attack
    (helper__is_adult!(ctx, world) || helper__can_child_attack!(ctx, world))
}
pub fn access_invoke_is_adult_or_invoke_can_child_attack_or_invoke_nuts(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_adult or $can_child_attack or $Nuts
    ((helper__is_adult!(ctx, world) || helper__can_child_attack!(ctx, world))
        || helper__Nuts!(ctx, world))
}
pub fn access_invoke_is_adult_or_invoke_sticks_or_kokiri_sword(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_adult or $Sticks or Kokiri_Sword
    ((helper__is_adult!(ctx, world) || helper__Sticks!(ctx, world)) || ctx.has(Item::Kokiri_Sword))
}
pub fn access_invoke_is_adult_or_kokiri_sword_or_boomerang(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_adult or Kokiri_Sword or Boomerang
    ((helper__is_adult!(ctx, world) || ctx.has(Item::Kokiri_Sword)) || ctx.has(Item::Boomerang))
}
pub fn access_invoke_is_adult_or_showed_mido(ctx: &Context, world: &graph::World) -> bool {
    // $is_adult or Showed_Mido
    (helper__is_adult!(ctx, world) || ctx.has(Item::Showed_Mido))
}
pub fn access_invoke_is_adult_or_slingshot_or_invoke_sticks_or_kokiri_sword(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_adult or Slingshot or $Sticks or Kokiri_Sword
    (((helper__is_adult!(ctx, world) || ctx.has(Item::Slingshot)) || helper__Sticks!(ctx, world))
        || ctx.has(Item::Kokiri_Sword))
}
pub fn access_invoke_is_child(ctx: &Context, world: &graph::World) -> bool {
    // $is_child
    helper__is_child!(ctx, world)
}
pub fn access_invoke_is_child_and_invoke_sticks_and_invoke_nuts(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_child and $Sticks and $Nuts
    ((helper__is_child!(ctx, world) && helper__Sticks!(ctx, world)) && helper__Nuts!(ctx, world))
}
pub fn access_invoke_is_child_and_kokiri_sword_and_invoke_deku_shield(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $is_child and Kokiri_Sword and $Deku_Shield
    ((helper__is_child!(ctx, world) && ctx.has(Item::Kokiri_Sword))
        && helper__Deku_Shield!(ctx, world))
}
pub fn access_invoke_nuts_and_invoke_has_shield_and_if___invoke_is_child____invoke_sticks__else____biggoron_sword_(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $Nuts and $has_shield and if ($is_child) { $Sticks } else { Biggoron_Sword }
    ((helper__Nuts!(ctx, world) && helper__has_shield!(ctx, world))
        && if helper__is_child!(ctx, world) {
            helper__Sticks!(ctx, world)
        } else {
            ctx.has(Item::Biggoron_Sword)
        })
}
pub fn access_invoke_objective(ctx: &Context, world: &graph::World) -> bool {
    // $objective
    rule__objective!(ctx, world)
}
pub fn action_deku_tree__compass_room__entry__light_torch__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_torch = True
    ctx.set_deku_tree__compass_room__ctx__torch(true);
}
pub fn action_rupees_set_invoke_max__rupees_add_20_invoke_wallet_max(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^rupees = $max(^rupees + 20, $wallet_max)
    ctx.set_rupees(std::cmp::max(
        ctx.rupees() + 20,
        helper__wallet_max!(ctx, world),
    ));
}
pub fn action_rupees_set_invoke_min__rupees_add_1_invoke_wallet_max(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^rupees = $min(^rupees + 1, $wallet_max)
    ctx.set_rupees(std::cmp::min(
        ctx.rupees() + 1,
        helper__wallet_max!(ctx, world),
    ));
}
pub fn action_rupees_set_invoke_min__rupees_add_50_invoke_wallet_max(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^rupees = $min(^rupees + 50, $wallet_max)
    ctx.set_rupees(std::cmp::min(
        ctx.rupees() + 50,
        helper__wallet_max!(ctx, world),
    ));
}
pub fn action_rupees_set_invoke_min__rupees_add_5_invoke_wallet_max(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^rupees = $min(^rupees + 5, $wallet_max)
    ctx.set_rupees(std::cmp::min(
        ctx.rupees() + 5,
        helper__wallet_max!(ctx, world),
    ));
}
pub fn action_save_set_position(ctx: &mut Context, world: &graph::World) {
    // ^save = ^position
    ctx.set_save(ctx.position());
}
pub fn action_tod_set_match_tod____day_setgt_night_night_setgt_day___setgt_day_(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^tod = MATCH ^tod { 'day' => 'night', 'night' => 'day', _ => 'day' }
    ctx.set_tod(match ctx.tod() {
        enums::Tod::Day => enums::Tod::Night,
        enums::Tod::Night => enums::Tod::Day,
        _ => enums::Tod::Day,
    });
}
pub fn explain___defeat_ganon(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Defeat_Ganon]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Defeat_Ganon);
            edict.insert("Defeat_Ganon", format!("{}", h));
            (h, vec!["Defeat_Ganon"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___deku_lobby_web_kokiri_emerald(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Deku_Lobby_Web, Kokiri_Emerald]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Deku_Lobby_Web);
            edict.insert("Deku_Lobby_Web", format!("{}", h));
            (h, vec!["Deku_Lobby_Web"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = {
            let h = ctx.has(Item::Kokiri_Emerald);
            edict.insert("Kokiri_Emerald", format!("{}", h));
            (h, vec!["Kokiri_Emerald"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___invoke_nuts_or_invoke_can_use__slingshot_and_invoke_can_jumpslash(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ($Nuts or $can_use(Slingshot)) and $can_jumpslash
    {
        let mut left = ({
            let mut left = {
                let (res, mut refs) = hexplain__Nuts!(ctx, world, edict);
                edict.insert("$Nuts", format!("{:?}", res));
                refs.push("$Nuts");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__can_use!(ctx, world, Item::Slingshot, edict);
                    edict.insert("$can_use(Slingshot)", format!("{:?}", res));
                    refs.push("$can_use(Slingshot)");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        });
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_jumpslash!(ctx, world, edict);
                edict.insert("$can_jumpslash", format!("{:?}", res));
                refs.push("$can_jumpslash");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain___triforce_piece__triforce_count(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Triforce_Piece{triforce_count}]
    {
        let mut refs = Vec::new();
        let mut h = {
            let ct = ctx.count(Item::Triforce_Piece);
            edict.insert("Triforce_Piece count", format!("{}", ct));
            let s = ctx.triforce_count();
            edict.insert("triforce_count", format!("{}", s));
            (ct >= s, vec!["Triforce_Piece count", "triforce_count"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___victory_invoke_objective(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Victory, $objective]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Victory);
            edict.insert("Victory", format!("{}", h));
            (h, vec!["Victory"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = rexplain__objective!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain_defeat_gohma(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Defeat_Gohma
    {
        let h = ctx.has(Item::Defeat_Gohma);
        edict.insert("Defeat_Gohma", format!("{}", h));
        (h, vec!["Defeat_Gohma"])
    }
}
pub fn explain_deku_back_room_web_and_deku_back_room_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Back_Room_Web and Deku_Back_Room_Wall
    {
        let mut left = {
            let h = ctx.has(Item::Deku_Back_Room_Web);
            edict.insert("Deku_Back_Room_Web", format!("{}", h));
            (h, vec!["Deku_Back_Room_Web"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Deku_Back_Room_Wall);
                edict.insert("Deku_Back_Room_Wall", format!("{}", h));
                (h, vec!["Deku_Back_Room_Wall"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_deku_back_room_web_and_invoke_can_blast_or_smash(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Back_Room_Web and $can_blast_or_smash
    {
        let mut left = {
            let h = ctx.has(Item::Deku_Back_Room_Web);
            edict.insert("Deku_Back_Room_Web", format!("{}", h));
            (h, vec!["Deku_Back_Room_Web"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_blast_or_smash!(ctx, world, edict);
                edict.insert("$can_blast_or_smash", format!("{:?}", res));
                refs.push("$can_blast_or_smash");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_deku_basement_block_and_invoke_is_child_and_invoke_sticks(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Basement_Block and $is_child and $Sticks
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Deku_Basement_Block);
                edict.insert("Deku_Basement_Block", format!("{}", h));
                (h, vec!["Deku_Basement_Block"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__is_child!(ctx, world, edict);
                    edict.insert("$is_child", format!("{:?}", res));
                    refs.push("$is_child");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                edict.insert("$Sticks", format!("{:?}", res));
                refs.push("$Sticks");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_deku_basement_scrubs(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Basement_Scrubs
    {
        let h = ctx.has(Item::Deku_Basement_Scrubs);
        edict.insert("Deku_Basement_Scrubs", format!("{}", h));
        (h, vec!["Deku_Basement_Scrubs"])
    }
}
pub fn explain_deku_basement_switch(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Basement_Switch
    {
        let h = ctx.has(Item::Deku_Basement_Switch);
        edict.insert("Deku_Basement_Switch", format!("{}", h));
        (h, vec!["Deku_Basement_Switch"])
    }
}
pub fn explain_deku_basement_web(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Basement_Web
    {
        let h = ctx.has(Item::Deku_Basement_Web);
        edict.insert("Deku_Basement_Web", format!("{}", h));
        (h, vec!["Deku_Basement_Web"])
    }
}
pub fn explain_deku_lobby_web(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Lobby_Web
    {
        let h = ctx.has(Item::Deku_Lobby_Web);
        edict.insert("Deku_Lobby_Web", format!("{}", h));
        (h, vec!["Deku_Lobby_Web"])
    }
}
pub fn explain_deku_lobby_web_and_logic_deku_b1_skip(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Lobby_Web and logic_deku_b1_skip
    {
        let mut left = {
            let h = ctx.has(Item::Deku_Lobby_Web);
            edict.insert("Deku_Lobby_Web", format!("{}", h));
            (h, vec!["Deku_Lobby_Web"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let s = world.logic_deku_b1_skip;
                edict.insert("logic_deku_b1_skip", format!("{}", s));
                (s, vec!["logic_deku_b1_skip"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_deku_slingshot_scrub(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Deku_Slingshot_Scrub
    {
        let h = ctx.has(Item::Deku_Slingshot_Scrub);
        edict.insert("Deku_Slingshot_Scrub", format!("{}", h));
        (h, vec!["Deku_Slingshot_Scrub"])
    }
}
pub fn explain_deku_tree__compass_room__entry__ex__floor_3__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_torch
    {
        let r = ctx.deku_tree__compass_room__ctx__torch();
        edict.insert("^deku_tree__compass_room__ctx__torch", format!("{:?}", r));
        (r, vec!["^deku_tree__compass_room__ctx__torch"])
    }
}
pub fn explain_deku_tree__compass_room__entry__light_torch__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_child and $Sticks and not ^_torch
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__is_child!(ctx, world, edict);
                edict.insert("$is_child", format!("{:?}", res));
                refs.push("$is_child");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                    edict.insert("$Sticks", format!("{:?}", res));
                    refs.push("$Sticks");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.deku_tree__compass_room__ctx__torch();
                    edict.insert("^deku_tree__compass_room__ctx__torch", format!("{:?}", r));
                    (r, vec!["^deku_tree__compass_room__ctx__torch"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_false(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // False
    (false, vec![])
}
pub fn explain_gold_skulltula_token__10(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Gold_Skulltula_Token{10}
    {
        let ct = ctx.count(Item::Gold_Skulltula_Token);
        edict.insert("Gold_Skulltula_Token count", format!("{}", ct));
        (ct >= 10, vec!["Gold_Skulltula_Token count"])
    }
}
pub fn explain_invoke_can_play__minuet_of_forest(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_play(Minuet_of_Forest)
    {
        let (res, mut refs) = hexplain__can_play!(ctx, world, Item::Minuet_of_Forest, edict);
        edict.insert("$can_play(Minuet_of_Forest)", format!("{:?}", res));
        refs.push("$can_play(Minuet_of_Forest)");
        (res, refs)
    }
}
pub fn explain_invoke_can_use__boomerang_or_invoke_can_use__hookshot(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_use(Boomerang) or $can_use(Hookshot)
    {
        let mut left = {
            let (res, mut refs) = hexplain__can_use!(ctx, world, Item::Boomerang, edict);
            edict.insert("$can_use(Boomerang)", format!("{:?}", res));
            refs.push("$can_use(Boomerang)");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_use!(ctx, world, Item::Hookshot, edict);
                edict.insert("$can_use(Hookshot)", format!("{:?}", res));
                refs.push("$can_use(Hookshot)");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_can_use__slingshot(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_use(Slingshot)
    {
        let (res, mut refs) = hexplain__can_use!(ctx, world, Item::Slingshot, edict);
        edict.insert("$can_use(Slingshot)", format!("{:?}", res));
        refs.push("$can_use(Slingshot)");
        (res, refs)
    }
}
pub fn explain_invoke_has_fire_source(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $has_fire_source
    {
        let (res, mut refs) = hexplain__has_fire_source!(ctx, world, edict);
        edict.insert("$has_fire_source", format!("{:?}", res));
        refs.push("$has_fire_source");
        (res, refs)
    }
}
pub fn explain_invoke_has_fire_source_with_torch_or_invoke_can_use__bow(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $has_fire_source_with_torch or $can_use(Bow)
    {
        let mut left = {
            let (res, mut refs) = hexplain__has_fire_source_with_torch!(ctx, world, edict);
            edict.insert("$has_fire_source_with_torch", format!("{:?}", res));
            refs.push("$has_fire_source_with_torch");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_use!(ctx, world, Item::Bow, edict);
                edict.insert("$can_use(Bow)", format!("{:?}", res));
                refs.push("$can_use(Bow)");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_has_shield(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $has_shield
    {
        let (res, mut refs) = hexplain__has_shield!(ctx, world, edict);
        edict.insert("$has_shield", format!("{:?}", res));
        refs.push("$has_shield");
        (res, refs)
    }
}
pub fn explain_invoke_is_adult(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult
    {
        let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
        edict.insert("$is_adult", format!("{:?}", res));
        refs.push("$is_adult");
        (res, refs)
    }
}
pub fn explain_invoke_is_adult_or_deku_basement_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or Deku_Basement_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
            edict.insert("$is_adult", format!("{:?}", res));
            refs.push("$is_adult");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Deku_Basement_Block);
                edict.insert("Deku_Basement_Block", format!("{}", h));
                (h, vec!["Deku_Basement_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_adult_or_invoke_can_child_attack(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or $can_child_attack
    {
        let mut left = {
            let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
            edict.insert("$is_adult", format!("{:?}", res));
            refs.push("$is_adult");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_child_attack!(ctx, world, edict);
                edict.insert("$can_child_attack", format!("{:?}", res));
                refs.push("$can_child_attack");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_adult_or_invoke_can_child_attack_or_invoke_nuts(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or $can_child_attack or $Nuts
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
                edict.insert("$is_adult", format!("{:?}", res));
                refs.push("$is_adult");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__can_child_attack!(ctx, world, edict);
                    edict.insert("$can_child_attack", format!("{:?}", res));
                    refs.push("$can_child_attack");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__Nuts!(ctx, world, edict);
                edict.insert("$Nuts", format!("{:?}", res));
                refs.push("$Nuts");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_adult_or_invoke_sticks_or_kokiri_sword(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or $Sticks or Kokiri_Sword
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
                edict.insert("$is_adult", format!("{:?}", res));
                refs.push("$is_adult");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                    edict.insert("$Sticks", format!("{:?}", res));
                    refs.push("$Sticks");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Kokiri_Sword);
                edict.insert("Kokiri_Sword", format!("{}", h));
                (h, vec!["Kokiri_Sword"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_adult_or_kokiri_sword_or_boomerang(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or Kokiri_Sword or Boomerang
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
                edict.insert("$is_adult", format!("{:?}", res));
                refs.push("$is_adult");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Kokiri_Sword);
                    edict.insert("Kokiri_Sword", format!("{}", h));
                    (h, vec!["Kokiri_Sword"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Boomerang);
                edict.insert("Boomerang", format!("{}", h));
                (h, vec!["Boomerang"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_adult_or_showed_mido(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or Showed_Mido
    {
        let mut left = {
            let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
            edict.insert("$is_adult", format!("{:?}", res));
            refs.push("$is_adult");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Showed_Mido);
                edict.insert("Showed_Mido", format!("{}", h));
                (h, vec!["Showed_Mido"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_adult_or_slingshot_or_invoke_sticks_or_kokiri_sword(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_adult or Slingshot or $Sticks or Kokiri_Sword
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__is_adult!(ctx, world, edict);
                    edict.insert("$is_adult", format!("{:?}", res));
                    refs.push("$is_adult");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Slingshot);
                        edict.insert("Slingshot", format!("{}", h));
                        (h, vec!["Slingshot"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                    edict.insert("$Sticks", format!("{:?}", res));
                    refs.push("$Sticks");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Kokiri_Sword);
                edict.insert("Kokiri_Sword", format!("{}", h));
                (h, vec!["Kokiri_Sword"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_child(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_child
    {
        let (res, mut refs) = hexplain__is_child!(ctx, world, edict);
        edict.insert("$is_child", format!("{:?}", res));
        refs.push("$is_child");
        (res, refs)
    }
}
pub fn explain_invoke_is_child_and_invoke_sticks_and_invoke_nuts(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_child and $Sticks and $Nuts
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__is_child!(ctx, world, edict);
                edict.insert("$is_child", format!("{:?}", res));
                refs.push("$is_child");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                    edict.insert("$Sticks", format!("{:?}", res));
                    refs.push("$Sticks");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__Nuts!(ctx, world, edict);
                edict.insert("$Nuts", format!("{:?}", res));
                refs.push("$Nuts");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_is_child_and_kokiri_sword_and_invoke_deku_shield(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $is_child and Kokiri_Sword and $Deku_Shield
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__is_child!(ctx, world, edict);
                edict.insert("$is_child", format!("{:?}", res));
                refs.push("$is_child");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Kokiri_Sword);
                    edict.insert("Kokiri_Sword", format!("{}", h));
                    (h, vec!["Kokiri_Sword"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__Deku_Shield!(ctx, world, edict);
                edict.insert("$Deku_Shield", format!("{:?}", res));
                refs.push("$Deku_Shield");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_nuts_and_invoke_has_shield_and_if___invoke_is_child____invoke_sticks__else____biggoron_sword_(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $Nuts and $has_shield and if ($is_child) { $Sticks } else { Biggoron_Sword }
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__Nuts!(ctx, world, edict);
                edict.insert("$Nuts", format!("{:?}", res));
                refs.push("$Nuts");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__has_shield!(ctx, world, edict);
                    edict.insert("$has_shield", format!("{:?}", res));
                    refs.push("$has_shield");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = Vec::new();
                let mut cond = {
                    let (res, mut refs) = hexplain__is_child!(ctx, world, edict);
                    edict.insert("$is_child", format!("{:?}", res));
                    refs.push("$is_child");
                    (res, refs)
                };
                refs.append(cond.1);
                if cond.0 {
                    let mut then = {
                        let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                        edict.insert("$Sticks", format!("{:?}", res));
                        refs.push("$Sticks");
                        (res, refs)
                    };
                    refs.append(&mut then.1);
                    (then.0, refs)
                } else {
                    let mut then = {
                        let (res, mut refs) = hexplain__Sticks!(ctx, world, edict);
                        edict.insert("$Sticks", format!("{:?}", res));
                        refs.push("$Sticks");
                        (res, refs)
                    };
                    refs.append(&mut then.1);
                    (then.0, refs)
                }
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_objective(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $objective
    {
        let (res, mut refs) = rexplain__objective!(ctx, world, edict);
        edict.insert("$objective", format!("{:?}", res));
        refs.push("$objective");
        (res, refs)
    }
}
pub fn observe_access___defeat_ganon(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Defeat_Ganon]
    ({
        full_obs.observe_defeat_ganon();
        ctx.has(Item::Defeat_Ganon)
    })
}
pub fn observe_access___deku_lobby_web_kokiri_emerald(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Deku_Lobby_Web, Kokiri_Emerald]
    ({
        full_obs.observe_deku_lobby_web();
        ctx.has(Item::Deku_Lobby_Web)
    }) && ({
        full_obs.observe_kokiri_emerald();
        ctx.has(Item::Kokiri_Emerald)
    })
}
pub fn observe_access___invoke_nuts_or_invoke_can_use__slingshot_and_invoke_can_jumpslash(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ($Nuts or $can_use(Slingshot)) and $can_jumpslash
    ((hobserve__Nuts!(ctx, world, full_obs)
        || hobserve__can_use!(ctx, world, Item::Slingshot, full_obs))
        && (hobserve__can_jumpslash!(ctx, world, full_obs)))
}
pub fn observe_access___triforce_piece__triforce_count(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Triforce_Piece{triforce_count}]
    ({
        full_obs.observe_triforce_piece(IntegerObservation::Ge(ctx.triforce_count()));
        ctx.count(Item::Triforce_Piece) >= ctx.triforce_count()
    })
}
pub fn observe_access___victory_invoke_objective(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Victory, $objective]
    ({
        full_obs.observe_victory();
        ctx.has(Item::Victory)
    }) && robserve__objective!(ctx, world, full_obs)
}
pub fn observe_access_defeat_gohma(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Defeat_Gohma
    {
        full_obs.observe_defeat_gohma();
        ctx.has(Item::Defeat_Gohma)
    }
}
pub fn observe_access_deku_back_room_web_and_deku_back_room_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Back_Room_Web and Deku_Back_Room_Wall
    ({
        full_obs.observe_deku_back_room_web();
        ctx.has(Item::Deku_Back_Room_Web)
    } && ({
        full_obs.observe_deku_back_room_wall();
        ctx.has(Item::Deku_Back_Room_Wall)
    }))
}
pub fn observe_access_deku_back_room_web_and_invoke_can_blast_or_smash(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Back_Room_Web and $can_blast_or_smash
    ({
        full_obs.observe_deku_back_room_web();
        ctx.has(Item::Deku_Back_Room_Web)
    } && (hobserve__can_blast_or_smash!(ctx, world, full_obs)))
}
pub fn observe_access_deku_basement_block_and_invoke_is_child_and_invoke_sticks(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Basement_Block and $is_child and $Sticks
    (({
        full_obs.observe_deku_basement_block();
        ctx.has(Item::Deku_Basement_Block)
    } && (hobserve__is_child!(ctx, world, full_obs)))
        && (hobserve__Sticks!(ctx, world, full_obs)))
}
pub fn observe_access_deku_basement_scrubs(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Basement_Scrubs
    {
        full_obs.observe_deku_basement_scrubs();
        ctx.has(Item::Deku_Basement_Scrubs)
    }
}
pub fn observe_access_deku_basement_switch(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Basement_Switch
    {
        full_obs.observe_deku_basement_switch();
        ctx.has(Item::Deku_Basement_Switch)
    }
}
pub fn observe_access_deku_basement_web(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Basement_Web
    {
        full_obs.observe_deku_basement_web();
        ctx.has(Item::Deku_Basement_Web)
    }
}
pub fn observe_access_deku_lobby_web(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Lobby_Web
    {
        full_obs.observe_deku_lobby_web();
        ctx.has(Item::Deku_Lobby_Web)
    }
}
pub fn observe_access_deku_lobby_web_and_logic_deku_b1_skip(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Lobby_Web and logic_deku_b1_skip
    ({
        full_obs.observe_deku_lobby_web();
        ctx.has(Item::Deku_Lobby_Web)
    } && (world.logic_deku_b1_skip))
}
pub fn observe_access_deku_slingshot_scrub(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Deku_Slingshot_Scrub
    {
        full_obs.observe_deku_slingshot_scrub();
        ctx.has(Item::Deku_Slingshot_Scrub)
    }
}
pub fn observe_access_deku_tree__compass_room__entry__ex__floor_3__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_torch
    {
        full_obs.observe_deku_tree__compass_room__ctx__torch();
        ctx.deku_tree__compass_room__ctx__torch()
    }
}
pub fn observe_access_deku_tree__compass_room__entry__light_torch__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_child and $Sticks and not ^_torch
    ((hobserve__is_child!(ctx, world, full_obs) && (hobserve__Sticks!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_deku_tree__compass_room__ctx__torch();
            ctx.deku_tree__compass_room__ctx__torch()
        })))
}
pub fn observe_access_false(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // False
    false
}
pub fn observe_access_gold_skulltula_token__10(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Gold_Skulltula_Token{10}
    {
        full_obs.observe_gold_skulltula_token(IntegerObservation::Ge(10));
        ctx.count(Item::Gold_Skulltula_Token) >= 10
    }
}
pub fn observe_access_invoke_can_play__minuet_of_forest(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_play(Minuet_of_Forest)
    hobserve__can_play!(ctx, world, Item::Minuet_of_Forest, full_obs)
}
pub fn observe_access_invoke_can_use__boomerang_or_invoke_can_use__hookshot(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_use(Boomerang) or $can_use(Hookshot)
    (hobserve__can_use!(ctx, world, Item::Boomerang, full_obs)
        || hobserve__can_use!(ctx, world, Item::Hookshot, full_obs))
}
pub fn observe_access_invoke_can_use__slingshot(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_use(Slingshot)
    hobserve__can_use!(ctx, world, Item::Slingshot, full_obs)
}
pub fn observe_access_invoke_has_fire_source(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $has_fire_source
    hobserve__has_fire_source!(ctx, world, full_obs)
}
pub fn observe_access_invoke_has_fire_source_with_torch_or_invoke_can_use__bow(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $has_fire_source_with_torch or $can_use(Bow)
    (hobserve__has_fire_source_with_torch!(ctx, world, full_obs)
        || hobserve__can_use!(ctx, world, Item::Bow, full_obs))
}
pub fn observe_access_invoke_has_shield(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $has_shield
    hobserve__has_shield!(ctx, world, full_obs)
}
pub fn observe_access_invoke_is_adult(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult
    hobserve__is_adult!(ctx, world, full_obs)
}
pub fn observe_access_invoke_is_adult_or_deku_basement_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or Deku_Basement_Block
    (hobserve__is_adult!(ctx, world, full_obs) || {
        full_obs.observe_deku_basement_block();
        ctx.has(Item::Deku_Basement_Block)
    })
}
pub fn observe_access_invoke_is_adult_or_invoke_can_child_attack(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or $can_child_attack
    (hobserve__is_adult!(ctx, world, full_obs) || hobserve__can_child_attack!(ctx, world, full_obs))
}
pub fn observe_access_invoke_is_adult_or_invoke_can_child_attack_or_invoke_nuts(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or $can_child_attack or $Nuts
    ((hobserve__is_adult!(ctx, world, full_obs)
        || hobserve__can_child_attack!(ctx, world, full_obs))
        || hobserve__Nuts!(ctx, world, full_obs))
}
pub fn observe_access_invoke_is_adult_or_invoke_sticks_or_kokiri_sword(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or $Sticks or Kokiri_Sword
    ((hobserve__is_adult!(ctx, world, full_obs) || hobserve__Sticks!(ctx, world, full_obs)) || {
        full_obs.observe_kokiri_sword();
        ctx.has(Item::Kokiri_Sword)
    })
}
pub fn observe_access_invoke_is_adult_or_kokiri_sword_or_boomerang(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or Kokiri_Sword or Boomerang
    ((hobserve__is_adult!(ctx, world, full_obs) || {
        full_obs.observe_kokiri_sword();
        ctx.has(Item::Kokiri_Sword)
    }) || {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    })
}
pub fn observe_access_invoke_is_adult_or_showed_mido(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or Showed_Mido
    (hobserve__is_adult!(ctx, world, full_obs) || {
        full_obs.observe_showed_mido();
        ctx.has(Item::Showed_Mido)
    })
}
pub fn observe_access_invoke_is_adult_or_slingshot_or_invoke_sticks_or_kokiri_sword(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_adult or Slingshot or $Sticks or Kokiri_Sword
    (((hobserve__is_adult!(ctx, world, full_obs) || {
        full_obs.observe_slingshot();
        ctx.has(Item::Slingshot)
    }) || hobserve__Sticks!(ctx, world, full_obs))
        || {
            full_obs.observe_kokiri_sword();
            ctx.has(Item::Kokiri_Sword)
        })
}
pub fn observe_access_invoke_is_child(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_child
    hobserve__is_child!(ctx, world, full_obs)
}
pub fn observe_access_invoke_is_child_and_invoke_sticks_and_invoke_nuts(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_child and $Sticks and $Nuts
    ((hobserve__is_child!(ctx, world, full_obs) && (hobserve__Sticks!(ctx, world, full_obs)))
        && (hobserve__Nuts!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_is_child_and_kokiri_sword_and_invoke_deku_shield(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $is_child and Kokiri_Sword and $Deku_Shield
    ((hobserve__is_child!(ctx, world, full_obs)
        && ({
            full_obs.observe_kokiri_sword();
            ctx.has(Item::Kokiri_Sword)
        }))
        && (hobserve__Deku_Shield!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_nuts_and_invoke_has_shield_and_if___invoke_is_child____invoke_sticks__else____biggoron_sword_(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $Nuts and $has_shield and if ($is_child) { $Sticks } else { Biggoron_Sword }
    ((hobserve__Nuts!(ctx, world, full_obs) && (hobserve__has_shield!(ctx, world, full_obs)))
        && (if hobserve__is_child!(ctx, world, full_obs) {
            hobserve__Sticks!(ctx, world, full_obs)
        } else {
            {
                full_obs.observe_biggoron_sword();
                ctx.has(Item::Biggoron_Sword)
            }
        }))
}
pub fn observe_access_invoke_objective(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $objective
    robserve__objective!(ctx, world, full_obs)
}
pub fn observe_action_deku_tree__compass_room__entry__light_torch__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_torch = True
}
pub fn observe_action_rupees_set_invoke_max__rupees_add_20_invoke_wallet_max(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^rupees = $max(^rupees + 20, $wallet_max)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    {
        let _set = std::cmp::max(
            {
                full_obs.observe_rupees(IntegerObservation::Exact);
                ctx.rupees()
            } + 20,
            helper__wallet_max!(ctx, world),
        );
    };
    full_obs.strict = old_strict;
}
pub fn observe_action_rupees_set_invoke_min__rupees_add_1_invoke_wallet_max(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^rupees = $min(^rupees + 1, $wallet_max)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    {
        let _set = std::cmp::min(
            {
                full_obs.observe_rupees(IntegerObservation::Exact);
                ctx.rupees()
            } + 1,
            helper__wallet_max!(ctx, world),
        );
    };
    full_obs.strict = old_strict;
}
pub fn observe_action_rupees_set_invoke_min__rupees_add_50_invoke_wallet_max(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^rupees = $min(^rupees + 50, $wallet_max)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    {
        let _set = std::cmp::min(
            {
                full_obs.observe_rupees(IntegerObservation::Exact);
                ctx.rupees()
            } + 50,
            helper__wallet_max!(ctx, world),
        );
    };
    full_obs.strict = old_strict;
}
pub fn observe_action_rupees_set_invoke_min__rupees_add_5_invoke_wallet_max(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^rupees = $min(^rupees + 5, $wallet_max)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    {
        let _set = std::cmp::min(
            {
                full_obs.observe_rupees(IntegerObservation::Exact);
                ctx.rupees()
            } + 5,
            helper__wallet_max!(ctx, world),
        );
    };
    full_obs.strict = old_strict;
}
pub fn observe_action_save_set_position(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^save = ^position
}
pub fn observe_action_tod_set_match_tod____day_setgt_night_night_setgt_day___setgt_day_(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^tod = MATCH ^tod { 'day' => 'night', 'night' => 'day', _ => 'day' }
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    {
        let _set = match {
            full_obs.observe_tod();
            ctx.tod()
        } {
            enums::Tod::Day => enums::Tod::Night,
            enums::Tod::Night => enums::Tod::Day,
            _ => enums::Tod::Day,
        };
    };
    full_obs.strict = old_strict;
}
