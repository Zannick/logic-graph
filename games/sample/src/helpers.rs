//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

/// $is_child (  )
/// ^child
#[macro_export]
macro_rules! helper__is_child {
    ($ctx:expr, $world:expr) => {{
        $ctx.child()
    }};
}
#[macro_export]
macro_rules! hexplain__is_child {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let r = $ctx.child();
            $edict.insert("^child", format!("{:?}", r));
            (r, vec!["^child"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__is_child {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_child();
            $ctx.child()
        }
    }};
}

/// $is_adult (  )
/// NOT ^child
#[macro_export]
macro_rules! helper__is_adult {
    ($ctx:expr, $world:expr) => {{
        !$ctx.child()
    }};
}
#[macro_export]
macro_rules! hexplain__is_adult {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let val = {
                let r = $ctx.child();
                $edict.insert("^child", format!("{:?}", r));
                (r, vec!["^child"])
            };
            (!val.0, val.1)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__is_adult {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        !({
            $full_obs.observe_child();
            $ctx.child()
        })
    }};
}

/// $Deku_Shield (  )
/// Buy_Deku_Shield or Deku_Shield_Drop
#[macro_export]
macro_rules! helper__Deku_Shield {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Buy_Deku_Shield) || $ctx.has(Item::Deku_Shield_Drop))
    }};
}
#[macro_export]
macro_rules! hexplain__Deku_Shield {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Buy_Deku_Shield);
                $edict.insert("Buy_Deku_Shield", format!("{}", h));
                (h, vec!["Buy_Deku_Shield"])
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Deku_Shield_Drop);
                    $edict.insert("Deku_Shield_Drop", format!("{}", h));
                    (h, vec!["Deku_Shield_Drop"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__Deku_Shield {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_buy_deku_shield();
            $ctx.has(Item::Buy_Deku_Shield)
        } || {
            $full_obs.observe_deku_shield_drop();
            $ctx.has(Item::Deku_Shield_Drop)
        })
    }};
}

/// $Nuts (  )
/// Buy_Deku_Nut_5 or Buy_Deku_Nut_10 or Deku_Nut_Drop
#[macro_export]
macro_rules! helper__Nuts {
    ($ctx:expr, $world:expr) => {{
        (($ctx.has(Item::Buy_Deku_Nut_5) || $ctx.has(Item::Buy_Deku_Nut_10))
            || $ctx.has(Item::Deku_Nut_Drop))
    }};
}
#[macro_export]
macro_rules! hexplain__Nuts {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let h = $ctx.has(Item::Buy_Deku_Nut_5);
                    $edict.insert("Buy_Deku_Nut_5", format!("{}", h));
                    (h, vec!["Buy_Deku_Nut_5"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = $ctx.has(Item::Buy_Deku_Nut_10);
                        $edict.insert("Buy_Deku_Nut_10", format!("{}", h));
                        (h, vec!["Buy_Deku_Nut_10"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Deku_Nut_Drop);
                    $edict.insert("Deku_Nut_Drop", format!("{}", h));
                    (h, vec!["Deku_Nut_Drop"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__Nuts {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (({
            $full_obs.observe_buy_deku_nut_5();
            $ctx.has(Item::Buy_Deku_Nut_5)
        } || {
            $full_obs.observe_buy_deku_nut_10();
            $ctx.has(Item::Buy_Deku_Nut_10)
        }) || {
            $full_obs.observe_deku_nut_drop();
            $ctx.has(Item::Deku_Nut_Drop)
        })
    }};
}

/// $Sticks (  )
/// Buy_Deku_Stick_1 or Deku_Stick_Drop
#[macro_export]
macro_rules! helper__Sticks {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Buy_Deku_Stick_1) || $ctx.has(Item::Deku_Stick_Drop))
    }};
}
#[macro_export]
macro_rules! hexplain__Sticks {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Buy_Deku_Stick_1);
                $edict.insert("Buy_Deku_Stick_1", format!("{}", h));
                (h, vec!["Buy_Deku_Stick_1"])
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Deku_Stick_Drop);
                    $edict.insert("Deku_Stick_Drop", format!("{}", h));
                    (h, vec!["Deku_Stick_Drop"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__Sticks {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_buy_deku_stick_1();
            $ctx.has(Item::Buy_Deku_Stick_1)
        } || {
            $full_obs.observe_deku_stick_drop();
            $ctx.has(Item::Deku_Stick_Drop)
        })
    }};
}

/// $wallet_max (  )
/// PER Progressive_Wallet { 3 => 999, 2 => 500, 1 => 200, _ => 99 }
#[macro_export]
macro_rules! helper__wallet_max {
    ($ctx:expr, $world:expr) => {{
        match $ctx.count(Item::Progressive_Wallet) {
            3 => 999,
            2 => 500,
            1 => 200,
            _ => 99,
        }
    }};
}
#[macro_export]
macro_rules! hexplain__wallet_max {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = vec!["Progressive_Wallet count"];
            let ct = $ctx.count(Item::Progressive_Wallet);
            $edict.insert("Progressive_Wallet count", format!("{}", ct));
            let mut m = match ct {
                3 => (999, vec![]),
                2 => (500, vec![]),
                1 => (200, vec![]),
                _ => (99, vec![]),
            };
            refs.append(&mut m.1);
            m
        }
    }};
}
#[macro_export]
macro_rules! hobserve__wallet_max {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_progressive_wallet(IntegerObservation::Exact);
            match $ctx.count(Item::Progressive_Wallet) {
                3 => 999,
                2 => 500,
                1 => 200,
                _ => 99,
            }
        }
    }};
}

/// $has_shield (  )
/// ($is_adult and Hylian_Shield) or ($is_child and $Deku_Shield)
#[macro_export]
macro_rules! helper__has_shield {
    ($ctx:expr, $world:expr) => {{
        ((helper__is_adult!($ctx, $world) && $ctx.has(Item::Hylian_Shield))
            || (helper__is_child!($ctx, $world) && helper__Deku_Shield!($ctx, $world)))
    }};
}
#[macro_export]
macro_rules! hexplain__has_shield {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = ({
                let mut left = {
                    let (res, mut refs) = hexplain__is_adult!($ctx, $world, $edict);
                    $edict.insert("$is_adult", format!("{:?}", res));
                    refs.push("$is_adult");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = $ctx.has(Item::Hylian_Shield);
                        $edict.insert("Hylian_Shield", format!("{}", h));
                        (h, vec!["Hylian_Shield"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            if left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let (res, mut refs) = hexplain__is_child!($ctx, $world, $edict);
                        $edict.insert("$is_child", format!("{:?}", res));
                        refs.push("$is_child");
                        (res, refs)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__Deku_Shield!($ctx, $world, $edict);
                            $edict.insert("$Deku_Shield", format!("{:?}", res));
                            refs.push("$Deku_Shield");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__has_shield {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ((hobserve__is_adult!($ctx, $world, $full_obs)
            && ({
                $full_obs.observe_hylian_shield();
                $ctx.has(Item::Hylian_Shield)
            }))
            || (hobserve__is_child!($ctx, $world, $full_obs)
                && (hobserve__Deku_Shield!($ctx, $world, $full_obs))))
    }};
}

/// $can_play ( TypedVar(name='song', type='Item') )
/// Ocarina and ^song
#[macro_export]
macro_rules! helper__can_play {
    ($ctx:expr, $world:expr, $song:expr) => {{
        ($ctx.has(Item::Ocarina) && $ctx.has($song))
    }};
}
#[macro_export]
macro_rules! hexplain__can_play {
    ($ctx:expr, $world:expr, $song:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Ocarina);
                $edict.insert("Ocarina", format!("{}", h));
                (h, vec!["Ocarina"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let r = {
                        let r = $song;
                        if let Some(v) = $edict.get_mut(&"helpers:$can_play.^song") {
                            v.push_str(&format!(", $song: {}", r));
                        } else {
                            $edict.insert("helpers:$can_play.^song", format!("$song: {}", r));
                        };
                        (r, vec!["helpers:$can_play.^song"])
                    };
                    ($ctx.has(r.0), r.1)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_play {
    ($ctx:expr, $world:expr, $song:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_ocarina();
            $ctx.has(Item::Ocarina)
        } && ({
            $full_obs.observe_has_item($song);
            $ctx.has($song)
        }))
    }};
}

/// $can_jumpslash (  )
/// $is_adult or $Sticks or Kokiri_Sword
#[macro_export]
macro_rules! helper__can_jumpslash {
    ($ctx:expr, $world:expr) => {{
        ((helper__is_adult!($ctx, $world) || helper__Sticks!($ctx, $world))
            || $ctx.has(Item::Kokiri_Sword))
    }};
}
#[macro_export]
macro_rules! hexplain__can_jumpslash {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__is_adult!($ctx, $world, $edict);
                    $edict.insert("$is_adult", format!("{:?}", res));
                    refs.push("$is_adult");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__Sticks!($ctx, $world, $edict);
                        $edict.insert("$Sticks", format!("{:?}", res));
                        refs.push("$Sticks");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Kokiri_Sword);
                    $edict.insert("Kokiri_Sword", format!("{}", h));
                    (h, vec!["Kokiri_Sword"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_jumpslash {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ((hobserve__is_adult!($ctx, $world, $full_obs)
            || hobserve__Sticks!($ctx, $world, $full_obs))
            || {
                $full_obs.observe_kokiri_sword();
                $ctx.has(Item::Kokiri_Sword)
            })
    }};
}

/// $can_use ( TypedVar(name='item', type='Item') )
/// IF ($_is_magic_item(^item)) { ^item and Magic_Meter } ELSE IF ($_is_adult_item(^item)) { $is_adult and ^item } ELSE IF ($_is_magic_arrow(^item)) { $is_adult and ^item and Bow and Magic_Meter } ELSE IF ($_is_child_item(^item)) { $is_child and ^item }
#[macro_export]
macro_rules! helper__can_use {
    ($ctx:expr, $world:expr, $item:expr) => {{
        if helper___is_magic_item!($ctx, $world, $item) {
            ($ctx.has($item) && $ctx.has(Item::Magic_Meter))
        } else if helper___is_adult_item!($ctx, $world, $item) {
            (helper__is_adult!($ctx, $world) && $ctx.has($item))
        } else if helper___is_magic_arrow!($ctx, $world, $item) {
            (((helper__is_adult!($ctx, $world) && $ctx.has($item)) && $ctx.has(Item::Bow))
                && $ctx.has(Item::Magic_Meter))
        } else if helper___is_child_item!($ctx, $world, $item) {
            (helper__is_child!($ctx, $world) && $ctx.has($item))
        } else {
            false
        }
    }};
}
#[macro_export]
macro_rules! hexplain__can_use {
    ($ctx:expr, $world:expr, $item:expr, $edict:expr) => {{
        { let mut refs = Vec::new(); let mut cond = { let (res, mut refs) = hexplain___is_magic_item!($ctx, $world, $item, $edict); $edict.insert("$_is_magic_item(^item)", format!("{:?}", res)); refs.push("$_is_magic_item(^item)"); let mut r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; refs.append(&mut r.1); (res, refs) }; refs.append(&mut cond.1); if cond.0 { let mut then = { let mut left = { let r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; ($ctx.has(r.0), r.1) }; if !left.0 { left } else { let mut right = { let h = $ctx.has(Item::Magic_Meter); $edict.insert("Magic_Meter", format!("{}", h)); (h, vec!["Magic_Meter"]) }; left.1.append(&mut right.1); (right.0, left.1) } }; refs.append(&mut then.1); (then.0, refs) } else { let mut cond = { let (res, mut refs) = hexplain___is_adult_item!($ctx, $world, $item, $edict); $edict.insert("$_is_adult_item(^item)", format!("{:?}", res)); refs.push("$_is_adult_item(^item)"); let mut r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; refs.append(&mut r.1); (res, refs) }; refs.append(&mut cond.1); if cond.0 { let mut then = { let mut left = { let (res, mut refs) = hexplain__is_adult!($ctx, $world, $edict); $edict.insert("$is_adult", format!("{:?}", res)); refs.push("$is_adult"); (res, refs) }; if !left.0 { left } else { let mut right = { let r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; ($ctx.has(r.0), r.1) }; left.1.append(&mut right.1); (right.0, left.1) } }; refs.append(&mut then.1); (then.0, refs) } else { let mut cond = { let (res, mut refs) = hexplain___is_magic_arrow!($ctx, $world, $item, $edict); $edict.insert("$_is_magic_arrow(^item)", format!("{:?}", res)); refs.push("$_is_magic_arrow(^item)"); let mut r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; refs.append(&mut r.1); (res, refs) }; refs.append(&mut cond.1); if cond.0 { let mut then = { let mut left = { let mut left = { let mut left = { let (res, mut refs) = hexplain__is_adult!($ctx, $world, $edict); $edict.insert("$is_adult", format!("{:?}", res)); refs.push("$is_adult"); (res, refs) }; if !left.0 { left } else { let mut right = { let r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; ($ctx.has(r.0), r.1) }; left.1.append(&mut right.1); (right.0, left.1) } }; if !left.0 { left } else { let mut right = { let h = $ctx.has(Item::Bow); $edict.insert("Bow", format!("{}", h)); (h, vec!["Bow"]) }; left.1.append(&mut right.1); (right.0, left.1) } }; if !left.0 { left } else { let mut right = { let h = $ctx.has(Item::Magic_Meter); $edict.insert("Magic_Meter", format!("{}", h)); (h, vec!["Magic_Meter"]) }; left.1.append(&mut right.1); (right.0, left.1) } }; refs.append(&mut then.1); (then.0, refs) } else { let mut cond = { let (res, mut refs) = hexplain___is_child_item!($ctx, $world, $item, $edict); $edict.insert("$_is_child_item(^item)", format!("{:?}", res)); refs.push("$_is_child_item(^item)"); let mut r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; refs.append(&mut r.1); (res, refs) }; refs.append(&mut cond.1); if cond.0 { let mut then = { let mut left = { let (res, mut refs) = hexplain__is_child!($ctx, $world, $edict); $edict.insert("$is_child", format!("{:?}", res)); refs.push("$is_child"); (res, refs) }; if !left.0 { left } else { let mut right = { let r = { let r = $item; if let Some(v) = $edict.get_mut(&"helpers:$can_use.^item") { v.push_str(&format!(", $item: {}", r)); } else { $edict.insert("helpers:$can_use.^item", format!("$item: {}", r)); }; (r, vec!["helpers:$can_use.^item"]) }; ($ctx.has(r.0), r.1) }; left.1.append(&mut right.1); (right.0, left.1) } }; refs.append(&mut then.1); (then.0, refs) } else {  (false, refs)  } } } } }
    }};
}
#[macro_export]
macro_rules! hobserve__can_use {
    ($ctx:expr, $world:expr, $item:expr, $full_obs:expr) => {{
        if hobserve___is_magic_item!($ctx, $world, $item, $full_obs) {
            ({
                $full_obs.observe_has_item($item);
                $ctx.has($item)
            } && ({
                $full_obs.observe_magic_meter();
                $ctx.has(Item::Magic_Meter)
            }))
        } else if hobserve___is_adult_item!($ctx, $world, $item, $full_obs) {
            (hobserve__is_adult!($ctx, $world, $full_obs)
                && ({
                    $full_obs.observe_has_item($item);
                    $ctx.has($item)
                }))
        } else if hobserve___is_magic_arrow!($ctx, $world, $item, $full_obs) {
            (((hobserve__is_adult!($ctx, $world, $full_obs)
                && ({
                    $full_obs.observe_has_item($item);
                    $ctx.has($item)
                }))
                && ({
                    $full_obs.observe_bow();
                    $ctx.has(Item::Bow)
                }))
                && ({
                    $full_obs.observe_magic_meter();
                    $ctx.has(Item::Magic_Meter)
                }))
        } else if hobserve___is_child_item!($ctx, $world, $item, $full_obs) {
            (hobserve__is_child!($ctx, $world, $full_obs)
                && ({
                    $full_obs.observe_has_item($item);
                    $ctx.has($item)
                }))
        } else {
            false
        }
    }};
}

/// $_is_magic_item ( TypedVar(name='item', type='Item') )
/// ^item IN [Dins_Fire, Farores_Wind, Nayrus_Love, Lens_of_Truth]
#[macro_export]
macro_rules! helper___is_magic_item {
    ($ctx:expr, $world:expr, $item:expr) => {{
        matches!(
            $item,
            Item::Dins_Fire | Item::Farores_Wind | Item::Nayrus_Love | Item::Lens_of_Truth
        )
    }};
}
#[macro_export]
macro_rules! hexplain___is_magic_item {
    ($ctx:expr, $world:expr, $item:expr, $edict:expr) => {{
        {
            let r = {
                let r = $item;
                if let Some(v) = $edict.get_mut(&"helpers:$_is_magic_item.^item") {
                    v.push_str(&format!(", $item: {}", r));
                } else {
                    $edict.insert("helpers:$_is_magic_item.^item", format!("$item: {}", r));
                };
                (r, vec!["helpers:$_is_magic_item.^item"])
            };
            (
                matches!(
                    r.0,
                    Item::Dins_Fire | Item::Farores_Wind | Item::Nayrus_Love | Item::Lens_of_Truth
                ),
                r.1,
            )
        }
    }};
}
#[macro_export]
macro_rules! hobserve___is_magic_item {
    ($ctx:expr, $world:expr, $item:expr, $full_obs:expr) => {{
        matches!(
            $item,
            Item::Dins_Fire | Item::Farores_Wind | Item::Nayrus_Love | Item::Lens_of_Truth
        )
    }};
}

/// $_is_adult_item ( TypedVar(name='item', type='Item') )
/// ^item IN [Bow, Megaton_Hammer, Iron_Boots, Hover_Boots, Hookshot, Goron_Tunic, Zora_Tunic, Mirror_Shield]
#[macro_export]
macro_rules! helper___is_adult_item {
    ($ctx:expr, $world:expr, $item:expr) => {{
        matches!(
            $item,
            Item::Bow
                | Item::Megaton_Hammer
                | Item::Iron_Boots
                | Item::Hover_Boots
                | Item::Hookshot
                | Item::Goron_Tunic
                | Item::Zora_Tunic
                | Item::Mirror_Shield
        )
    }};
}
#[macro_export]
macro_rules! hexplain___is_adult_item {
    ($ctx:expr, $world:expr, $item:expr, $edict:expr) => {{
        {
            let r = {
                let r = $item;
                if let Some(v) = $edict.get_mut(&"helpers:$_is_adult_item.^item") {
                    v.push_str(&format!(", $item: {}", r));
                } else {
                    $edict.insert("helpers:$_is_adult_item.^item", format!("$item: {}", r));
                };
                (r, vec!["helpers:$_is_adult_item.^item"])
            };
            (
                matches!(
                    r.0,
                    Item::Bow
                        | Item::Megaton_Hammer
                        | Item::Iron_Boots
                        | Item::Hover_Boots
                        | Item::Hookshot
                        | Item::Goron_Tunic
                        | Item::Zora_Tunic
                        | Item::Mirror_Shield
                ),
                r.1,
            )
        }
    }};
}
#[macro_export]
macro_rules! hobserve___is_adult_item {
    ($ctx:expr, $world:expr, $item:expr, $full_obs:expr) => {{
        matches!(
            $item,
            Item::Bow
                | Item::Megaton_Hammer
                | Item::Iron_Boots
                | Item::Hover_Boots
                | Item::Hookshot
                | Item::Goron_Tunic
                | Item::Zora_Tunic
                | Item::Mirror_Shield
        )
    }};
}

/// $_is_child_item ( TypedVar(name='item', type='Item') )
/// ^item IN [Slingshot, Boomerang, Kokiri_Sword]
#[macro_export]
macro_rules! helper___is_child_item {
    ($ctx:expr, $world:expr, $item:expr) => {{
        matches!(
            $item,
            Item::Slingshot | Item::Boomerang | Item::Kokiri_Sword
        )
    }};
}
#[macro_export]
macro_rules! hexplain___is_child_item {
    ($ctx:expr, $world:expr, $item:expr, $edict:expr) => {{
        {
            let r = {
                let r = $item;
                if let Some(v) = $edict.get_mut(&"helpers:$_is_child_item.^item") {
                    v.push_str(&format!(", $item: {}", r));
                } else {
                    $edict.insert("helpers:$_is_child_item.^item", format!("$item: {}", r));
                };
                (r, vec!["helpers:$_is_child_item.^item"])
            };
            (
                matches!(r.0, Item::Slingshot | Item::Boomerang | Item::Kokiri_Sword),
                r.1,
            )
        }
    }};
}
#[macro_export]
macro_rules! hobserve___is_child_item {
    ($ctx:expr, $world:expr, $item:expr, $full_obs:expr) => {{
        matches!(
            $item,
            Item::Slingshot | Item::Boomerang | Item::Kokiri_Sword
        )
    }};
}

/// $_is_magic_arrow ( TypedVar(name='item', type='Item') )
/// ^item IN [Fire_Arrows, Light_Arrows, Blue_Fire_Arrows]
#[macro_export]
macro_rules! helper___is_magic_arrow {
    ($ctx:expr, $world:expr, $item:expr) => {{
        matches!(
            $item,
            Item::Fire_Arrows | Item::Light_Arrows | Item::Blue_Fire_Arrows
        )
    }};
}
#[macro_export]
macro_rules! hexplain___is_magic_arrow {
    ($ctx:expr, $world:expr, $item:expr, $edict:expr) => {{
        {
            let r = {
                let r = $item;
                if let Some(v) = $edict.get_mut(&"helpers:$_is_magic_arrow.^item") {
                    v.push_str(&format!(", $item: {}", r));
                } else {
                    $edict.insert("helpers:$_is_magic_arrow.^item", format!("$item: {}", r));
                };
                (r, vec!["helpers:$_is_magic_arrow.^item"])
            };
            (
                matches!(
                    r.0,
                    Item::Fire_Arrows | Item::Light_Arrows | Item::Blue_Fire_Arrows
                ),
                r.1,
            )
        }
    }};
}
#[macro_export]
macro_rules! hobserve___is_magic_arrow {
    ($ctx:expr, $world:expr, $item:expr, $full_obs:expr) => {{
        matches!(
            $item,
            Item::Fire_Arrows | Item::Light_Arrows | Item::Blue_Fire_Arrows
        )
    }};
}

/// $has_explosives (  )
/// Bombs
#[macro_export]
macro_rules! helper__has_explosives {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Bombs)
    }};
}
#[macro_export]
macro_rules! hexplain__has_explosives {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Bombs);
            $edict.insert("Bombs", format!("{}", h));
            (h, vec!["Bombs"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__has_explosives {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_bombs();
            $ctx.has(Item::Bombs)
        }
    }};
}

/// $can_blast_or_smash (  )
/// $has_explosives or $can_use(Megaton_Hammer)
#[macro_export]
macro_rules! helper__can_blast_or_smash {
    ($ctx:expr, $world:expr) => {{
        (helper__has_explosives!($ctx, $world)
            || helper__can_use!($ctx, $world, Item::Megaton_Hammer))
    }};
}
#[macro_export]
macro_rules! hexplain__can_blast_or_smash {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let (res, mut refs) = hexplain__has_explosives!($ctx, $world, $edict);
                $edict.insert("$has_explosives", format!("{:?}", res));
                refs.push("$has_explosives");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) =
                        hexplain__can_use!($ctx, $world, Item::Megaton_Hammer, $edict);
                    $edict.insert("$can_use(Megaton_Hammer)", format!("{:?}", res));
                    refs.push("$can_use(Megaton_Hammer)");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_blast_or_smash {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (hobserve__has_explosives!($ctx, $world, $full_obs)
            || hobserve__can_use!($ctx, $world, Item::Megaton_Hammer, $full_obs))
    }};
}

/// $can_child_attack (  )
/// $is_child and (Slingshot or Boomerang or $Sticks or Kokiri_Sword)
#[macro_export]
macro_rules! helper__can_child_attack {
    ($ctx:expr, $world:expr) => {{
        (helper__is_child!($ctx, $world)
            && ((($ctx.has(Item::Slingshot) || $ctx.has(Item::Boomerang))
                || helper__Sticks!($ctx, $world))
                || $ctx.has(Item::Kokiri_Sword)))
    }};
}
#[macro_export]
macro_rules! hexplain__can_child_attack {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let (res, mut refs) = hexplain__is_child!($ctx, $world, $edict);
                $edict.insert("$is_child", format!("{:?}", res));
                refs.push("$is_child");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let mut left = {
                            let mut left = {
                                let h = $ctx.has(Item::Slingshot);
                                $edict.insert("Slingshot", format!("{}", h));
                                (h, vec!["Slingshot"])
                            };
                            if left.0 {
                                left
                            } else {
                                let mut right = {
                                    let h = $ctx.has(Item::Boomerang);
                                    $edict.insert("Boomerang", format!("{}", h));
                                    (h, vec!["Boomerang"])
                                };
                                left.1.append(&mut right.1);
                                (right.0, left.1)
                            }
                        };
                        if left.0 {
                            left
                        } else {
                            let mut right = {
                                let (res, mut refs) = hexplain__Sticks!($ctx, $world, $edict);
                                $edict.insert("$Sticks", format!("{:?}", res));
                                refs.push("$Sticks");
                                (res, refs)
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    };
                    if left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = $ctx.has(Item::Kokiri_Sword);
                            $edict.insert("Kokiri_Sword", format!("{}", h));
                            (h, vec!["Kokiri_Sword"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_child_attack {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (hobserve__is_child!($ctx, $world, $full_obs)
            && ((({
                $full_obs.observe_slingshot();
                $ctx.has(Item::Slingshot)
            } || {
                $full_obs.observe_boomerang();
                $ctx.has(Item::Boomerang)
            }) || hobserve__Sticks!($ctx, $world, $full_obs))
                || {
                    $full_obs.observe_kokiri_sword();
                    $ctx.has(Item::Kokiri_Sword)
                }))
    }};
}

/// $has_fire_source (  )
/// $can_use(Dins_Fire) or $can_use(Fire_Arrows)
#[macro_export]
macro_rules! helper__has_fire_source {
    ($ctx:expr, $world:expr) => {{
        (helper__can_use!($ctx, $world, Item::Dins_Fire)
            || helper__can_use!($ctx, $world, Item::Fire_Arrows))
    }};
}
#[macro_export]
macro_rules! hexplain__has_fire_source {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let (res, mut refs) = hexplain__can_use!($ctx, $world, Item::Dins_Fire, $edict);
                $edict.insert("$can_use(Dins_Fire)", format!("{:?}", res));
                refs.push("$can_use(Dins_Fire)");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) =
                        hexplain__can_use!($ctx, $world, Item::Fire_Arrows, $edict);
                    $edict.insert("$can_use(Fire_Arrows)", format!("{:?}", res));
                    refs.push("$can_use(Fire_Arrows)");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__has_fire_source {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (hobserve__can_use!($ctx, $world, Item::Dins_Fire, $full_obs)
            || hobserve__can_use!($ctx, $world, Item::Fire_Arrows, $full_obs))
    }};
}

/// $has_fire_source_with_torch (  )
/// $has_fire_source or ($is_child and $Sticks)
#[macro_export]
macro_rules! helper__has_fire_source_with_torch {
    ($ctx:expr, $world:expr) => {{
        (helper__has_fire_source!($ctx, $world)
            || (helper__is_child!($ctx, $world) && helper__Sticks!($ctx, $world)))
    }};
}
#[macro_export]
macro_rules! hexplain__has_fire_source_with_torch {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let (res, mut refs) = hexplain__has_fire_source!($ctx, $world, $edict);
                $edict.insert("$has_fire_source", format!("{:?}", res));
                refs.push("$has_fire_source");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let (res, mut refs) = hexplain__is_child!($ctx, $world, $edict);
                        $edict.insert("$is_child", format!("{:?}", res));
                        refs.push("$is_child");
                        (res, refs)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__Sticks!($ctx, $world, $edict);
                            $edict.insert("$Sticks", format!("{:?}", res));
                            refs.push("$Sticks");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__has_fire_source_with_torch {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (hobserve__has_fire_source!($ctx, $world, $full_obs)
            || (hobserve__is_child!($ctx, $world, $full_obs)
                && (hobserve__Sticks!($ctx, $world, $full_obs))))
    }};
}

/// Rule $victory
#[macro_export]
macro_rules! rule__victory {
    ($ctx:expr, $world:expr) => {{
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => rules::access___victory_invoke_objective($ctx, $world),
        }
    }};
}
#[macro_export]
macro_rules! rexplain__victory {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => rules::explain___victory_invoke_objective($ctx, $world, $edict),
        }
    }};
}
#[macro_export]
macro_rules! robserve__victory {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => {
                rules::observe_access___victory_invoke_objective($ctx, $world, $full_obs)
            }
        }
    }};
}

/// Rule $objective
#[macro_export]
macro_rules! rule__objective {
    ($ctx:expr, $world:expr) => {{
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Gohma => rules::access___deku_lobby_web_kokiri_emerald($ctx, $world),
            RuleObjective::Ganon => rules::access___defeat_ganon($ctx, $world),
            RuleObjective::TriforceHunt => {
                rules::access___triforce_piece__triforce_count($ctx, $world)
            }
        }
    }};
}
#[macro_export]
macro_rules! rexplain__objective {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Gohma => {
                rules::explain___deku_lobby_web_kokiri_emerald($ctx, $world, $edict)
            }
            RuleObjective::Ganon => rules::explain___defeat_ganon($ctx, $world, $edict),
            RuleObjective::TriforceHunt => {
                rules::explain___triforce_piece__triforce_count($ctx, $world, $edict)
            }
        }
    }};
}
#[macro_export]
macro_rules! robserve__objective {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Gohma => {
                rules::observe_access___deku_lobby_web_kokiri_emerald($ctx, $world, $full_obs)
            }
            RuleObjective::Ganon => rules::observe_access___defeat_ganon($ctx, $world, $full_obs),
            RuleObjective::TriforceHunt => {
                rules::observe_access___triforce_piece__triforce_count($ctx, $world, $full_obs)
            }
        }
    }};
}
