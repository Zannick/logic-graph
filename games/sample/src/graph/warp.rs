//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::*;
use crate::graph::{World, enums::*};
use crate::observe::FullObservation;
use crate::prices::Currency;
use crate::rules;
use analyzer::context::Ctx;
use analyzer::world;
use enum_map::{EnumMap, Enum};
use rustc_hash::FxHashMap;
use std::option::Option;

#[derive(Copy, Clone, Debug)]
pub struct Warp {
    id: WarpId,
    dest: SpotId,
    time: u32,
    price: Currency,
}
impl world::Accessible for Warp {
    type Context = Context;
    type Currency = Currency;

    fn can_access(&self, ctx: &Context, world: &World) -> bool {
        ctx.can_afford(&self.price) && match self.id {
            WarpId::Minuet => rules::access_invoke_can_play__minuet_of_forest(ctx, world),
            WarpId::Save => true,
        }
    }
    fn observe_access(&self, ctx: &Context, world: &World, full_obs: &mut FullObservation) -> bool {
        ctx.observe_afford(&self.price, full_obs);
        match self.id {
            WarpId::Minuet => rules::observe_access_invoke_can_play__minuet_of_forest(ctx, world, full_obs),
            _ => true,
        }
    }
    fn base_time(&self) -> u32 { self.time }
    fn time(&self, ctx: &Context, world: &World) -> u32 {
        self.time
            + match self.id {
            _ => 0,
        }
    }

    fn observe_time(&self, ctx: &Context, world: &World, full_obs: &mut FullObservation) -> u32 {
        self.time
            + match self.id {
            _ => 0,
        }
    }


    fn base_price(&self) -> &Currency { &self.price }
    fn price_per_sec(&self) -> &Currency { &Currency::Free }
    fn price(&self, ctx: &Context, world: &World) -> Currency { self.price }

    fn explain_rule(&self, ctx: &Self::Context, world: &World, edict: &mut FxHashMap<&'static str, String>) -> (bool, Vec<&'static str>) {
        match self.id {
            WarpId::Minuet => {
                let (ret, mut tags) = rules::explain_invoke_can_play__minuet_of_forest(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "SpotId::KF__Kokiri_Village__Shop_Porch"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            _ => (true, vec![])
        }
    }
}
impl world::Warp for Warp {
    type WarpId = WarpId;
    type SpotId = SpotId;

    fn id(&self) -> WarpId { self.id }
    fn dest(&self, ctx: &Context, world: &World) -> SpotId {
        if self.dest == SpotId::None {
            match self.id {
                WarpId::Minuet => SpotId::KF__Kokiri_Village__Shop_Porch,
                WarpId::Save => data::save(ctx.position()),
            }
        } else {
            self.dest
        }
    }
    fn connect(&mut self, dest: SpotId) { self.dest = dest; }
    fn prewarp(&self, ctx: &mut Context, world: &World) {
        match self.id {
            _ => (),
        }
    }
    fn postwarp(&self, ctx: &mut Context, world: &World) {
        match self.id {
            _ => (),
        }
    }
    fn should_reload(&self) -> bool {
        match self.id {
            WarpId::Minuet => false,
            WarpId::Save => false,
        }
    }
    fn is_bulk_exit(&self) -> bool {
        match self.id {
            WarpId::Minuet => false,
            WarpId::Save => false,
        }
    }
    fn observe_effects(&self, ctx: &mut Context, world: &World, full_obs: &mut FullObservation) {
        match self.id {
            WarpId::Minuet => {
                ctx.observe_set_position(self.dest(ctx, world), world, full_obs);
            }
            WarpId::Save => {
                ctx.observe_set_position(self.dest(ctx, world), world, full_obs);
            }
        }
    }
}

static WARP_DEFS: [Warp; 2] = [
    Warp {
        id: WarpId::Minuet,
        dest: SpotId::None,
        time: 5000,
        price: Currency::Free,
    },
    Warp {
        id: WarpId::Save,
        dest: SpotId::None,
        time: 8000,
        price: Currency::Free,
    },
];

pub(super) fn build_warps(warps: &mut EnumMap<WarpId, Warp>) {
    for (k, warp) in WARP_DEFS.iter().enumerate() {
        assert!(k == warp.id.into_usize(),
                "Order of warp ids does not match: {} defined as {} but expected to be {}",
                warp.id, warp.id.into_usize(), k);
        warps[warp.id] = *warp;
    }
}