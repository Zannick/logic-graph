//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::*;
use crate::graph::{World, enums::*};
use crate::observe::FullObservation;
use crate::prices::Currency;
use crate::rules;
use analyzer::context::Ctx;
use analyzer::world;
use enum_map::{Enum, EnumMap};
use rustc_hash::FxHashMap;

#[derive(Copy, Clone, Debug)]
pub struct Action {
    id: ActionId,
    time: u32,
    price: Currency,
    price_per_sec: Currency,
}

impl world::Accessible for Action {
    type Context = Context;
    type Currency = Currency;
    fn can_access(&self, ctx: &Context, world: &World) -> bool {
        ctx.can_afford(&self.price) && match self.id {
            ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch => rules::access_invoke_is_child_and_invoke_sticks_and_not_deku_tree__compass_room__ctx__torch(ctx, world),
            ActionId::Global__Change_Time => true,
            ActionId::KF__Kokiri_Village__Midos_Porch__Gather_Rupees => true,
        }
    }
    fn observe_access(&self, ctx: &Context, world: &World, full_obs: &mut FullObservation) -> bool {
        ctx.observe_afford(&self.price(ctx, world), full_obs);
        match self.id {
            ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch => rules::observe_access_invoke_is_child_and_invoke_sticks_and_not_deku_tree__compass_room__ctx__torch(ctx, world, full_obs),
            _ => true,
        }
    }
    fn base_time(&self) -> u32 { self.time }
    fn time(&self, ctx: &Context, world: &World) -> u32 { 
        self.time
            + match self.id {
            _ => 0,
        }
    }

    fn observe_time(&self, ctx: &Context, world: &World, full_obs: &mut FullObservation) -> u32 { 
        self.time
            + match self.id {
            _ => 0,
        }
    }


    fn base_price(&self) -> &Currency { &self.price }
    fn price_per_sec(&self) -> &Currency { &self.price_per_sec }
    fn price(&self, ctx: &Context, world: &World) -> Currency {
        if self.price_per_sec == Currency::Free {
            self.price
        } else {
            match self.id {
                _ => self.price + (self.price_per_sec * (self.time(ctx, world) as f32 / 1000.0))
            }
        }
    }

    fn explain_rule(&self, ctx: &Self::Context, world: &World, edict: &mut FxHashMap<&'static str, String>) -> (bool, Vec<&'static str>) {
        match self.id {
            ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch => {
                let (ret, mut tags) = rules::explain_invoke_is_child_and_invoke_sticks_and_not_deku_tree__compass_room__ctx__torch(ctx, world, edict);
                let dest = world::Action::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, ""));
                    tags.push("dest");
                }
                (ret, tags)
            }
            _ => (true, vec![])
        }
    }
}
impl world::Action for Action {
    type ActionId = ActionId;
    type SpotId = SpotId;
    fn id(&self) -> ActionId { self.id }
    fn perform(&self, ctx: &mut Context, world: &World) {
        match self.id {
            ActionId::Global__Change_Time => rules::action_tod_set_match_tod____day_setgt_night_night_setgt_day___setgt_day_(ctx, world),
            ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch => rules::action_deku_tree__compass_room__ctx__torch_set_true(ctx, world),
            ActionId::KF__Kokiri_Village__Midos_Porch__Gather_Rupees => rules::action_rupees_set_invoke_max__rupees_add_20_invoke_wallet_max(ctx, world),
        };
        let dest = self.dest(ctx, world);
        if dest != SpotId::None {
            ctx.set_position(dest, world);
        }
        match self.id {
            _ => (),
        };
    }
    fn dest(&self, ctx: &Context, world: &World) -> SpotId {
        match self.id {
            _ => SpotId::None,
        }
    }
    fn observe_effects(&self, ctx: &mut Context, world: &World, full_obs: &mut FullObservation) {
        match self.id {
            ActionId::Global__Change_Time => {
                rules::observe_action_tod_set_match_tod____day_setgt_night_night_setgt_day___setgt_day_(ctx, world, full_obs);
                let dest = self.dest(ctx, world);
                if dest != SpotId::None {
                    ctx.observe_set_position(dest, world, full_obs);
                }
            }
            ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch => {
                rules::observe_action_deku_tree__compass_room__ctx__torch_set_true(ctx, world, full_obs);
                let dest = self.dest(ctx, world);
                if dest != SpotId::None {
                    ctx.observe_set_position(dest, world, full_obs);
                }
            }
            ActionId::KF__Kokiri_Village__Midos_Porch__Gather_Rupees => {
                rules::observe_action_rupees_set_invoke_max__rupees_add_20_invoke_wallet_max(ctx, world, full_obs);
                let dest = self.dest(ctx, world);
                if dest != SpotId::None {
                    ctx.observe_set_position(dest, world, full_obs);
                }
            }
        }
    }
}

static ACT_DEFS: [Action; 3] = [
    Action {
        id: ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch,
        time: 1000,
        price: Currency::Free,
        price_per_sec: Currency::Free,
    },
    Action {
        id: ActionId::Global__Change_Time,
        time: 2000,
        price: Currency::Rupees(10),
        price_per_sec: Currency::Free,
    },
    Action {
        id: ActionId::KF__Kokiri_Village__Midos_Porch__Gather_Rupees,
        time: 20000,
        price: Currency::Free,
        price_per_sec: Currency::Free,
    },
];

pub(super) fn build_actions(actions: &mut EnumMap<ActionId, Action>) {
    for (k, act) in ACT_DEFS.iter().enumerate() {
        assert!(k == act.id.into_usize(),
                "Order of location ids does not match: {} defined as {} but expected to be {}",
                act.id, act.id.into_usize(), k);
        actions[act.id] = *act;
    }
}

pub fn get_action_spot(act_id: ActionId) -> SpotId {
    match act_id {
        ActionId::Deku_Tree__Compass_Room__Entry__Light_Torch => SpotId::Deku_Tree__Compass_Room__Entry,
        ActionId::KF__Kokiri_Village__Midos_Porch__Gather_Rupees => SpotId::KF__Kokiri_Village__Midos_Porch,
        _ => SpotId::None,
    }
}

pub fn action_has_visit(act_id: ActionId) -> bool {
    match act_id {
        _ => false,
    }
}