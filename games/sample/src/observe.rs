//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::{data, enums, flags, Context};
use crate::graph::{self, *};
use crate::graph_enums::*;
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::matchertrie::*;
use analyzer::observer::*;
use analyzer::solutions::{Solution, SolutionSuffix};
use std::sync::{Arc, Mutex};

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum OneObservation {
    Position(SpotId),
    Tod(enums::Tod),
    RupeesExact(i32),
    RupeesEq(i32, bool),
    RupeesGe(i32, bool),
    RupeesLe(i32, bool),
    RupeesRange(i32, i32, bool),
    // items
    GoldSkulltulaTokenExact(i8),
    GoldSkulltulaTokenEq(i8, bool),
    GoldSkulltulaTokenGe(i8, bool),
    GoldSkulltulaTokenLe(i8, bool),
    GoldSkulltulaTokenRange(i8, i8, bool),
    ProgressiveWalletExact(i8),
    ProgressiveWalletEq(i8, bool),
    ProgressiveWalletGe(i8, bool),
    ProgressiveWalletLe(i8, bool),
    ProgressiveWalletRange(i8, i8, bool),
    TriforcePieceExact(i16),
    TriforcePieceEq(i16, bool),
    TriforcePieceGe(i16, bool),
    TriforcePieceLe(i16, bool),
    TriforcePieceRange(i16, i16, bool),
    // bitflags
    CBits1 {
        mask: flags::ContextBits1,
        result: flags::ContextBits1,
    },
    CBits2 {
        mask: flags::ContextBits2,
        result: flags::ContextBits2,
    },
}

#[derive(Debug, Default)]
pub struct FullObservation {
    // context vars: observed or not. Ints get comparisons as well but they are observed-as-true comparisons,
    // or otherwise partitioned as exact
    position: bool,
    tod: bool,
    rupees: IntegerObservation<i32>,
    // items
    gold_skulltula_token: IntegerObservation<i8>,
    progressive_wallet: IntegerObservation<i8>,
    triforce_piece: IntegerObservation<i16>,
    // bitflags: optionally a mask
    cbits1: Option<flags::ContextBits1>,
    cbits2: Option<flags::ContextBits2>,
    pub strict: bool,
}

impl Observer for FullObservation {
    type Ctx = Context;
    type Matcher = ObservationMatcher;

    fn from_victory_state(won: &Context, world: &World) -> Self {
        let mut full_obs = Self::default();
        full_obs.position = true;
        match world.rule_victory {
            RuleVictory::Default => {
                rules::observe_access___victory_objective(won, world, &mut full_obs);
            }
        }
        full_obs
    }

    fn observe_visit(&mut self, loc_id: LocationId) {
        match loc_id {
            LocationId::Deku_Tree__Lobby__Center__Deku_Baba_Sticks => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_DEKU_TREE__LOBBY__CENTER__DEKU_BABA_STICKS,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_DEKU_TREE__LOBBY__CENTER__DEKU_BABA_STICKS,
                );
            }
            LocationId::Deku_Tree__Lobby__Center__Deku_Baba_Nuts => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__LOBBY__CENTER__DEKU_BABA_NUTS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__LOBBY__CENTER__DEKU_BABA_NUTS);
            }
            LocationId::Deku_Tree__Lobby__Center__Web => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__LOBBY__CENTER__WEB);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__LOBBY__CENTER__WEB);
            }
            LocationId::Deku_Tree__Floor_2__Vines__Map_Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__FLOOR_2__VINES__MAP_CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__FLOOR_2__VINES__MAP_CHEST);
            }
            LocationId::Deku_Tree__Scrub_Room__Entry__Scrub => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__SCRUB_ROOM__ENTRY__SCRUB);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__SCRUB_ROOM__ENTRY__SCRUB);
            }
            LocationId::Deku_Tree__Slingshot_Room__Slingshot__Chest => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_DEKU_TREE__SLINGSHOT_ROOM__SLINGSHOT__CHEST,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_DEKU_TREE__SLINGSHOT_ROOM__SLINGSHOT__CHEST,
                );
            }
            LocationId::Deku_Tree__Slingshot_Upper__Ledge__Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__SLINGSHOT_UPPER__LEDGE__CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__SLINGSHOT_UPPER__LEDGE__CHEST);
            }
            LocationId::Deku_Tree__Floor_3__Door__Break_Web => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__FLOOR_3__DOOR__BREAK_WEB);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__FLOOR_3__DOOR__BREAK_WEB);
            }
            LocationId::Deku_Tree__Compass_Room__Entry__Burn_Web => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__COMPASS_ROOM__ENTRY__BURN_WEB);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__COMPASS_ROOM__ENTRY__BURN_WEB);
            }
            LocationId::Deku_Tree__Compass_Room__Compass__Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__COMPASS_ROOM__COMPASS__CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__COMPASS_ROOM__COMPASS__CHEST);
            }
            LocationId::Deku_Tree__Compass_Room__Ledge__Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__COMPASS_ROOM__LEDGE__CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__COMPASS_ROOM__LEDGE__CHEST);
            }
            LocationId::Deku_Tree__Compass_Room__Ledge__GS => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__COMPASS_ROOM__LEDGE__GS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__COMPASS_ROOM__LEDGE__GS);
            }
            LocationId::Deku_Tree__Basement_1__Center__Vines_GS => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_1__CENTER__VINES_GS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_1__CENTER__VINES_GS);
            }
            LocationId::Deku_Tree__Basement_1__Corner__Switch => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_1__CORNER__SWITCH);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_1__CORNER__SWITCH);
            }
            LocationId::Deku_Tree__Basement_1__Corner__Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_1__CORNER__CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_1__CORNER__CHEST);
            }
            LocationId::Deku_Tree__Basement_1__Corner__Gate_GS => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_1__CORNER__GATE_GS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_1__CORNER__GATE_GS);
            }
            LocationId::Deku_Tree__Basement_1__Corner__Burn_Basement_Web => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_1__CORNER__BURN_BASEMENT_WEB,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_1__CORNER__BURN_BASEMENT_WEB,
                );
            }
            LocationId::Deku_Tree__Back_Room__Northwest__Burn_Web => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BACK_ROOM__NORTHWEST__BURN_WEB);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BACK_ROOM__NORTHWEST__BURN_WEB);
            }
            LocationId::Deku_Tree__Back_Room__Northwest__Break_Wall => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_DEKU_TREE__BACK_ROOM__NORTHWEST__BREAK_WALL,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_DEKU_TREE__BACK_ROOM__NORTHWEST__BREAK_WALL,
                );
            }
            LocationId::Deku_Tree__Skull_Room__Entry__GS => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__SKULL_ROOM__ENTRY__GS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__SKULL_ROOM__ENTRY__GS);
            }
            LocationId::Deku_Tree__Basement_Ledge__Block__Push_Block => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_LEDGE__BLOCK__PUSH_BLOCK,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_LEDGE__BLOCK__PUSH_BLOCK,
                );
            }
            LocationId::Deku_Tree__Basement_Ledge__Web__Burn_Web => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_LEDGE__WEB__BURN_WEB);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_LEDGE__WEB__BURN_WEB);
            }
            LocationId::Deku_Tree__Basement_2__Boss_Door__Scrubs => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BASEMENT_2__BOSS_DOOR__SCRUBS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BASEMENT_2__BOSS_DOOR__SCRUBS);
            }
            LocationId::Deku_Tree__Boss_Room__Arena__Gohma => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BOSS_ROOM__ARENA__GOHMA);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BOSS_ROOM__ARENA__GOHMA);
            }
            LocationId::Deku_Tree__Boss_Room__Arena__Gohma_Quick_Kill => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_DEKU_TREE__BOSS_ROOM__ARENA__GOHMA_QUICK_KILL,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_DEKU_TREE__BOSS_ROOM__ARENA__GOHMA_QUICK_KILL,
                );
            }
            LocationId::Deku_Tree__Boss_Room__Arena__Gohma_Heart => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BOSS_ROOM__ARENA__GOHMA_HEART);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BOSS_ROOM__ARENA__GOHMA_HEART);
            }
            LocationId::Deku_Tree__Boss_Room__Arena__Blue_Warp => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_DEKU_TREE__BOSS_ROOM__ARENA__BLUE_WARP);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_DEKU_TREE__BOSS_ROOM__ARENA__BLUE_WARP);
            }
            LocationId::KF__Kokiri_Village__Training_Center__Victory => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_KF__KOKIRI_VILLAGE__TRAINING_CENTER__VICTORY,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_KF__KOKIRI_VILLAGE__TRAINING_CENTER__VICTORY,
                );
            }
            LocationId::KF__Kokiri_Village__Midos_Guardpost__Show_Mido => {
                self.cbits1.insert(
                    flags::ContextBits1::VISITED_KF__KOKIRI_VILLAGE__MIDOS_GUARDPOST__SHOW_MIDO,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_KF__KOKIRI_VILLAGE__MIDOS_GUARDPOST__SHOW_MIDO,
                );
            }
            LocationId::KF__Boulder_Maze__Reward__Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_KF__BOULDER_MAZE__REWARD__CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__BOULDER_MAZE__REWARD__CHEST);
            }
            LocationId::KF__Baba_Corridor__Deku_Babas__Sticks => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_KF__BABA_CORRIDOR__DEKU_BABAS__STICKS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__BABA_CORRIDOR__DEKU_BABAS__STICKS);
            }
            LocationId::KF__Baba_Corridor__Deku_Babas__Nuts => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_KF__BABA_CORRIDOR__DEKU_BABAS__NUTS);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__BABA_CORRIDOR__DEKU_BABAS__NUTS);
            }
            LocationId::KF__Outside_Deku_Tree__Left__Gossip_Stone => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__OUTSIDE_DEKU_TREE__LEFT__GOSSIP_STONE);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__OUTSIDE_DEKU_TREE__LEFT__GOSSIP_STONE);
            }
            LocationId::KF__Outside_Deku_Tree__Right__Gossip_Stone => {
                self.cbits2.insert(
                    flags::ContextBits2::VISITED_KF__OUTSIDE_DEKU_TREE__RIGHT__GOSSIP_STONE,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_KF__OUTSIDE_DEKU_TREE__RIGHT__GOSSIP_STONE,
                );
            }
            LocationId::KF__Midos_House__Entry__Top_Left_Chest => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__MIDOS_HOUSE__ENTRY__TOP_LEFT_CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__MIDOS_HOUSE__ENTRY__TOP_LEFT_CHEST);
            }
            LocationId::KF__Midos_House__Entry__Top_Right_Chest => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__MIDOS_HOUSE__ENTRY__TOP_RIGHT_CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__MIDOS_HOUSE__ENTRY__TOP_RIGHT_CHEST);
            }
            LocationId::KF__Midos_House__Entry__Bottom_Left_Chest => {
                self.cbits1
                    .insert(flags::ContextBits1::VISITED_KF__MIDOS_HOUSE__ENTRY__BOTTOM_LEFT_CHEST);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__MIDOS_HOUSE__ENTRY__BOTTOM_LEFT_CHEST);
            }
            LocationId::KF__Midos_House__Entry__Bottom_Right_Chest => {
                self.cbits2.insert(
                    flags::ContextBits2::VISITED_KF__MIDOS_HOUSE__ENTRY__BOTTOM_RIGHT_CHEST,
                );
                self.cbits2.insert(
                    flags::ContextBits2::SKIPPED_KF__MIDOS_HOUSE__ENTRY__BOTTOM_RIGHT_CHEST,
                );
            }
            LocationId::KF__Shop__Entry__Blue_Rupee => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__BLUE_RUPEE);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__BLUE_RUPEE);
            }
            LocationId::KF__Shop__Entry__Item_1 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_1);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_1);
            }
            LocationId::KF__Shop__Entry__Item_2 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_2);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_2);
            }
            LocationId::KF__Shop__Entry__Item_3 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_3);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_3);
            }
            LocationId::KF__Shop__Entry__Item_4 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_4);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_4);
            }
            LocationId::KF__Shop__Entry__Item_5 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_5);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_5);
            }
            LocationId::KF__Shop__Entry__Item_6 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_6);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_6);
            }
            LocationId::KF__Shop__Entry__Item_7 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_7);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_7);
            }
            LocationId::KF__Shop__Entry__Item_8 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KF__SHOP__ENTRY__ITEM_8);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KF__SHOP__ENTRY__ITEM_8);
            }
            LocationId::Kak__Spider_House__Entry__Skulls_10 => {
                self.cbits2
                    .insert(flags::ContextBits2::VISITED_KAK__SPIDER_HOUSE__ENTRY__SKULLS_10);
                self.cbits2
                    .insert(flags::ContextBits2::SKIPPED_KAK__SPIDER_HOUSE__ENTRY__SKULLS_10);
            }
        }
    }

    fn observe_collect(&mut self, ctx: &Context, item: Item, world: &World) {
        match item {
            Item::Rupee_1 => {
                rules::observe_action_rupees_set_min__rupees_add_1_wallet_max(ctx, world, self)
            }
            Item::Rupees_5 => {
                rules::observe_action_rupees_set_min__rupees_add_5_wallet_max(ctx, world, self)
            }
            Item::Rupees_50 => {
                rules::observe_action_rupees_set_min__rupees_add_50_wallet_max(ctx, world, self)
            }
            _ => (),
        }
    }

    fn observe_on_entry(&mut self, cur: &Context, dest: SpotId, world: &World) {
        let area = get_area(dest);
        match area {
            _ => (),
        }
    }

    fn update(&mut self, from: &Context, to: &Context) {
        if from.rupees != to.rupees {
            self.rupees = self.rupees.shift(to.rupees - from.rupees);
        }
        if from.gold_skulltula_token != to.gold_skulltula_token {
            self.gold_skulltula_token = self
                .gold_skulltula_token
                .shift(to.gold_skulltula_token - from.gold_skulltula_token);
        }
        if from.progressive_wallet != to.progressive_wallet {
            self.progressive_wallet = self
                .progressive_wallet
                .shift(to.progressive_wallet - from.progressive_wallet);
        }
        if from.triforce_piece != to.triforce_piece {
            self.triforce_piece = self
                .triforce_piece
                .shift(to.triforce_piece - from.triforce_piece);
        }
    }

    fn to_vec(&self, ctx: &Context) -> Vec<OneObservation> {
        let mut vec = Vec::with_capacity(self.fields_observed());
        if self.position {
            vec.push(OneObservation::Position(ctx.position));
        }
        if self.tod {
            vec.push(OneObservation::Tod(ctx.tod));
        }
        match self.rupees {
            IntegerObservation::Unknown => (),
            IntegerObservation::Exact => vec.push(OneObservation::RupeesExact(ctx.rupees)),
            IntegerObservation::Eq(i) => vec.push(OneObservation::RupeesEq(i, ctx.rupees == i)),
            IntegerObservation::Ge(i) => vec.push(OneObservation::RupeesGe(i, ctx.rupees >= i)),
            IntegerObservation::Le(i) => vec.push(OneObservation::RupeesLe(i, ctx.rupees <= i)),
            IntegerObservation::Range(lo, hi) => vec.push(OneObservation::RupeesRange(
                lo,
                hi,
                ctx.rupees >= lo && ctx.rupees <= hi,
            )),
        }
        match self.gold_skulltula_token {
            IntegerObservation::Unknown => (),
            IntegerObservation::Exact => vec.push(OneObservation::GoldSkulltulaTokenExact(
                ctx.gold_skulltula_token,
            )),
            IntegerObservation::Eq(i) => vec.push(OneObservation::GoldSkulltulaTokenEq(
                i,
                ctx.gold_skulltula_token == i,
            )),
            IntegerObservation::Ge(i) => vec.push(OneObservation::GoldSkulltulaTokenGe(
                i,
                ctx.gold_skulltula_token >= i,
            )),
            IntegerObservation::Le(i) => vec.push(OneObservation::GoldSkulltulaTokenLe(
                i,
                ctx.gold_skulltula_token <= i,
            )),
            IntegerObservation::Range(lo, hi) => vec.push(OneObservation::GoldSkulltulaTokenRange(
                lo,
                hi,
                ctx.gold_skulltula_token >= lo && ctx.gold_skulltula_token <= hi,
            )),
        }
        match self.progressive_wallet {
            IntegerObservation::Unknown => (),
            IntegerObservation::Exact => vec.push(OneObservation::ProgressiveWalletExact(
                ctx.progressive_wallet,
            )),
            IntegerObservation::Eq(i) => vec.push(OneObservation::ProgressiveWalletEq(
                i,
                ctx.progressive_wallet == i,
            )),
            IntegerObservation::Ge(i) => vec.push(OneObservation::ProgressiveWalletGe(
                i,
                ctx.progressive_wallet >= i,
            )),
            IntegerObservation::Le(i) => vec.push(OneObservation::ProgressiveWalletLe(
                i,
                ctx.progressive_wallet <= i,
            )),
            IntegerObservation::Range(lo, hi) => vec.push(OneObservation::ProgressiveWalletRange(
                lo,
                hi,
                ctx.progressive_wallet >= lo && ctx.progressive_wallet <= hi,
            )),
        }
        match self.triforce_piece {
            IntegerObservation::Unknown => (),
            IntegerObservation::Exact => {
                vec.push(OneObservation::TriforcePieceExact(ctx.triforce_piece))
            }
            IntegerObservation::Eq(i) => {
                vec.push(OneObservation::TriforcePieceEq(i, ctx.triforce_piece == i))
            }
            IntegerObservation::Ge(i) => {
                vec.push(OneObservation::TriforcePieceGe(i, ctx.triforce_piece >= i))
            }
            IntegerObservation::Le(i) => {
                vec.push(OneObservation::TriforcePieceLe(i, ctx.triforce_piece <= i))
            }
            IntegerObservation::Range(lo, hi) => vec.push(OneObservation::TriforcePieceRange(
                lo,
                hi,
                ctx.triforce_piece >= lo && ctx.triforce_piece <= hi,
            )),
        }
        if let Some(mask) = self.cbits1 {
            vec.push(OneObservation::CBits1 {
                mask,
                result: mask & ctx.cbits1,
            });
        }
        if let Some(mask) = self.cbits2 {
            vec.push(OneObservation::CBits2 {
                mask,
                result: mask & ctx.cbits2,
            });
        }
        vec
    }
}

impl FullObservation {
    fn fields_observed(&self) -> usize {
        let mut fields = 0;
        if self.position {
            fields += 1;
        }
        if self.tod {
            fields += 1;
        }
        if self.rupees != IntegerObservation::Unknown {
            fields += 1;
        }
        if self.gold_skulltula_token != IntegerObservation::Unknown {
            fields += 1;
        }
        if self.progressive_wallet != IntegerObservation::Unknown {
            fields += 1;
        }
        if self.triforce_piece != IntegerObservation::Unknown {
            fields += 1;
        }
        if self.cbits1.is_some() {
            fields += 1;
        }
        if self.cbits2.is_some() {
            fields += 1;
        }
        fields
    }

    pub fn observe_position(&mut self) {
        self.position = true;
    }
    pub fn observe_child(&mut self) {
        self.cbits1.insert(flags::ContextBits1::CHILD);
    }
    pub fn observe_tod(&mut self) {
        self.tod = true;
    }
    pub fn observe_rupees(&mut self, obs: IntegerObservation<i32>) {
        if self.strict {
            self.rupees = IntegerObservation::Exact;
        } else {
            self.rupees = self.rupees.combine(obs);
        }
    }
    pub fn observe_deku_tree__compass_room__ctx__torch(&mut self) {
        self.cbits1
            .insert(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
    }
    pub fn observe_biggoron_sword(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BIGGORON_SWORD);
    }
    pub fn observe_bombs(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BOMBS);
    }
    pub fn observe_boomerang(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BOOMERANG);
    }
    pub fn observe_bow(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BOW);
    }
    pub fn observe_buy_deku_nut_10(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_10);
    }
    pub fn observe_buy_deku_nut_5(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_5);
    }
    pub fn observe_buy_deku_shield(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BUY_DEKU_SHIELD);
    }
    pub fn observe_buy_deku_stick_1(&mut self) {
        self.cbits1.insert(flags::ContextBits1::BUY_DEKU_STICK_1);
    }
    pub fn observe_defeat_ganon(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEFEAT_GANON);
    }
    pub fn observe_defeat_gohma(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEFEAT_GOHMA);
    }
    pub fn observe_deku_back_room_wall(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
    }
    pub fn observe_deku_back_room_web(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
    }
    pub fn observe_deku_basement_block(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
    }
    pub fn observe_deku_basement_scrubs(&mut self) {
        self.cbits1
            .insert(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
    }
    pub fn observe_deku_basement_switch(&mut self) {
        self.cbits1
            .insert(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
    }
    pub fn observe_deku_basement_web(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_WEB);
    }
    pub fn observe_deku_lobby_web(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_LOBBY_WEB);
    }
    pub fn observe_deku_nut_drop(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_NUT_DROP);
    }
    pub fn observe_deku_shield_drop(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_SHIELD_DROP);
    }
    pub fn observe_deku_slingshot_scrub(&mut self) {
        self.cbits1
            .insert(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
    }
    pub fn observe_deku_stick_drop(&mut self) {
        self.cbits1.insert(flags::ContextBits1::DEKU_STICK_DROP);
    }
    pub fn observe_gold_skulltula_token(&mut self, obs: IntegerObservation<i8>) {
        if self.strict {
            self.gold_skulltula_token = IntegerObservation::Exact;
        } else {
            self.gold_skulltula_token = self.gold_skulltula_token.combine(obs);
        }
    }
    pub fn observe_hylian_shield(&mut self) {
        self.cbits1.insert(flags::ContextBits1::HYLIAN_SHIELD);
    }
    pub fn observe_kokiri_emerald(&mut self) {
        self.cbits1.insert(flags::ContextBits1::KOKIRI_EMERALD);
    }
    pub fn observe_kokiri_sword(&mut self) {
        self.cbits1.insert(flags::ContextBits1::KOKIRI_SWORD);
    }
    pub fn observe_magic_meter(&mut self) {
        self.cbits1.insert(flags::ContextBits1::MAGIC_METER);
    }
    pub fn observe_ocarina(&mut self) {
        self.cbits1.insert(flags::ContextBits1::OCARINA);
    }
    pub fn observe_progressive_wallet(&mut self, obs: IntegerObservation<i8>) {
        if self.strict {
            self.progressive_wallet = IntegerObservation::Exact;
        } else {
            self.progressive_wallet = self.progressive_wallet.combine(obs);
        }
    }
    pub fn observe_showed_mido(&mut self) {
        self.cbits1.insert(flags::ContextBits1::SHOWED_MIDO);
    }
    pub fn observe_slingshot(&mut self) {
        self.cbits1.insert(flags::ContextBits1::SLINGSHOT);
    }
    pub fn observe_triforce_piece(&mut self, obs: IntegerObservation<i16>) {
        if self.strict {
            self.triforce_piece = IntegerObservation::Exact;
        } else {
            self.triforce_piece = self.triforce_piece.combine(obs);
        }
    }
    pub fn observe_victory(&mut self) {
        self.cbits1.insert(flags::ContextBits1::VICTORY);
    }
}

#[derive(Debug)]
pub enum ObservationMatcher {
    PositionLookup(LookupMatcher<Node<Self>, SpotId, SolutionSuffix<Context>>),
    TodLookup(LookupMatcher<Node<Self>, enums::Tod, SolutionSuffix<Context>>),
    RupeesLookup(LookupMatcher<Node<Self>, i32, SolutionSuffix<Context>>),
    RupeesEq {
        eq: i32,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    RupeesGe {
        lo: i32,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    RupeesLe {
        hi: i32,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    RupeesRange {
        lo: i32,
        hi: i32,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    // items
    GoldSkulltulaTokenLookup(LookupMatcher<Node<Self>, i8, SolutionSuffix<Context>>),
    GoldSkulltulaTokenEq {
        eq: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    GoldSkulltulaTokenGe {
        lo: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    GoldSkulltulaTokenLe {
        hi: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    GoldSkulltulaTokenRange {
        lo: i8,
        hi: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    ProgressiveWalletLookup(LookupMatcher<Node<Self>, i8, SolutionSuffix<Context>>),
    ProgressiveWalletEq {
        eq: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    ProgressiveWalletGe {
        lo: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    ProgressiveWalletLe {
        hi: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    ProgressiveWalletRange {
        lo: i8,
        hi: i8,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    TriforcePieceLookup(LookupMatcher<Node<Self>, i16, SolutionSuffix<Context>>),
    TriforcePieceEq {
        eq: i16,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    TriforcePieceGe {
        lo: i16,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    TriforcePieceLe {
        hi: i16,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    TriforcePieceRange {
        lo: i16,
        hi: i16,
        matcher: BooleanMatcher<Node<Self>, SolutionSuffix<Context>>,
    },
    // bitflags
    LookupCBits1 {
        mask: flags::ContextBits1,
        matcher: LookupMatcher<Node<Self>, flags::ContextBits1, SolutionSuffix<Context>>,
    },
    LookupCBits2 {
        mask: flags::ContextBits2,
        matcher: LookupMatcher<Node<Self>, flags::ContextBits2, SolutionSuffix<Context>>,
    },
}

impl Default for ObservationMatcher {
    fn default() -> Self {
        Self::PositionLookup(LookupMatcher::new())
    }
}

impl MatcherDispatch for ObservationMatcher {
    type Node = Node<Self>;
    type Struct = Context;
    type Value = SolutionSuffix<Context>;
    fn new(obs: &OneObservation) -> (Arc<Mutex<Node<Self>>>, Self) {
        match obs {
            &OneObservation::Position(v) => {
                let (node, m) = LookupMatcher::new_with(v);
                (node, ObservationMatcher::PositionLookup(m))
            }
            &OneObservation::Tod(v) => {
                let (node, m) = LookupMatcher::new_with(v);
                (node, ObservationMatcher::TodLookup(m))
            }
            &OneObservation::RupeesExact(v) => {
                let (node, m) = LookupMatcher::new_with(v);
                (node, ObservationMatcher::RupeesLookup(m))
            }
            &OneObservation::RupeesEq(eq, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::RupeesEq { eq, matcher })
            }
            &OneObservation::RupeesGe(lo, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::RupeesGe { lo, matcher })
            }
            &OneObservation::RupeesLe(hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::RupeesLe { hi, matcher })
            }
            &OneObservation::RupeesRange(lo, hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::RupeesRange { lo, hi, matcher })
            }
            &OneObservation::GoldSkulltulaTokenExact(v) => {
                let (node, m) = LookupMatcher::new_with(v);
                (node, ObservationMatcher::GoldSkulltulaTokenLookup(m))
            }
            &OneObservation::GoldSkulltulaTokenEq(eq, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::GoldSkulltulaTokenEq { eq, matcher },
                )
            }
            &OneObservation::GoldSkulltulaTokenGe(lo, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::GoldSkulltulaTokenGe { lo, matcher },
                )
            }
            &OneObservation::GoldSkulltulaTokenLe(hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::GoldSkulltulaTokenLe { hi, matcher },
                )
            }
            &OneObservation::GoldSkulltulaTokenRange(lo, hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::GoldSkulltulaTokenRange { lo, hi, matcher },
                )
            }
            &OneObservation::ProgressiveWalletExact(v) => {
                let (node, m) = LookupMatcher::new_with(v);
                (node, ObservationMatcher::ProgressiveWalletLookup(m))
            }
            &OneObservation::ProgressiveWalletEq(eq, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::ProgressiveWalletEq { eq, matcher },
                )
            }
            &OneObservation::ProgressiveWalletGe(lo, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::ProgressiveWalletGe { lo, matcher },
                )
            }
            &OneObservation::ProgressiveWalletLe(hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::ProgressiveWalletLe { hi, matcher },
                )
            }
            &OneObservation::ProgressiveWalletRange(lo, hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::ProgressiveWalletRange { lo, hi, matcher },
                )
            }
            &OneObservation::TriforcePieceExact(v) => {
                let (node, m) = LookupMatcher::new_with(v);
                (node, ObservationMatcher::TriforcePieceLookup(m))
            }
            &OneObservation::TriforcePieceEq(eq, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::TriforcePieceEq { eq, matcher })
            }
            &OneObservation::TriforcePieceGe(lo, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::TriforcePieceGe { lo, matcher })
            }
            &OneObservation::TriforcePieceLe(hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (node, ObservationMatcher::TriforcePieceLe { hi, matcher })
            }
            &OneObservation::TriforcePieceRange(lo, hi, res) => {
                let (node, matcher) = BooleanMatcher::new_with(res);
                (
                    node,
                    ObservationMatcher::TriforcePieceRange { lo, hi, matcher },
                )
            }
            &OneObservation::CBits1 { mask, result } => {
                let (node, matcher) = LookupMatcher::new_with(result);
                (node, ObservationMatcher::LookupCBits1 { mask, matcher })
            }
            &OneObservation::CBits2 { mask, result } => {
                let (node, matcher) = LookupMatcher::new_with(result);
                (node, ObservationMatcher::LookupCBits2 { mask, matcher })
            }
        }
    }

    fn clear(&mut self) {
        match self {
            Self::PositionLookup(m) => m.clear(),
            Self::TodLookup(m) => m.clear(),
            Self::RupeesLookup(m) => m.clear(),
            Self::RupeesEq { matcher, .. } => matcher.clear(),
            Self::RupeesGe { matcher, .. } => matcher.clear(),
            Self::RupeesLe { matcher, .. } => matcher.clear(),
            Self::RupeesRange { matcher, .. } => matcher.clear(),
            Self::GoldSkulltulaTokenLookup(m) => m.clear(),
            Self::GoldSkulltulaTokenEq { matcher, .. } => matcher.clear(),
            Self::GoldSkulltulaTokenGe { matcher, .. } => matcher.clear(),
            Self::GoldSkulltulaTokenLe { matcher, .. } => matcher.clear(),
            Self::GoldSkulltulaTokenRange { matcher, .. } => matcher.clear(),
            Self::ProgressiveWalletLookup(m) => m.clear(),
            Self::ProgressiveWalletEq { matcher, .. } => matcher.clear(),
            Self::ProgressiveWalletGe { matcher, .. } => matcher.clear(),
            Self::ProgressiveWalletLe { matcher, .. } => matcher.clear(),
            Self::ProgressiveWalletRange { matcher, .. } => matcher.clear(),
            Self::TriforcePieceLookup(m) => m.clear(),
            Self::TriforcePieceEq { matcher, .. } => matcher.clear(),
            Self::TriforcePieceGe { matcher, .. } => matcher.clear(),
            Self::TriforcePieceLe { matcher, .. } => matcher.clear(),
            Self::TriforcePieceRange { matcher, .. } => matcher.clear(),
            Self::LookupCBits1 { matcher, .. } => matcher.clear(),
            Self::LookupCBits2 { matcher, .. } => matcher.clear(),
        }
    }

    fn lookup(&self, val: &Context) -> (Option<Arc<Mutex<Node<Self>>>>, Vec<Self::Value>) {
        match self {
            Self::PositionLookup(m) => m.lookup(val.position),
            Self::TodLookup(m) => m.lookup(val.tod),
            Self::RupeesLookup(m) => m.lookup(val.rupees),
            Self::RupeesEq { eq, matcher } => matcher.lookup(val.rupees == *eq),
            Self::RupeesGe { lo, matcher } => matcher.lookup(val.rupees >= *lo),
            Self::RupeesLe { hi, matcher } => matcher.lookup(val.rupees <= *hi),
            Self::RupeesRange { lo, hi, matcher } => {
                matcher.lookup(val.rupees >= *lo && val.rupees <= *hi)
            }
            Self::GoldSkulltulaTokenLookup(m) => m.lookup(val.gold_skulltula_token),
            Self::GoldSkulltulaTokenEq { eq, matcher } => {
                matcher.lookup(val.gold_skulltula_token == *eq)
            }
            Self::GoldSkulltulaTokenGe { lo, matcher } => {
                matcher.lookup(val.gold_skulltula_token >= *lo)
            }
            Self::GoldSkulltulaTokenLe { hi, matcher } => {
                matcher.lookup(val.gold_skulltula_token <= *hi)
            }
            Self::GoldSkulltulaTokenRange { lo, hi, matcher } => {
                matcher.lookup(val.gold_skulltula_token >= *lo && val.gold_skulltula_token <= *hi)
            }
            Self::ProgressiveWalletLookup(m) => m.lookup(val.progressive_wallet),
            Self::ProgressiveWalletEq { eq, matcher } => {
                matcher.lookup(val.progressive_wallet == *eq)
            }
            Self::ProgressiveWalletGe { lo, matcher } => {
                matcher.lookup(val.progressive_wallet >= *lo)
            }
            Self::ProgressiveWalletLe { hi, matcher } => {
                matcher.lookup(val.progressive_wallet <= *hi)
            }
            Self::ProgressiveWalletRange { lo, hi, matcher } => {
                matcher.lookup(val.progressive_wallet >= *lo && val.progressive_wallet <= *hi)
            }
            Self::TriforcePieceLookup(m) => m.lookup(val.triforce_piece),
            Self::TriforcePieceEq { eq, matcher } => matcher.lookup(val.triforce_piece == *eq),
            Self::TriforcePieceGe { lo, matcher } => matcher.lookup(val.triforce_piece >= *lo),
            Self::TriforcePieceLe { hi, matcher } => matcher.lookup(val.triforce_piece <= *hi),
            Self::TriforcePieceRange { lo, hi, matcher } => {
                matcher.lookup(val.triforce_piece >= *lo && val.triforce_piece <= *hi)
            }
            Self::LookupCBits1 { mask, matcher } => matcher.lookup(val.cbits1 & *mask),
            Self::LookupCBits2 { mask, matcher } => matcher.lookup(val.cbits2 & *mask),
        }
    }

    fn insert(&mut self, obs: &OneObservation) -> Option<Arc<Mutex<Node<Self>>>> {
        match (self, obs) {
            (Self::PositionLookup(m), OneObservation::Position(v)) => Some(m.insert(*v)),
            (Self::TodLookup(m), OneObservation::Tod(v)) => Some(m.insert(*v)),
            (Self::RupeesLookup(m), OneObservation::RupeesExact(v)) => Some(m.insert(*v)),
            (Self::RupeesEq { eq, matcher }, OneObservation::RupeesEq(eq2, v)) if eq2 == eq => {
                Some(matcher.insert(*v))
            }
            (Self::RupeesGe { lo, matcher }, OneObservation::RupeesGe(lo2, v)) if lo2 == lo => {
                Some(matcher.insert(*v))
            }
            (Self::RupeesLe { hi, matcher }, OneObservation::RupeesLe(hi2, v)) if hi2 == hi => {
                Some(matcher.insert(*v))
            }
            (Self::RupeesRange { lo, hi, matcher }, OneObservation::RupeesRange(lo2, hi2, v))
                if lo2 == lo && hi2 == hi =>
            {
                Some(matcher.insert(*v))
            }
            (Self::GoldSkulltulaTokenLookup(m), OneObservation::GoldSkulltulaTokenExact(v)) => {
                Some(m.insert(*v))
            }
            (
                Self::GoldSkulltulaTokenEq { eq, matcher },
                OneObservation::GoldSkulltulaTokenEq(eq2, v),
            ) if eq2 == eq => Some(matcher.insert(*v)),
            (
                Self::GoldSkulltulaTokenGe { lo, matcher },
                OneObservation::GoldSkulltulaTokenGe(lo2, v),
            ) if lo2 == lo => Some(matcher.insert(*v)),
            (
                Self::GoldSkulltulaTokenLe { hi, matcher },
                OneObservation::GoldSkulltulaTokenLe(hi2, v),
            ) if hi2 == hi => Some(matcher.insert(*v)),
            (
                Self::GoldSkulltulaTokenRange { lo, hi, matcher },
                OneObservation::GoldSkulltulaTokenRange(lo2, hi2, v),
            ) if lo2 == lo && hi2 == hi => Some(matcher.insert(*v)),
            (Self::ProgressiveWalletLookup(m), OneObservation::ProgressiveWalletExact(v)) => {
                Some(m.insert(*v))
            }
            (
                Self::ProgressiveWalletEq { eq, matcher },
                OneObservation::ProgressiveWalletEq(eq2, v),
            ) if eq2 == eq => Some(matcher.insert(*v)),
            (
                Self::ProgressiveWalletGe { lo, matcher },
                OneObservation::ProgressiveWalletGe(lo2, v),
            ) if lo2 == lo => Some(matcher.insert(*v)),
            (
                Self::ProgressiveWalletLe { hi, matcher },
                OneObservation::ProgressiveWalletLe(hi2, v),
            ) if hi2 == hi => Some(matcher.insert(*v)),
            (
                Self::ProgressiveWalletRange { lo, hi, matcher },
                OneObservation::ProgressiveWalletRange(lo2, hi2, v),
            ) if lo2 == lo && hi2 == hi => Some(matcher.insert(*v)),
            (Self::TriforcePieceLookup(m), OneObservation::TriforcePieceExact(v)) => {
                Some(m.insert(*v))
            }
            (Self::TriforcePieceEq { eq, matcher }, OneObservation::TriforcePieceEq(eq2, v))
                if eq2 == eq =>
            {
                Some(matcher.insert(*v))
            }
            (Self::TriforcePieceGe { lo, matcher }, OneObservation::TriforcePieceGe(lo2, v))
                if lo2 == lo =>
            {
                Some(matcher.insert(*v))
            }
            (Self::TriforcePieceLe { hi, matcher }, OneObservation::TriforcePieceLe(hi2, v))
                if hi2 == hi =>
            {
                Some(matcher.insert(*v))
            }
            (
                Self::TriforcePieceRange { lo, hi, matcher },
                OneObservation::TriforcePieceRange(lo2, hi2, v),
            ) if lo2 == lo && hi2 == hi => Some(matcher.insert(*v)),
            (
                Self::LookupCBits1 { mask, matcher },
                OneObservation::CBits1 {
                    mask: mask2,
                    result,
                },
            ) if mask == mask2 => Some(matcher.insert(*result)),
            (
                Self::LookupCBits2 { mask, matcher },
                OneObservation::CBits2 {
                    mask: mask2,
                    result,
                },
            ) if mask == mask2 => Some(matcher.insert(*result)),
            _ => None,
        }
    }

    fn add_value(&mut self, obs: &OneObservation, value: Self::Value) {
        match (self, obs) {
            (Self::PositionLookup(m), OneObservation::Position(v)) => m.add_value(*v, value),
            (Self::TodLookup(m), OneObservation::Tod(v)) => m.add_value(*v, value),
            (Self::RupeesLookup(m), OneObservation::RupeesExact(v)) => m.add_value(*v, value),
            (Self::RupeesEq { eq, matcher }, OneObservation::RupeesEq(eq2, v)) if eq2 == eq => {
                matcher.add_value(*v, value)
            }
            (Self::RupeesGe { lo, matcher }, OneObservation::RupeesGe(lo2, v)) if lo2 == lo => {
                matcher.add_value(*v, value)
            }
            (Self::RupeesLe { hi, matcher }, OneObservation::RupeesLe(hi2, v)) if hi2 == hi => {
                matcher.add_value(*v, value)
            }
            (Self::RupeesRange { lo, hi, matcher }, OneObservation::RupeesRange(lo2, hi2, v))
                if lo2 == lo && hi2 == hi =>
            {
                matcher.add_value(*v, value)
            }
            (Self::GoldSkulltulaTokenLookup(m), OneObservation::GoldSkulltulaTokenExact(v)) => {
                m.add_value(*v, value)
            }
            (
                Self::GoldSkulltulaTokenEq { eq, matcher },
                OneObservation::GoldSkulltulaTokenEq(eq2, v),
            ) if eq2 == eq => matcher.add_value(*v, value),
            (
                Self::GoldSkulltulaTokenGe { lo, matcher },
                OneObservation::GoldSkulltulaTokenGe(lo2, v),
            ) if lo2 == lo => matcher.add_value(*v, value),
            (
                Self::GoldSkulltulaTokenLe { hi, matcher },
                OneObservation::GoldSkulltulaTokenLe(hi2, v),
            ) if hi2 == hi => matcher.add_value(*v, value),
            (
                Self::GoldSkulltulaTokenRange { lo, hi, matcher },
                OneObservation::GoldSkulltulaTokenRange(lo2, hi2, v),
            ) if lo2 == lo && hi2 == hi => matcher.add_value(*v, value),
            (Self::ProgressiveWalletLookup(m), OneObservation::ProgressiveWalletExact(v)) => {
                m.add_value(*v, value)
            }
            (
                Self::ProgressiveWalletEq { eq, matcher },
                OneObservation::ProgressiveWalletEq(eq2, v),
            ) if eq2 == eq => matcher.add_value(*v, value),
            (
                Self::ProgressiveWalletGe { lo, matcher },
                OneObservation::ProgressiveWalletGe(lo2, v),
            ) if lo2 == lo => matcher.add_value(*v, value),
            (
                Self::ProgressiveWalletLe { hi, matcher },
                OneObservation::ProgressiveWalletLe(hi2, v),
            ) if hi2 == hi => matcher.add_value(*v, value),
            (
                Self::ProgressiveWalletRange { lo, hi, matcher },
                OneObservation::ProgressiveWalletRange(lo2, hi2, v),
            ) if lo2 == lo && hi2 == hi => matcher.add_value(*v, value),
            (Self::TriforcePieceLookup(m), OneObservation::TriforcePieceExact(v)) => {
                m.add_value(*v, value)
            }
            (Self::TriforcePieceEq { eq, matcher }, OneObservation::TriforcePieceEq(eq2, v))
                if eq2 == eq =>
            {
                matcher.add_value(*v, value)
            }
            (Self::TriforcePieceGe { lo, matcher }, OneObservation::TriforcePieceGe(lo2, v))
                if lo2 == lo =>
            {
                matcher.add_value(*v, value)
            }
            (Self::TriforcePieceLe { hi, matcher }, OneObservation::TriforcePieceLe(hi2, v))
                if hi2 == hi =>
            {
                matcher.add_value(*v, value)
            }
            (
                Self::TriforcePieceRange { lo, hi, matcher },
                OneObservation::TriforcePieceRange(lo2, hi2, v),
            ) if lo2 == lo && hi2 == hi => matcher.add_value(*v, value),
            (
                Self::LookupCBits1 { mask, matcher },
                OneObservation::CBits1 {
                    mask: mask2,
                    result,
                },
            ) if mask == mask2 => matcher.add_value(*result, value),
            (
                Self::LookupCBits2 { mask, matcher },
                OneObservation::CBits2 {
                    mask: mask2,
                    result,
                },
            ) if mask == mask2 => matcher.add_value(*result, value),
            _ => (),
        }
    }

    fn nodes(&self) -> Vec<Arc<Mutex<Node<Self>>>> {
        match self {
            Self::PositionLookup(m) => m.nodes(),
            Self::TodLookup(m) => m.nodes(),
            Self::RupeesLookup(m) => m.nodes(),
            Self::RupeesEq { matcher, .. } => matcher.nodes(),
            Self::RupeesGe { matcher, .. } => matcher.nodes(),
            Self::RupeesLe { matcher, .. } => matcher.nodes(),
            Self::RupeesRange { matcher, .. } => matcher.nodes(),
            Self::GoldSkulltulaTokenLookup(m) => m.nodes(),
            Self::GoldSkulltulaTokenEq { matcher, .. } => matcher.nodes(),
            Self::GoldSkulltulaTokenGe { matcher, .. } => matcher.nodes(),
            Self::GoldSkulltulaTokenLe { matcher, .. } => matcher.nodes(),
            Self::GoldSkulltulaTokenRange { matcher, .. } => matcher.nodes(),
            Self::ProgressiveWalletLookup(m) => m.nodes(),
            Self::ProgressiveWalletEq { matcher, .. } => matcher.nodes(),
            Self::ProgressiveWalletGe { matcher, .. } => matcher.nodes(),
            Self::ProgressiveWalletLe { matcher, .. } => matcher.nodes(),
            Self::ProgressiveWalletRange { matcher, .. } => matcher.nodes(),
            Self::TriforcePieceLookup(m) => m.nodes(),
            Self::TriforcePieceEq { matcher, .. } => matcher.nodes(),
            Self::TriforcePieceGe { matcher, .. } => matcher.nodes(),
            Self::TriforcePieceLe { matcher, .. } => matcher.nodes(),
            Self::TriforcePieceRange { matcher, .. } => matcher.nodes(),
            Self::LookupCBits1 { matcher, .. } => matcher.nodes(),
            Self::LookupCBits2 { matcher, .. } => matcher.nodes(),
        }
    }

    fn num_values(&self) -> usize {
        match self {
            Self::PositionLookup(m) => m.num_values(),
            Self::TodLookup(m) => m.num_values(),
            Self::RupeesLookup(m) => m.num_values(),
            Self::RupeesEq { matcher, .. } => matcher.num_values(),
            Self::RupeesGe { matcher, .. } => matcher.num_values(),
            Self::RupeesLe { matcher, .. } => matcher.num_values(),
            Self::RupeesRange { matcher, .. } => matcher.num_values(),
            Self::GoldSkulltulaTokenLookup(m) => m.num_values(),
            Self::GoldSkulltulaTokenEq { matcher, .. } => matcher.num_values(),
            Self::GoldSkulltulaTokenGe { matcher, .. } => matcher.num_values(),
            Self::GoldSkulltulaTokenLe { matcher, .. } => matcher.num_values(),
            Self::GoldSkulltulaTokenRange { matcher, .. } => matcher.num_values(),
            Self::ProgressiveWalletLookup(m) => m.num_values(),
            Self::ProgressiveWalletEq { matcher, .. } => matcher.num_values(),
            Self::ProgressiveWalletGe { matcher, .. } => matcher.num_values(),
            Self::ProgressiveWalletLe { matcher, .. } => matcher.num_values(),
            Self::ProgressiveWalletRange { matcher, .. } => matcher.num_values(),
            Self::TriforcePieceLookup(m) => m.num_values(),
            Self::TriforcePieceEq { matcher, .. } => matcher.num_values(),
            Self::TriforcePieceGe { matcher, .. } => matcher.num_values(),
            Self::TriforcePieceLe { matcher, .. } => matcher.num_values(),
            Self::TriforcePieceRange { matcher, .. } => matcher.num_values(),
            Self::LookupCBits1 { matcher, .. } => matcher.num_values(),
            Self::LookupCBits2 { matcher, .. } => matcher.num_values(),
        }
    }
}
