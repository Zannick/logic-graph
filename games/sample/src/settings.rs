//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

use crate::context::{flags, Context};
use crate::graph::World;
use analyzer::context::ContextWrapper;
use analyzer::route::route_from_yaml_string;
use analyzer::settings::*;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use yaml_rust::{Yaml, YamlLoader};

fn read_key_value(
    world: &mut World,
    ctx: &mut Context,
    key: &Yaml,
    val: &Yaml,
) -> Result<(), String> {
    match key.as_str() {
        Some("objective") => {
            world.objective = parse_str_into(key, val)?;
        }
        Some("rules") => {
            for (rkey, rval) in val.as_hash().expect("rules YAML should be a key-value map") {
                match rkey.as_str() {
                    Some("$victory" | "victory") => {
                        world.rule_victory = parse_str_into(rkey, rval)?
                    }
                    Some("$objective" | "objective") => {
                        world.rule_objective = parse_str_into(rkey, rval)?
                    }
                    _ => {
                        return Err(format!(
                            "Unrecognized or unparseable rule key: '{:?}'",
                            rkey
                        ))
                    }
                }
            }
        }
        Some("triforce_count") => {
            ctx.triforce_count = parse_int(key, val)?;
        }
        Some("logic_deku_b1_skip") => {
            ctx.cbits1.set(
                flags::ContextBits1::LOGIC_DEKU_B1_SKIP,
                parse_bool(key, val)?,
            );
        }
        _ => {
            return Err(format!("Unrecognized or unparseable key: '{:?}'", key));
        }
    }
    Ok(())
}

pub fn load_settings(
    filename: Option<&PathBuf>,
) -> (Box<World>, Context, Vec<ContextWrapper<Context>>) {
    let mut world: Box<World> = Box::default();
    analyzer::world::World::condense_graph(world.as_mut());
    let mut ctx = Context::default();
    let mut vec = Vec::new();
    let route_key = Yaml::String(String::from("routes"));
    if let Some(filename) = filename {
        let mut file = File::open(filename)
            .unwrap_or_else(|e| panic!("Couldn't open file \"{:?}\": {:?}", filename, e));
        let mut settings = String::new();
        file.read_to_string(&mut settings)
            .unwrap_or_else(|e| panic!("Couldn't read from file \"{:?}\": {:?}", filename, e));
        let yaml = YamlLoader::load_from_str(&settings).expect("YAML parse error");
        let mut errs = Vec::new();
        let mut route_strs = Vec::new();
        for (key, value) in yaml[0]
            .as_hash()
            .expect("YAML file should be a key-value map")
        {
            if key == &route_key {
                if let Some(v) = value.as_vec() {
                    route_strs.extend(v.iter());
                } else {
                    errs.push(format!(
                        "routes must be list of strings, but was {:?}",
                        value
                    ));
                }
            } else if let Err(e) = read_key_value(world.as_mut(), &mut ctx, key, value) {
                errs.push(e);
            }
        }
        for s in route_strs {
            match route_from_yaml_string(world.as_ref(), &ctx, s) {
                Ok(c) => vec.push(c),
                Err(e) => errs.push(e),
            }
        }
        if !errs.is_empty() {
            panic!(
                "Errors reading YAML file: {}\n{} total errors",
                errs.join("\n"),
                errs.len()
            );
        }
    }
    (world, ctx, vec)
}
