//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

#![allow(non_snake_case)]
#![allow(unused)]

use crate::graph::{self, *};
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::context;
use analyzer::world::World;
use enum_map::EnumMap;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};

pub mod enums {
    use std::fmt;
    #[derive(
        Debug,
        PartialEq,
        Eq,
        Copy,
        Clone,
        Hash,
        Ord,
        PartialOrd,
        Default,
        serde_repr::Serialize_repr,
        serde_repr::Deserialize_repr,
    )]
    #[repr(u8)]
    pub enum Tod {
        #[default]
        Day,
        Night,
    }
    impl fmt::Display for Tod {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Tod::Day => write!(f, "{}", "Day"),

                Tod::Night => write!(f, "{}", "Night"),
            }
        }
    }
    impl std::str::FromStr for Tod {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Day" => Ok(Tod::Day),
                "Night" => Ok(Tod::Night),
                _ => Err(format!("Could not recognize as a Tod: {}", s)),
            }
        }
    }
}

pub mod data {
    #[allow(unused_imports)]
    use crate::context::enums;
    use crate::graph::*;
}

pub mod flags {
    use bitflags::bitflags;
    use serde::{self, Deserialize, Serialize};

    bitflags! {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub struct ContextBits1 : u32 {
            const CHILD = 1 << 0;
            const DEKU_TREE__COMPASS_ROOM__CTX__TORCH = 1 << 1;
            const LOGIC_DEKU_B1_SKIP = 1 << 2;
            const BIGGORON_SWORD = 1 << 3;
            const BOMBS = 1 << 4;
            const BOOMERANG = 1 << 5;
            const BOW = 1 << 6;
            const BUY_DEKU_NUT_10 = 1 << 7;
            const BUY_DEKU_NUT_5 = 1 << 8;
            const BUY_DEKU_SHIELD = 1 << 9;
            const BUY_DEKU_STICK_1 = 1 << 10;
            const DEFEAT_GANON = 1 << 11;
            const DEFEAT_GOHMA = 1 << 12;
            const DEKU_BACK_ROOM_WALL = 1 << 13;
            const DEKU_BACK_ROOM_WEB = 1 << 14;
            const DEKU_BASEMENT_BLOCK = 1 << 15;
            const DEKU_BASEMENT_SCRUBS = 1 << 16;
            const DEKU_BASEMENT_SWITCH = 1 << 17;
            const DEKU_BASEMENT_WEB = 1 << 18;
            const DEKU_LOBBY_WEB = 1 << 19;
            const DEKU_NUT_DROP = 1 << 20;
            const DEKU_SHIELD_DROP = 1 << 21;
            const DEKU_SLINGSHOT_SCRUB = 1 << 22;
            const DEKU_STICK_DROP = 1 << 23;
            const HYLIAN_SHIELD = 1 << 24;
            const KOKIRI_EMERALD = 1 << 25;
            const KOKIRI_SWORD = 1 << 26;
            const MAGIC_METER = 1 << 27;
            const OCARINA = 1 << 28;
            const SHOWED_MIDO = 1 << 29;
            const SLINGSHOT = 1 << 30;
        }
    }
    impl Default for ContextBits1 {
        fn default() -> ContextBits1 {
            ContextBits1::CHILD
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum Status {
    #[default]
    None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct Context {
    // context vars
    pub position: SpotId,
    pub save: SpotId,
    pub tod: enums::Tod,
    pub rupees: i32,
    // settings
    pub triforce_count: i16,
    // items
    pub gold_skulltula_token: i8,
    pub triforce_piece: i16,
    // bitflags
    pub cbits1: flags::ContextBits1,
    // other
    pub status: EnumMap<LocationId, Status>,

    visits: u32,
    skips: u32,
}

impl Default for Context {
    fn default() -> Context {
        Context {
            position: SpotId::KF__Links_House__Start_Point,
            save: SpotId::KF__Links_House__Start_Point,
            tod: enums::Tod::Day,
            rupees: 0,
            // settings
            triforce_count: Default::default(),
            // items
            gold_skulltula_token: Default::default(),
            triforce_piece: Default::default(),
            // bitflags
            cbits1: Default::default(),
            // other
            status: Default::default(),
            visits: Default::default(),
            skips: Default::default(),
        }
    }
}

impl context::Ctx for Context {
    type World = graph::World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;
    type MovementState = movements::MovementState;
    const NUM_ITEMS: u32 = 30;

    fn has(&self, item: Item) -> bool {
        match item {
            Item::Biggoron_Sword => self.cbits1.contains(flags::ContextBits1::BIGGORON_SWORD),
            Item::Bombs => self.cbits1.contains(flags::ContextBits1::BOMBS),
            Item::Boomerang => self.cbits1.contains(flags::ContextBits1::BOOMERANG),
            Item::Bow => self.cbits1.contains(flags::ContextBits1::BOW),
            Item::Buy_Deku_Nut_10 => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_10),
            Item::Buy_Deku_Nut_5 => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_5),
            Item::Buy_Deku_Shield => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_SHIELD),
            Item::Buy_Deku_Stick_1 => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_STICK_1),
            Item::Defeat_Ganon => self.cbits1.contains(flags::ContextBits1::DEFEAT_GANON),
            Item::Defeat_Gohma => self.cbits1.contains(flags::ContextBits1::DEFEAT_GOHMA),
            Item::Deku_Back_Room_Wall => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL),
            Item::Deku_Back_Room_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB),
            Item::Deku_Basement_Block => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK),
            Item::Deku_Basement_Scrubs => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS),
            Item::Deku_Basement_Switch => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH),
            Item::Deku_Basement_Web => self.cbits1.contains(flags::ContextBits1::DEKU_BASEMENT_WEB),
            Item::Deku_Lobby_Web => self.cbits1.contains(flags::ContextBits1::DEKU_LOBBY_WEB),
            Item::Deku_Nut_Drop => self.cbits1.contains(flags::ContextBits1::DEKU_NUT_DROP),
            Item::Deku_Shield_Drop => self.cbits1.contains(flags::ContextBits1::DEKU_SHIELD_DROP),
            Item::Deku_Slingshot_Scrub => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB),
            Item::Deku_Stick_Drop => self.cbits1.contains(flags::ContextBits1::DEKU_STICK_DROP),
            Item::Gold_Skulltula_Token => self.gold_skulltula_token >= 1,
            Item::Hylian_Shield => self.cbits1.contains(flags::ContextBits1::HYLIAN_SHIELD),
            Item::Kokiri_Emerald => self.cbits1.contains(flags::ContextBits1::KOKIRI_EMERALD),
            Item::Kokiri_Sword => self.cbits1.contains(flags::ContextBits1::KOKIRI_SWORD),
            Item::Magic_Meter => self.cbits1.contains(flags::ContextBits1::MAGIC_METER),
            Item::Ocarina => self.cbits1.contains(flags::ContextBits1::OCARINA),
            Item::Showed_Mido => self.cbits1.contains(flags::ContextBits1::SHOWED_MIDO),
            Item::Slingshot => self.cbits1.contains(flags::ContextBits1::SLINGSHOT),
            Item::Triforce_Piece => self.triforce_piece >= 1,
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
            Item::Biggoron_Sword => self
                .cbits1
                .contains(flags::ContextBits1::BIGGORON_SWORD)
                .into(),
            Item::Bombs => self.cbits1.contains(flags::ContextBits1::BOMBS).into(),
            Item::Boomerang => self.cbits1.contains(flags::ContextBits1::BOOMERANG).into(),
            Item::Bow => self.cbits1.contains(flags::ContextBits1::BOW).into(),
            Item::Buy_Deku_Nut_10 => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_NUT_10)
                .into(),
            Item::Buy_Deku_Nut_5 => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_NUT_5)
                .into(),
            Item::Buy_Deku_Shield => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_SHIELD)
                .into(),
            Item::Buy_Deku_Stick_1 => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_STICK_1)
                .into(),
            Item::Defeat_Ganon => self
                .cbits1
                .contains(flags::ContextBits1::DEFEAT_GANON)
                .into(),
            Item::Defeat_Gohma => self
                .cbits1
                .contains(flags::ContextBits1::DEFEAT_GOHMA)
                .into(),
            Item::Deku_Back_Room_Wall => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL)
                .into(),
            Item::Deku_Back_Room_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB)
                .into(),
            Item::Deku_Basement_Block => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK)
                .into(),
            Item::Deku_Basement_Scrubs => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS)
                .into(),
            Item::Deku_Basement_Switch => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH)
                .into(),
            Item::Deku_Basement_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_WEB)
                .into(),
            Item::Deku_Lobby_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_LOBBY_WEB)
                .into(),
            Item::Deku_Nut_Drop => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_NUT_DROP)
                .into(),
            Item::Deku_Shield_Drop => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_SHIELD_DROP)
                .into(),
            Item::Deku_Slingshot_Scrub => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB)
                .into(),
            Item::Deku_Stick_Drop => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_STICK_DROP)
                .into(),
            Item::Gold_Skulltula_Token => self.gold_skulltula_token.into(),
            Item::Hylian_Shield => self
                .cbits1
                .contains(flags::ContextBits1::HYLIAN_SHIELD)
                .into(),
            Item::Kokiri_Emerald => self
                .cbits1
                .contains(flags::ContextBits1::KOKIRI_EMERALD)
                .into(),
            Item::Kokiri_Sword => self
                .cbits1
                .contains(flags::ContextBits1::KOKIRI_SWORD)
                .into(),
            Item::Magic_Meter => self
                .cbits1
                .contains(flags::ContextBits1::MAGIC_METER)
                .into(),
            Item::Ocarina => self.cbits1.contains(flags::ContextBits1::OCARINA).into(),
            Item::Showed_Mido => self
                .cbits1
                .contains(flags::ContextBits1::SHOWED_MIDO)
                .into(),
            Item::Slingshot => self.cbits1.contains(flags::ContextBits1::SLINGSHOT).into(),
            Item::Triforce_Piece => self.triforce_piece.into(),
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
            Item::Biggoron_Sword => {
                self.cbits1.insert(flags::ContextBits1::BIGGORON_SWORD);
            }
            Item::Bombs => {
                self.cbits1.insert(flags::ContextBits1::BOMBS);
            }
            Item::Boomerang => {
                self.cbits1.insert(flags::ContextBits1::BOOMERANG);
            }
            Item::Bow => {
                self.cbits1.insert(flags::ContextBits1::BOW);
            }
            Item::Buy_Deku_Nut_10 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_10);
            }
            Item::Buy_Deku_Nut_5 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_5);
            }
            Item::Buy_Deku_Shield => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_SHIELD);
            }
            Item::Buy_Deku_Stick_1 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_STICK_1);
            }
            Item::Defeat_Ganon => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GANON);
            }
            Item::Defeat_Gohma => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GOHMA);
            }
            Item::Deku_Back_Room_Wall => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
            }
            Item::Deku_Back_Room_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
            }
            Item::Deku_Basement_Block => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
            }
            Item::Deku_Basement_Scrubs => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
            }
            Item::Deku_Basement_Switch => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
            }
            Item::Deku_Basement_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_WEB);
            }
            Item::Deku_Lobby_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_LOBBY_WEB);
            }
            Item::Deku_Nut_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_NUT_DROP);
            }
            Item::Deku_Shield_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_SHIELD_DROP);
            }
            Item::Deku_Slingshot_Scrub => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
            }
            Item::Deku_Stick_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_STICK_DROP);
            }
            Item::Gold_Skulltula_Token => {
                self.gold_skulltula_token += 1;
            }
            Item::Hylian_Shield => {
                self.cbits1.insert(flags::ContextBits1::HYLIAN_SHIELD);
            }
            Item::Kokiri_Emerald => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_EMERALD);
            }
            Item::Kokiri_Sword => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_SWORD);
            }
            Item::Magic_Meter => {
                self.cbits1.insert(flags::ContextBits1::MAGIC_METER);
            }
            Item::Ocarina => {
                self.cbits1.insert(flags::ContextBits1::OCARINA);
            }
            Item::Showed_Mido => {
                self.cbits1.insert(flags::ContextBits1::SHOWED_MIDO);
            }
            Item::Slingshot => {
                self.cbits1.insert(flags::ContextBits1::SLINGSHOT);
            }
            Item::Triforce_Piece => {
                self.triforce_piece += 1;
            }
            Item::Rupee_1 => rules::action_rupees__min__rupees__1_wallet_max(self),
            Item::Rupees_5 => rules::action_rupees__min__rupees__5_wallet_max(self),
            Item::Rupees_50 => rules::action_rupees__min__rupees__50_wallet_max(self),
            _ => (),
        }
    }

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position(&mut self, pos: SpotId) {
        let area = get_area(pos);
        match area {
            AreaId::Deku_Tree__Compass_Room => {
                if get_area(self.position) != area {
                    self.cbits1
                        .remove(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
                }
            }
            _ => (),
        }
        self.position = pos;
    }

    fn reload_game(&mut self) {
        self.reset_all();
    }

    fn reset_all(&mut self) {}

    fn reset_region(&mut self, region_id: RegionId) {}
    fn reset_area(&mut self, area_id: AreaId) {}
    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
            Currency::Rupees(c) => self.rupees >= *c,
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
            Currency::Rupees(c) => self.rupees -= *c,
        }
    }

    fn visit(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Visited;
        self.visits += 1;
    }
    fn skip(&mut self, loc_id: LocationId) {
        if self.status[loc_id] == Status::None {
            self.status[loc_id] = Status::Skipped;
            self.skips += 1;
        }
    }
    fn reset(&mut self, loc_id: LocationId) {
        match self.status[loc_id] {
            Status::Visited => self.visits -= 1,
            Status::Skipped => self.skips -= 1,
            _ => (),
        }
        self.status[loc_id] = Status::None;
    }

    fn todo(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::None
    }
    fn visited(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Visited
    }
    fn skipped(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Skipped
    }

    fn all_spot_checks(&self, id: SpotId) -> bool {
        let r = spot_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_area_checks(&self, id: AreaId) -> bool {
        let r = area_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_region_checks(&self, id: RegionId) -> bool {
        let r = region_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn get_movement_state(&self) -> movements::MovementState {
        movements::get_movement_state(self)
    }

    fn local_travel_time(&self, movement_state: movements::MovementState, dest: SpotId) -> u32 {
        movements::local_travel_time(self, movement_state, self.position, dest)
    }

    fn count_visits(&self) -> u32 {
        self.visits
    }
    fn count_skips(&self) -> u32 {
        self.skips
    }
    fn progress(&self) -> u32 {
        if self.visits <= 0 {
            0
        } else {
            self.visits * 100 / (Self::World::NUM_LOCATIONS - self.skips)
        }
    }

    fn diff(&self, old: &Context) -> String {
        let mut list: Vec<String> = Vec::new();

        if old.position != self.position {
            list.push(format!(
                "position: {:?} ➡ {:?}",
                old.position, self.position
            ));
        }
        if old.save != self.save {
            list.push(format!("save: {:?} ➡ {:?}", old.save, self.save));
        }
        if old.tod != self.tod {
            list.push(format!("tod: {:?} ➡ {:?}", old.tod, self.tod));
        }
        if old.rupees != self.rupees {
            list.push(format!("rupees: {:?} ➡ {:?}", old.rupees, self.rupees));
        }
        if old.triforce_count != self.triforce_count {
            list.push(format!(
                "triforce_count: {:?} ➡ {:?}",
                old.triforce_count, self.triforce_count
            ));
        }
        if old.gold_skulltula_token != self.gold_skulltula_token {
            list.push(format!(
                "Gold_Skulltula_Token: {:+}",
                self.gold_skulltula_token - old.gold_skulltula_token
            ));
        }
        if old.triforce_piece != self.triforce_piece {
            list.push(format!(
                "Triforce_Piece: {:+}",
                self.triforce_piece - old.triforce_piece
            ));
        }
        // bitflags
        let n = self.cbits1.contains(flags::ContextBits1::CHILD);
        let p = old.cbits1.contains(flags::ContextBits1::CHILD);
        if n != p {
            list.push(format!("{}CHILD", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
        if n != p {
            list.push(format!(
                "{}DEKU_TREE__COMPASS_ROOM__CTX__TORCH",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::LOGIC_DEKU_B1_SKIP);
        let p = old.cbits1.contains(flags::ContextBits1::LOGIC_DEKU_B1_SKIP);
        if n != p {
            list.push(format!("{}LOGIC_DEKU_B1_SKIP", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BIGGORON_SWORD);
        let p = old.cbits1.contains(flags::ContextBits1::BIGGORON_SWORD);
        if n != p {
            list.push(format!("{}BIGGORON_SWORD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOMBS);
        let p = old.cbits1.contains(flags::ContextBits1::BOMBS);
        if n != p {
            list.push(format!("{}BOMBS", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOOMERANG);
        let p = old.cbits1.contains(flags::ContextBits1::BOOMERANG);
        if n != p {
            list.push(format!("{}BOOMERANG", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOW);
        let p = old.cbits1.contains(flags::ContextBits1::BOW);
        if n != p {
            list.push(format!("{}BOW", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_10);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_10);
        if n != p {
            list.push(format!("{}BUY_DEKU_NUT_10", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_5);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_5);
        if n != p {
            list.push(format!("{}BUY_DEKU_NUT_5", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_SHIELD);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_SHIELD);
        if n != p {
            list.push(format!("{}BUY_DEKU_SHIELD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_STICK_1);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_STICK_1);
        if n != p {
            list.push(format!("{}BUY_DEKU_STICK_1", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEFEAT_GANON);
        let p = old.cbits1.contains(flags::ContextBits1::DEFEAT_GANON);
        if n != p {
            list.push(format!("{}DEFEAT_GANON", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEFEAT_GOHMA);
        let p = old.cbits1.contains(flags::ContextBits1::DEFEAT_GOHMA);
        if n != p {
            list.push(format!("{}DEFEAT_GOHMA", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
        if n != p {
            list.push(format!("{}DEKU_BACK_ROOM_WALL", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
        if n != p {
            list.push(format!("{}DEKU_BACK_ROOM_WEB", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_BLOCK", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_SCRUBS", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_SWITCH", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_BASEMENT_WEB);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_BASEMENT_WEB);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_WEB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_LOBBY_WEB);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_LOBBY_WEB);
        if n != p {
            list.push(format!("{}DEKU_LOBBY_WEB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_NUT_DROP);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_NUT_DROP);
        if n != p {
            list.push(format!("{}DEKU_NUT_DROP", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_SHIELD_DROP);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_SHIELD_DROP);
        if n != p {
            list.push(format!("{}DEKU_SHIELD_DROP", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
        if n != p {
            list.push(format!("{}DEKU_SLINGSHOT_SCRUB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_STICK_DROP);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_STICK_DROP);
        if n != p {
            list.push(format!("{}DEKU_STICK_DROP", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::HYLIAN_SHIELD);
        let p = old.cbits1.contains(flags::ContextBits1::HYLIAN_SHIELD);
        if n != p {
            list.push(format!("{}HYLIAN_SHIELD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::KOKIRI_EMERALD);
        let p = old.cbits1.contains(flags::ContextBits1::KOKIRI_EMERALD);
        if n != p {
            list.push(format!("{}KOKIRI_EMERALD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::KOKIRI_SWORD);
        let p = old.cbits1.contains(flags::ContextBits1::KOKIRI_SWORD);
        if n != p {
            list.push(format!("{}KOKIRI_SWORD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::MAGIC_METER);
        let p = old.cbits1.contains(flags::ContextBits1::MAGIC_METER);
        if n != p {
            list.push(format!("{}MAGIC_METER", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::OCARINA);
        let p = old.cbits1.contains(flags::ContextBits1::OCARINA);
        if n != p {
            list.push(format!("{}OCARINA", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::SHOWED_MIDO);
        let p = old.cbits1.contains(flags::ContextBits1::SHOWED_MIDO);
        if n != p {
            list.push(format!("{}SHOWED_MIDO", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::SLINGSHOT);
        let p = old.cbits1.contains(flags::ContextBits1::SLINGSHOT);
        if n != p {
            list.push(format!("{}SLINGSHOT", if n { "+" } else { "-" }));
        }
        for (loc_id, status) in self.status.iter() {
            if *status != old.status[loc_id] {
                list.push(format!("{:?}: {}", status, loc_id));
            }
        }

        if self.visits != old.visits {
            list.push(format!("Visits: {:+}", self.visits - old.visits));
        }

        if self.skips != old.skips {
            list.push(format!("Skips: {:+}", self.skips - old.skips));
        }

        list.join("\n")
    }
}

impl Context {
    // settings
    pub fn triforce_count(&self) -> i16 {
        self.triforce_count
    }
    pub fn set_triforce_count(&mut self, val: i16) {
        self.triforce_count = val;
    }
    pub fn logic_deku_b1_skip(&self) -> bool {
        self.cbits1
            .contains(flags::ContextBits1::LOGIC_DEKU_B1_SKIP)
    }
    pub fn set_logic_deku_b1_skip(&mut self, val: bool) {
        self.cbits1
            .set(flags::ContextBits1::LOGIC_DEKU_B1_SKIP, val);
    }
    // context
    pub fn position(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.position,
                },
            },
        }
    }
    pub fn save(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    RegionId::Deku_Tree => SpotId::Deku_Tree__Lobby__Entry,
                    _ => self.save,
                },
            },
        }
    }
    pub fn set_save(&mut self, val: SpotId) {
        self.save = val;
    }
    pub fn child(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.cbits1.contains(flags::ContextBits1::CHILD),
                },
            },
        }
    }
    pub fn set_child(&mut self, val: bool) {
        self.cbits1.set(flags::ContextBits1::CHILD, val);
    }
    pub fn tod(&self) -> enums::Tod {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.tod,
                },
            },
        }
    }
    pub fn set_tod(&mut self, val: enums::Tod) {
        self.tod = val;
    }
    pub fn rupees(&self) -> i32 {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.rupees,
                },
            },
        }
    }
    pub fn set_rupees(&mut self, val: i32) {
        self.rupees = val;
    }
    pub fn deku_tree__compass_room__ctx__torch(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH),
                },
            },
        }
    }
    pub fn set_deku_tree__compass_room__ctx__torch(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH,
            val,
        );
    }
    // test helper for items
    pub fn add_item(&mut self, item: Item) {
        match item {
            Item::Biggoron_Sword => {
                self.cbits1.insert(flags::ContextBits1::BIGGORON_SWORD);
            }
            Item::Bombs => {
                self.cbits1.insert(flags::ContextBits1::BOMBS);
            }
            Item::Boomerang => {
                self.cbits1.insert(flags::ContextBits1::BOOMERANG);
            }
            Item::Bow => {
                self.cbits1.insert(flags::ContextBits1::BOW);
            }
            Item::Buy_Deku_Nut_10 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_10);
            }
            Item::Buy_Deku_Nut_5 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_5);
            }
            Item::Buy_Deku_Shield => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_SHIELD);
            }
            Item::Buy_Deku_Stick_1 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_STICK_1);
            }
            Item::Defeat_Ganon => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GANON);
            }
            Item::Defeat_Gohma => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GOHMA);
            }
            Item::Deku_Back_Room_Wall => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
            }
            Item::Deku_Back_Room_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
            }
            Item::Deku_Basement_Block => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
            }
            Item::Deku_Basement_Scrubs => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
            }
            Item::Deku_Basement_Switch => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
            }
            Item::Deku_Basement_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_WEB);
            }
            Item::Deku_Lobby_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_LOBBY_WEB);
            }
            Item::Deku_Nut_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_NUT_DROP);
            }
            Item::Deku_Shield_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_SHIELD_DROP);
            }
            Item::Deku_Slingshot_Scrub => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
            }
            Item::Deku_Stick_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_STICK_DROP);
            }
            Item::Gold_Skulltula_Token => {
                self.gold_skulltula_token += 1;
            }
            Item::Hylian_Shield => {
                self.cbits1.insert(flags::ContextBits1::HYLIAN_SHIELD);
            }
            Item::Kokiri_Emerald => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_EMERALD);
            }
            Item::Kokiri_Sword => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_SWORD);
            }
            Item::Magic_Meter => {
                self.cbits1.insert(flags::ContextBits1::MAGIC_METER);
            }
            Item::Ocarina => {
                self.cbits1.insert(flags::ContextBits1::OCARINA);
            }
            Item::Showed_Mido => {
                self.cbits1.insert(flags::ContextBits1::SHOWED_MIDO);
            }
            Item::Slingshot => {
                self.cbits1.insert(flags::ContextBits1::SLINGSHOT);
            }
            Item::Triforce_Piece => {
                self.triforce_piece += 1;
            }
            _ => (),
        }
    }
}
