//! AUTOGENERATED FOR sample - MODIFICATIONS WILL BE LOST

#![allow(non_snake_case)]
#![allow(unused)]

use crate::graph::{self, *};
use crate::graph_enums::*;
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::context;
use analyzer::world::World;
use enum_map::EnumMap;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use std::str::FromStr;
use yaml_rust::Yaml;

pub mod enums {
    use std::fmt;
    #[derive(
        Debug,
        PartialEq,
        Eq,
        Copy,
        Clone,
        Hash,
        Ord,
        PartialOrd,
        Default,
        serde_repr::Serialize_repr,
        serde_repr::Deserialize_repr,
    )]
    #[repr(u8)]
    pub enum Tod {
        #[default]
        Day,
        Night,
    }
    impl fmt::Display for Tod {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Tod::Day => write!(f, "{}", "Day"),

                Tod::Night => write!(f, "{}", "Night"),
            }
        }
    }
    impl std::str::FromStr for Tod {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Day" | "day" => Ok(Tod::Day),
                "Night" | "night" => Ok(Tod::Night),
                _ => Err(format!("Could not recognize as a Tod: {}", s)),
            }
        }
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Expectation {
    Position(SpotId),
    Save(SpotId),
    Child(bool),
    Tod(enums::Tod),
    Rupees(i32),
    DekuTreeCompassRoomCtxTorch(bool),
    // items
    BiggoronSword(bool),
    Bombs(bool),
    Boomerang(bool),
    Bow(bool),
    BuyDekuNut10(bool),
    BuyDekuNut5(bool),
    BuyDekuShield(bool),
    BuyDekuStick1(bool),
    DefeatGanon(bool),
    DefeatGohma(bool),
    DekuBackRoomWall(bool),
    DekuBackRoomWeb(bool),
    DekuBasementBlock(bool),
    DekuBasementScrubs(bool),
    DekuBasementSwitch(bool),
    DekuBasementWeb(bool),
    DekuLobbyWeb(bool),
    DekuNutDrop(bool),
    DekuShieldDrop(bool),
    DekuSlingshotScrub(bool),
    DekuStickDrop(bool),
    GoldSkulltulaToken(i8),
    HylianShield(bool),
    KokiriEmerald(bool),
    KokiriSword(bool),
    MagicMeter(bool),
    Ocarina(bool),
    ShowedMido(bool),
    Slingshot(bool),
    TriforcePiece(i16),
}

pub mod data {
    #[allow(unused_imports)]
    use crate::context::enums;
    use crate::graph_enums::*;
}

pub mod flags {
    use bitflags::bitflags;
    use serde::{self, Deserialize, Serialize};

    bitflags! {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub struct ContextBits1 : u32 {
            const CHILD = 0x1;
            const DEKU_TREE__COMPASS_ROOM__CTX__TORCH = 0x2;
            const LOGIC_DEKU_B1_SKIP = 0x4;
            const BIGGORON_SWORD = 0x8;
            const BOMBS = 0x10;
            const BOOMERANG = 0x20;
            const BOW = 0x40;
            const BUY_DEKU_NUT_10 = 0x80;
            const BUY_DEKU_NUT_5 = 0x100;
            const BUY_DEKU_SHIELD = 0x200;
            const BUY_DEKU_STICK_1 = 0x400;
            const DEFEAT_GANON = 0x800;
            const DEFEAT_GOHMA = 0x1000;
            const DEKU_BACK_ROOM_WALL = 0x2000;
            const DEKU_BACK_ROOM_WEB = 0x4000;
            const DEKU_BASEMENT_BLOCK = 0x8000;
            const DEKU_BASEMENT_SCRUBS = 0x10000;
            const DEKU_BASEMENT_SWITCH = 0x20000;
            const DEKU_BASEMENT_WEB = 0x40000;
            const DEKU_LOBBY_WEB = 0x80000;
            const DEKU_NUT_DROP = 0x100000;
            const DEKU_SHIELD_DROP = 0x200000;
            const DEKU_SLINGSHOT_SCRUB = 0x400000;
            const DEKU_STICK_DROP = 0x800000;
            const HYLIAN_SHIELD = 0x1000000;
            const KOKIRI_EMERALD = 0x2000000;
            const KOKIRI_SWORD = 0x4000000;
            const MAGIC_METER = 0x8000000;
            const OCARINA = 0x10000000;
            const SHOWED_MIDO = 0x20000000;
            const SLINGSHOT = 0x40000000;
        }
    }
    impl Default for ContextBits1 {
        fn default() -> ContextBits1 {
            ContextBits1::CHILD
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum Status {
    #[default]
    None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct Context {
    // context vars
    pub position: SpotId,
    pub save: SpotId,
    pub tod: enums::Tod,
    pub rupees: i32,
    // settings
    pub triforce_count: i16,
    // items
    pub gold_skulltula_token: i8,
    pub triforce_piece: i16,
    // bitflags
    pub cbits1: flags::ContextBits1,
    // other
    pub status: EnumMap<LocationId, Status>,

    visits: u32,
    skips: u32,
}

impl Default for Context {
    fn default() -> Context {
        Context {
            position: SpotId::KF__Links_House__Start_Point,
            save: SpotId::KF__Links_House__Start_Point,
            tod: enums::Tod::Day,
            rupees: 0,
            // settings
            triforce_count: Default::default(),
            // items
            gold_skulltula_token: Default::default(),
            triforce_piece: Default::default(),
            // bitflags
            cbits1: Default::default(),
            // other
            status: Default::default(),
            visits: Default::default(),
            skips: Default::default(),
        }
    }
}

impl context::Ctx for Context {
    type World = graph::World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;
    type MovementState = movements::MovementState;
    type Expectation = Expectation;
    const NUM_ITEMS: u32 = 30;

    fn has(&self, item: Item) -> bool {
        match item {
            Item::Biggoron_Sword => self.cbits1.contains(flags::ContextBits1::BIGGORON_SWORD),
            Item::Bombs => self.cbits1.contains(flags::ContextBits1::BOMBS),
            Item::Boomerang => self.cbits1.contains(flags::ContextBits1::BOOMERANG),
            Item::Bow => self.cbits1.contains(flags::ContextBits1::BOW),
            Item::Buy_Deku_Nut_10 => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_10),
            Item::Buy_Deku_Nut_5 => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_5),
            Item::Buy_Deku_Shield => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_SHIELD),
            Item::Buy_Deku_Stick_1 => self.cbits1.contains(flags::ContextBits1::BUY_DEKU_STICK_1),
            Item::Defeat_Ganon => self.cbits1.contains(flags::ContextBits1::DEFEAT_GANON),
            Item::Defeat_Gohma => self.cbits1.contains(flags::ContextBits1::DEFEAT_GOHMA),
            Item::Deku_Back_Room_Wall => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL),
            Item::Deku_Back_Room_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB),
            Item::Deku_Basement_Block => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK),
            Item::Deku_Basement_Scrubs => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS),
            Item::Deku_Basement_Switch => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH),
            Item::Deku_Basement_Web => self.cbits1.contains(flags::ContextBits1::DEKU_BASEMENT_WEB),
            Item::Deku_Lobby_Web => self.cbits1.contains(flags::ContextBits1::DEKU_LOBBY_WEB),
            Item::Deku_Nut_Drop => self.cbits1.contains(flags::ContextBits1::DEKU_NUT_DROP),
            Item::Deku_Shield_Drop => self.cbits1.contains(flags::ContextBits1::DEKU_SHIELD_DROP),
            Item::Deku_Slingshot_Scrub => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB),
            Item::Deku_Stick_Drop => self.cbits1.contains(flags::ContextBits1::DEKU_STICK_DROP),
            Item::Gold_Skulltula_Token => self.gold_skulltula_token >= 1,
            Item::Hylian_Shield => self.cbits1.contains(flags::ContextBits1::HYLIAN_SHIELD),
            Item::Kokiri_Emerald => self.cbits1.contains(flags::ContextBits1::KOKIRI_EMERALD),
            Item::Kokiri_Sword => self.cbits1.contains(flags::ContextBits1::KOKIRI_SWORD),
            Item::Magic_Meter => self.cbits1.contains(flags::ContextBits1::MAGIC_METER),
            Item::Ocarina => self.cbits1.contains(flags::ContextBits1::OCARINA),
            Item::Showed_Mido => self.cbits1.contains(flags::ContextBits1::SHOWED_MIDO),
            Item::Slingshot => self.cbits1.contains(flags::ContextBits1::SLINGSHOT),
            Item::Triforce_Piece => self.triforce_piece >= 1,
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
            Item::Biggoron_Sword => self
                .cbits1
                .contains(flags::ContextBits1::BIGGORON_SWORD)
                .into(),
            Item::Bombs => self.cbits1.contains(flags::ContextBits1::BOMBS).into(),
            Item::Boomerang => self.cbits1.contains(flags::ContextBits1::BOOMERANG).into(),
            Item::Bow => self.cbits1.contains(flags::ContextBits1::BOW).into(),
            Item::Buy_Deku_Nut_10 => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_NUT_10)
                .into(),
            Item::Buy_Deku_Nut_5 => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_NUT_5)
                .into(),
            Item::Buy_Deku_Shield => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_SHIELD)
                .into(),
            Item::Buy_Deku_Stick_1 => self
                .cbits1
                .contains(flags::ContextBits1::BUY_DEKU_STICK_1)
                .into(),
            Item::Defeat_Ganon => self
                .cbits1
                .contains(flags::ContextBits1::DEFEAT_GANON)
                .into(),
            Item::Defeat_Gohma => self
                .cbits1
                .contains(flags::ContextBits1::DEFEAT_GOHMA)
                .into(),
            Item::Deku_Back_Room_Wall => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL)
                .into(),
            Item::Deku_Back_Room_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB)
                .into(),
            Item::Deku_Basement_Block => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK)
                .into(),
            Item::Deku_Basement_Scrubs => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS)
                .into(),
            Item::Deku_Basement_Switch => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH)
                .into(),
            Item::Deku_Basement_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_BASEMENT_WEB)
                .into(),
            Item::Deku_Lobby_Web => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_LOBBY_WEB)
                .into(),
            Item::Deku_Nut_Drop => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_NUT_DROP)
                .into(),
            Item::Deku_Shield_Drop => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_SHIELD_DROP)
                .into(),
            Item::Deku_Slingshot_Scrub => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB)
                .into(),
            Item::Deku_Stick_Drop => self
                .cbits1
                .contains(flags::ContextBits1::DEKU_STICK_DROP)
                .into(),
            Item::Gold_Skulltula_Token => self.gold_skulltula_token.into(),
            Item::Hylian_Shield => self
                .cbits1
                .contains(flags::ContextBits1::HYLIAN_SHIELD)
                .into(),
            Item::Kokiri_Emerald => self
                .cbits1
                .contains(flags::ContextBits1::KOKIRI_EMERALD)
                .into(),
            Item::Kokiri_Sword => self
                .cbits1
                .contains(flags::ContextBits1::KOKIRI_SWORD)
                .into(),
            Item::Magic_Meter => self
                .cbits1
                .contains(flags::ContextBits1::MAGIC_METER)
                .into(),
            Item::Ocarina => self.cbits1.contains(flags::ContextBits1::OCARINA).into(),
            Item::Showed_Mido => self
                .cbits1
                .contains(flags::ContextBits1::SHOWED_MIDO)
                .into(),
            Item::Slingshot => self.cbits1.contains(flags::ContextBits1::SLINGSHOT).into(),
            Item::Triforce_Piece => self.triforce_piece.into(),
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
            Item::Biggoron_Sword => {
                self.cbits1.insert(flags::ContextBits1::BIGGORON_SWORD);
            }
            Item::Bombs => {
                self.cbits1.insert(flags::ContextBits1::BOMBS);
            }
            Item::Boomerang => {
                self.cbits1.insert(flags::ContextBits1::BOOMERANG);
            }
            Item::Bow => {
                self.cbits1.insert(flags::ContextBits1::BOW);
            }
            Item::Buy_Deku_Nut_10 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_10);
            }
            Item::Buy_Deku_Nut_5 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_5);
            }
            Item::Buy_Deku_Shield => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_SHIELD);
            }
            Item::Buy_Deku_Stick_1 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_STICK_1);
            }
            Item::Defeat_Ganon => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GANON);
            }
            Item::Defeat_Gohma => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GOHMA);
            }
            Item::Deku_Back_Room_Wall => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
            }
            Item::Deku_Back_Room_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
            }
            Item::Deku_Basement_Block => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
            }
            Item::Deku_Basement_Scrubs => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
            }
            Item::Deku_Basement_Switch => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
            }
            Item::Deku_Basement_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_WEB);
            }
            Item::Deku_Lobby_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_LOBBY_WEB);
            }
            Item::Deku_Nut_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_NUT_DROP);
            }
            Item::Deku_Shield_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_SHIELD_DROP);
            }
            Item::Deku_Slingshot_Scrub => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
            }
            Item::Deku_Stick_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_STICK_DROP);
            }
            Item::Gold_Skulltula_Token => {
                self.gold_skulltula_token += 1;
            }
            Item::Hylian_Shield => {
                self.cbits1.insert(flags::ContextBits1::HYLIAN_SHIELD);
            }
            Item::Kokiri_Emerald => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_EMERALD);
            }
            Item::Kokiri_Sword => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_SWORD);
            }
            Item::Magic_Meter => {
                self.cbits1.insert(flags::ContextBits1::MAGIC_METER);
            }
            Item::Ocarina => {
                self.cbits1.insert(flags::ContextBits1::OCARINA);
            }
            Item::Showed_Mido => {
                self.cbits1.insert(flags::ContextBits1::SHOWED_MIDO);
            }
            Item::Slingshot => {
                self.cbits1.insert(flags::ContextBits1::SLINGSHOT);
            }
            Item::Triforce_Piece => {
                self.triforce_piece += 1;
            }
            Item::Rupee_1 => rules::action_rupees__min__rupees__1_wallet_max(self),
            Item::Rupees_5 => rules::action_rupees__min__rupees__5_wallet_max(self),
            Item::Rupees_50 => rules::action_rupees__min__rupees__50_wallet_max(self),
            _ => (),
        }
    }

    // test helper for items
    fn add_item(&mut self, item: Item) {
        match item {
            Item::Biggoron_Sword => {
                self.cbits1.insert(flags::ContextBits1::BIGGORON_SWORD);
            }
            Item::Bombs => {
                self.cbits1.insert(flags::ContextBits1::BOMBS);
            }
            Item::Boomerang => {
                self.cbits1.insert(flags::ContextBits1::BOOMERANG);
            }
            Item::Bow => {
                self.cbits1.insert(flags::ContextBits1::BOW);
            }
            Item::Buy_Deku_Nut_10 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_10);
            }
            Item::Buy_Deku_Nut_5 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_NUT_5);
            }
            Item::Buy_Deku_Shield => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_SHIELD);
            }
            Item::Buy_Deku_Stick_1 => {
                self.cbits1.insert(flags::ContextBits1::BUY_DEKU_STICK_1);
            }
            Item::Defeat_Ganon => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GANON);
            }
            Item::Defeat_Gohma => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_GOHMA);
            }
            Item::Deku_Back_Room_Wall => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
            }
            Item::Deku_Back_Room_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
            }
            Item::Deku_Basement_Block => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
            }
            Item::Deku_Basement_Scrubs => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
            }
            Item::Deku_Basement_Switch => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
            }
            Item::Deku_Basement_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_BASEMENT_WEB);
            }
            Item::Deku_Lobby_Web => {
                self.cbits1.insert(flags::ContextBits1::DEKU_LOBBY_WEB);
            }
            Item::Deku_Nut_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_NUT_DROP);
            }
            Item::Deku_Shield_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_SHIELD_DROP);
            }
            Item::Deku_Slingshot_Scrub => {
                self.cbits1
                    .insert(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
            }
            Item::Deku_Stick_Drop => {
                self.cbits1.insert(flags::ContextBits1::DEKU_STICK_DROP);
            }
            Item::Gold_Skulltula_Token => {
                self.gold_skulltula_token += 1;
            }
            Item::Hylian_Shield => {
                self.cbits1.insert(flags::ContextBits1::HYLIAN_SHIELD);
            }
            Item::Kokiri_Emerald => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_EMERALD);
            }
            Item::Kokiri_Sword => {
                self.cbits1.insert(flags::ContextBits1::KOKIRI_SWORD);
            }
            Item::Magic_Meter => {
                self.cbits1.insert(flags::ContextBits1::MAGIC_METER);
            }
            Item::Ocarina => {
                self.cbits1.insert(flags::ContextBits1::OCARINA);
            }
            Item::Showed_Mido => {
                self.cbits1.insert(flags::ContextBits1::SHOWED_MIDO);
            }
            Item::Slingshot => {
                self.cbits1.insert(flags::ContextBits1::SLINGSHOT);
            }
            Item::Triforce_Piece => {
                self.triforce_piece += 1;
            }
            _ => (),
        }
    }

    // test helper for context vars
    fn parse_set_context(&mut self, ckey: &str, cval: &Yaml) -> Result<(), String> {
        match (ckey, cval) {
            ("position", Yaml::String(s)) => {
                self.set_position(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("position", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("save", Yaml::String(s)) => {
                self.set_save(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("save", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("child", Yaml::Boolean(b)) => self.set_child(*b),
            ("child", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("tod", Yaml::String(s)) => {
                self.set_tod(enums::Tod::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("tod", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("rupees", Yaml::Integer(i)) => {
                self.set_rupees(i32::try_from(*i).map_err(|e| format!("{}", e))?)
            }
            ("rupees", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("deku_tree__compass_room__ctx__torch", Yaml::Boolean(b)) => {
                self.set_deku_tree__compass_room__ctx__torch(*b)
            }
            ("deku_tree__compass_room__ctx__torch", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("triforce_count", Yaml::Integer(i)) => {
                self.set_triforce_count(i16::try_from(*i).map_err(|e| format!("{}", e))?)
            }
            ("triforce_count", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("logic_deku_b1_skip", Yaml::Boolean(b)) => self.set_logic_deku_b1_skip(*b),
            ("logic_deku_b1_skip", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            _ => {
                return Err(format!("Unrecognized context key: {:?}", ckey));
            }
        }
        Ok(())
    }

    fn parse_expect_context(ckey: &str, cval: &Yaml) -> Result<Expectation, String> {
        Ok(match (ckey, cval) {
            ("position", Yaml::String(s)) => {
                Expectation::Position(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("position", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("save", Yaml::String(s)) => {
                Expectation::Save(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("save", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("child", Yaml::Boolean(b)) => Expectation::Child(*b),
            ("child", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("tod", Yaml::String(s)) => {
                Expectation::Tod(enums::Tod::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("tod", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("rupees", Yaml::Integer(i)) => {
                Expectation::Rupees(i32::try_from(*i).map_err(|e| format!("{}", e))?)
            }
            ("rupees", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("deku_tree__compass_room__ctx__torch", Yaml::Boolean(b)) => {
                Expectation::DekuTreeCompassRoomCtxTorch(*b)
            }
            ("deku_tree__compass_room__ctx__torch", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Biggoron_Sword", Yaml::Boolean(b)) => Expectation::BiggoronSword(*b),
            ("Biggoron_Sword", Yaml::Integer(i)) => Expectation::BiggoronSword(*i > 0),
            ("Biggoron_Sword", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Bombs", Yaml::Boolean(b)) => Expectation::Bombs(*b),
            ("Bombs", Yaml::Integer(i)) => Expectation::Bombs(*i > 0),
            ("Bombs", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Boomerang", Yaml::Boolean(b)) => Expectation::Boomerang(*b),
            ("Boomerang", Yaml::Integer(i)) => Expectation::Boomerang(*i > 0),
            ("Boomerang", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Bow", Yaml::Boolean(b)) => Expectation::Bow(*b),
            ("Bow", Yaml::Integer(i)) => Expectation::Bow(*i > 0),
            ("Bow", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Buy_Deku_Nut_10", Yaml::Boolean(b)) => Expectation::BuyDekuNut10(*b),
            ("Buy_Deku_Nut_10", Yaml::Integer(i)) => Expectation::BuyDekuNut10(*i > 0),
            ("Buy_Deku_Nut_10", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Buy_Deku_Nut_5", Yaml::Boolean(b)) => Expectation::BuyDekuNut5(*b),
            ("Buy_Deku_Nut_5", Yaml::Integer(i)) => Expectation::BuyDekuNut5(*i > 0),
            ("Buy_Deku_Nut_5", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Buy_Deku_Shield", Yaml::Boolean(b)) => Expectation::BuyDekuShield(*b),
            ("Buy_Deku_Shield", Yaml::Integer(i)) => Expectation::BuyDekuShield(*i > 0),
            ("Buy_Deku_Shield", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Buy_Deku_Stick_1", Yaml::Boolean(b)) => Expectation::BuyDekuStick1(*b),
            ("Buy_Deku_Stick_1", Yaml::Integer(i)) => Expectation::BuyDekuStick1(*i > 0),
            ("Buy_Deku_Stick_1", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Defeat_Ganon", Yaml::Boolean(b)) => Expectation::DefeatGanon(*b),
            ("Defeat_Ganon", Yaml::Integer(i)) => Expectation::DefeatGanon(*i > 0),
            ("Defeat_Ganon", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Defeat_Gohma", Yaml::Boolean(b)) => Expectation::DefeatGohma(*b),
            ("Defeat_Gohma", Yaml::Integer(i)) => Expectation::DefeatGohma(*i > 0),
            ("Defeat_Gohma", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Back_Room_Wall", Yaml::Boolean(b)) => Expectation::DekuBackRoomWall(*b),
            ("Deku_Back_Room_Wall", Yaml::Integer(i)) => Expectation::DekuBackRoomWall(*i > 0),
            ("Deku_Back_Room_Wall", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Back_Room_Web", Yaml::Boolean(b)) => Expectation::DekuBackRoomWeb(*b),
            ("Deku_Back_Room_Web", Yaml::Integer(i)) => Expectation::DekuBackRoomWeb(*i > 0),
            ("Deku_Back_Room_Web", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Basement_Block", Yaml::Boolean(b)) => Expectation::DekuBasementBlock(*b),
            ("Deku_Basement_Block", Yaml::Integer(i)) => Expectation::DekuBasementBlock(*i > 0),
            ("Deku_Basement_Block", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Basement_Scrubs", Yaml::Boolean(b)) => Expectation::DekuBasementScrubs(*b),
            ("Deku_Basement_Scrubs", Yaml::Integer(i)) => Expectation::DekuBasementScrubs(*i > 0),
            ("Deku_Basement_Scrubs", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Basement_Switch", Yaml::Boolean(b)) => Expectation::DekuBasementSwitch(*b),
            ("Deku_Basement_Switch", Yaml::Integer(i)) => Expectation::DekuBasementSwitch(*i > 0),
            ("Deku_Basement_Switch", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Basement_Web", Yaml::Boolean(b)) => Expectation::DekuBasementWeb(*b),
            ("Deku_Basement_Web", Yaml::Integer(i)) => Expectation::DekuBasementWeb(*i > 0),
            ("Deku_Basement_Web", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Lobby_Web", Yaml::Boolean(b)) => Expectation::DekuLobbyWeb(*b),
            ("Deku_Lobby_Web", Yaml::Integer(i)) => Expectation::DekuLobbyWeb(*i > 0),
            ("Deku_Lobby_Web", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Nut_Drop", Yaml::Boolean(b)) => Expectation::DekuNutDrop(*b),
            ("Deku_Nut_Drop", Yaml::Integer(i)) => Expectation::DekuNutDrop(*i > 0),
            ("Deku_Nut_Drop", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Shield_Drop", Yaml::Boolean(b)) => Expectation::DekuShieldDrop(*b),
            ("Deku_Shield_Drop", Yaml::Integer(i)) => Expectation::DekuShieldDrop(*i > 0),
            ("Deku_Shield_Drop", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Slingshot_Scrub", Yaml::Boolean(b)) => Expectation::DekuSlingshotScrub(*b),
            ("Deku_Slingshot_Scrub", Yaml::Integer(i)) => Expectation::DekuSlingshotScrub(*i > 0),
            ("Deku_Slingshot_Scrub", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Deku_Stick_Drop", Yaml::Boolean(b)) => Expectation::DekuStickDrop(*b),
            ("Deku_Stick_Drop", Yaml::Integer(i)) => Expectation::DekuStickDrop(*i > 0),
            ("Deku_Stick_Drop", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Gold_Skulltula_Token", Yaml::Integer(i)) => {
                Expectation::GoldSkulltulaToken(i8::try_from(*i).map_err(|e| format!("{}", e))?)
            }
            ("Gold_Skulltula_Token", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Hylian_Shield", Yaml::Boolean(b)) => Expectation::HylianShield(*b),
            ("Hylian_Shield", Yaml::Integer(i)) => Expectation::HylianShield(*i > 0),
            ("Hylian_Shield", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Kokiri_Emerald", Yaml::Boolean(b)) => Expectation::KokiriEmerald(*b),
            ("Kokiri_Emerald", Yaml::Integer(i)) => Expectation::KokiriEmerald(*i > 0),
            ("Kokiri_Emerald", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Kokiri_Sword", Yaml::Boolean(b)) => Expectation::KokiriSword(*b),
            ("Kokiri_Sword", Yaml::Integer(i)) => Expectation::KokiriSword(*i > 0),
            ("Kokiri_Sword", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Magic_Meter", Yaml::Boolean(b)) => Expectation::MagicMeter(*b),
            ("Magic_Meter", Yaml::Integer(i)) => Expectation::MagicMeter(*i > 0),
            ("Magic_Meter", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Ocarina", Yaml::Boolean(b)) => Expectation::Ocarina(*b),
            ("Ocarina", Yaml::Integer(i)) => Expectation::Ocarina(*i > 0),
            ("Ocarina", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Showed_Mido", Yaml::Boolean(b)) => Expectation::ShowedMido(*b),
            ("Showed_Mido", Yaml::Integer(i)) => Expectation::ShowedMido(*i > 0),
            ("Showed_Mido", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Slingshot", Yaml::Boolean(b)) => Expectation::Slingshot(*b),
            ("Slingshot", Yaml::Integer(i)) => Expectation::Slingshot(*i > 0),
            ("Slingshot", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("Triforce_Piece", Yaml::Integer(i)) => {
                Expectation::TriforcePiece(i16::try_from(*i).map_err(|e| format!("{}", e))?)
            }
            ("Triforce_Piece", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            _ => {
                return Err(format!(
                    "Unrecognized/disallowed expect context key: {:?}",
                    ckey
                ));
            }
        })
    }

    fn assert_expectations(&self, exps: &Vec<Self::Expectation>) -> Result<(), String> {
        let mut errs = Vec::new();
        for exp in exps {
            match exp {
                Expectation::Position(e) => {
                    let v = self.position();
                    if v != *e {
                        errs.push(format!("Expected {} = {}, got: {}", "position", e, v));
                    }
                }
                Expectation::Save(e) => {
                    let v = self.save();
                    if v != *e {
                        errs.push(format!("Expected {} = {}, got: {}", "save", e, v));
                    }
                }
                Expectation::Child(e) => {
                    let v = self.child();
                    if v != *e {
                        errs.push(format!("Expected {} = {}, got: {}", "child", e, v));
                    }
                }
                Expectation::Tod(e) => {
                    let v = self.tod();
                    if v != *e {
                        errs.push(format!("Expected {} = {}, got: {}", "tod", e, v));
                    }
                }
                Expectation::Rupees(e) => {
                    let v = self.rupees();
                    if v != *e {
                        errs.push(format!("Expected {} = {}, got: {}", "rupees", e, v));
                    }
                }
                Expectation::DekuTreeCompassRoomCtxTorch(e) => {
                    let v = self.deku_tree__compass_room__ctx__torch();
                    if v != *e {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "deku_tree__compass_room__ctx__torch", e, v
                        ));
                    }
                }
                Expectation::BiggoronSword(e) => {
                    let v = self.has(Item::Biggoron_Sword);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Biggoron_Sword", e, v));
                    }
                }
                Expectation::Bombs(e) => {
                    let v = self.has(Item::Bombs);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Bombs", e, v));
                    }
                }
                Expectation::Boomerang(e) => {
                    let v = self.has(Item::Boomerang);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Boomerang", e, v));
                    }
                }
                Expectation::Bow(e) => {
                    let v = self.has(Item::Bow);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Bow", e, v));
                    }
                }
                Expectation::BuyDekuNut10(e) => {
                    let v = self.has(Item::Buy_Deku_Nut_10);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Buy_Deku_Nut_10", e, v
                        ));
                    }
                }
                Expectation::BuyDekuNut5(e) => {
                    let v = self.has(Item::Buy_Deku_Nut_5);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Buy_Deku_Nut_5", e, v));
                    }
                }
                Expectation::BuyDekuShield(e) => {
                    let v = self.has(Item::Buy_Deku_Shield);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Buy_Deku_Shield", e, v
                        ));
                    }
                }
                Expectation::BuyDekuStick1(e) => {
                    let v = self.has(Item::Buy_Deku_Stick_1);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Buy_Deku_Stick_1", e, v
                        ));
                    }
                }
                Expectation::DefeatGanon(e) => {
                    let v = self.has(Item::Defeat_Ganon);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Defeat_Ganon", e, v));
                    }
                }
                Expectation::DefeatGohma(e) => {
                    let v = self.has(Item::Defeat_Gohma);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Defeat_Gohma", e, v));
                    }
                }
                Expectation::DekuBackRoomWall(e) => {
                    let v = self.has(Item::Deku_Back_Room_Wall);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Back_Room_Wall", e, v
                        ));
                    }
                }
                Expectation::DekuBackRoomWeb(e) => {
                    let v = self.has(Item::Deku_Back_Room_Web);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Back_Room_Web", e, v
                        ));
                    }
                }
                Expectation::DekuBasementBlock(e) => {
                    let v = self.has(Item::Deku_Basement_Block);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Basement_Block", e, v
                        ));
                    }
                }
                Expectation::DekuBasementScrubs(e) => {
                    let v = self.has(Item::Deku_Basement_Scrubs);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Basement_Scrubs", e, v
                        ));
                    }
                }
                Expectation::DekuBasementSwitch(e) => {
                    let v = self.has(Item::Deku_Basement_Switch);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Basement_Switch", e, v
                        ));
                    }
                }
                Expectation::DekuBasementWeb(e) => {
                    let v = self.has(Item::Deku_Basement_Web);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Basement_Web", e, v
                        ));
                    }
                }
                Expectation::DekuLobbyWeb(e) => {
                    let v = self.has(Item::Deku_Lobby_Web);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Deku_Lobby_Web", e, v));
                    }
                }
                Expectation::DekuNutDrop(e) => {
                    let v = self.has(Item::Deku_Nut_Drop);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Deku_Nut_Drop", e, v));
                    }
                }
                Expectation::DekuShieldDrop(e) => {
                    let v = self.has(Item::Deku_Shield_Drop);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Shield_Drop", e, v
                        ));
                    }
                }
                Expectation::DekuSlingshotScrub(e) => {
                    let v = self.has(Item::Deku_Slingshot_Scrub);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Slingshot_Scrub", e, v
                        ));
                    }
                }
                Expectation::DekuStickDrop(e) => {
                    let v = self.has(Item::Deku_Stick_Drop);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Deku_Stick_Drop", e, v
                        ));
                    }
                }
                Expectation::GoldSkulltulaToken(e) => {
                    let v = self.count(Item::Gold_Skulltula_Token);
                    if v != (*e).into() {
                        errs.push(format!(
                            "Expected {} = {}, got: {}",
                            "Gold_Skulltula_Token", e, v
                        ));
                    }
                }
                Expectation::HylianShield(e) => {
                    let v = self.has(Item::Hylian_Shield);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Hylian_Shield", e, v));
                    }
                }
                Expectation::KokiriEmerald(e) => {
                    let v = self.has(Item::Kokiri_Emerald);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Kokiri_Emerald", e, v));
                    }
                }
                Expectation::KokiriSword(e) => {
                    let v = self.has(Item::Kokiri_Sword);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Kokiri_Sword", e, v));
                    }
                }
                Expectation::MagicMeter(e) => {
                    let v = self.has(Item::Magic_Meter);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Magic_Meter", e, v));
                    }
                }
                Expectation::Ocarina(e) => {
                    let v = self.has(Item::Ocarina);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Ocarina", e, v));
                    }
                }
                Expectation::ShowedMido(e) => {
                    let v = self.has(Item::Showed_Mido);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Showed_Mido", e, v));
                    }
                }
                Expectation::Slingshot(e) => {
                    let v = self.has(Item::Slingshot);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Slingshot", e, v));
                    }
                }
                Expectation::TriforcePiece(e) => {
                    let v = self.count(Item::Triforce_Piece);
                    if v != (*e).into() {
                        errs.push(format!("Expected {} = {}, got: {}", "Triforce_Piece", e, v));
                    }
                }
            }
        }
        if errs.is_empty() {
            Ok(())
        } else {
            Err(errs.join("\n"))
        }
    }

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position_raw(&mut self, pos: SpotId) {
        self.position = pos;
    }
    fn set_position(&mut self, pos: SpotId) {
        let area = get_area(pos);
        match area {
            AreaId::Deku_Tree__Compass_Room => {
                if get_area(self.position) != area {
                    self.cbits1
                        .remove(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
                }
            }
            _ => (),
        }
        self.position = pos;
    }

    fn reload_game(&mut self) {
        self.reset_all();
    }

    fn reset_all(&mut self) {}

    fn reset_region(&mut self, region_id: RegionId) {}
    fn reset_area(&mut self, area_id: AreaId) {}
    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
            Currency::Rupees(c) => self.rupees >= *c,
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
            Currency::Rupees(c) => self.rupees -= *c,
        }
    }

    fn visit(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Visited;
        self.visits += 1;
    }
    fn skip(&mut self, loc_id: LocationId) {
        if self.status[loc_id] == Status::None {
            self.status[loc_id] = Status::Skipped;
            self.skips += 1;
        }
    }
    fn reset(&mut self, loc_id: LocationId) {
        match self.status[loc_id] {
            Status::Visited => self.visits -= 1,
            Status::Skipped => self.skips -= 1,
            _ => (),
        }
        self.status[loc_id] = Status::None;
    }

    fn todo(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::None
    }
    fn visited(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Visited
    }
    fn skipped(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Skipped
    }

    fn all_spot_checks(&self, id: SpotId) -> bool {
        let r = spot_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_area_checks(&self, id: AreaId) -> bool {
        let r = area_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_region_checks(&self, id: RegionId) -> bool {
        let r = region_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn get_movement_state(&self) -> movements::MovementState {
        movements::get_movement_state(self)
    }

    fn local_travel_time(&self, movement_state: movements::MovementState, dest: SpotId) -> u32 {
        movements::local_travel_time(self, movement_state, self.position, dest)
    }

    fn count_visits(&self) -> u32 {
        self.visits
    }
    fn count_skips(&self) -> u32 {
        self.skips
    }
    fn progress(&self) -> u32 {
        if self.visits <= 0 {
            0
        } else {
            self.visits * 100 / (Self::World::NUM_LOCATIONS - self.skips)
        }
    }

    fn diff(&self, old: &Context) -> String {
        let mut list: Vec<String> = Vec::new();

        if old.position != self.position {
            list.push(format!(
                "position: {:?} → {:?}",
                old.position, self.position
            ));
        }
        if old.save != self.save {
            list.push(format!("save: {:?} → {:?}", old.save, self.save));
        }
        if old.tod != self.tod {
            list.push(format!("tod: {:?} → {:?}", old.tod, self.tod));
        }
        if old.rupees != self.rupees {
            list.push(format!("rupees: {:?} → {:?}", old.rupees, self.rupees));
        }
        if old.triforce_count != self.triforce_count {
            list.push(format!(
                "triforce_count: {:?} → {:?}",
                old.triforce_count, self.triforce_count
            ));
        }
        if old.gold_skulltula_token != self.gold_skulltula_token {
            list.push(format!(
                "Gold_Skulltula_Token: {:+}",
                self.gold_skulltula_token - old.gold_skulltula_token
            ));
        }
        if old.triforce_piece != self.triforce_piece {
            list.push(format!(
                "Triforce_Piece: {:+}",
                self.triforce_piece - old.triforce_piece
            ));
        }
        // bitflags
        let n = self.cbits1.contains(flags::ContextBits1::CHILD);
        let p = old.cbits1.contains(flags::ContextBits1::CHILD);
        if n != p {
            list.push(format!("{}CHILD", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH);
        if n != p {
            list.push(format!(
                "{}DEKU_TREE__COMPASS_ROOM__CTX__TORCH",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::LOGIC_DEKU_B1_SKIP);
        let p = old.cbits1.contains(flags::ContextBits1::LOGIC_DEKU_B1_SKIP);
        if n != p {
            list.push(format!("{}LOGIC_DEKU_B1_SKIP", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BIGGORON_SWORD);
        let p = old.cbits1.contains(flags::ContextBits1::BIGGORON_SWORD);
        if n != p {
            list.push(format!("{}BIGGORON_SWORD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOMBS);
        let p = old.cbits1.contains(flags::ContextBits1::BOMBS);
        if n != p {
            list.push(format!("{}BOMBS", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOOMERANG);
        let p = old.cbits1.contains(flags::ContextBits1::BOOMERANG);
        if n != p {
            list.push(format!("{}BOOMERANG", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOW);
        let p = old.cbits1.contains(flags::ContextBits1::BOW);
        if n != p {
            list.push(format!("{}BOW", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_10);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_10);
        if n != p {
            list.push(format!("{}BUY_DEKU_NUT_10", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_5);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_NUT_5);
        if n != p {
            list.push(format!("{}BUY_DEKU_NUT_5", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_SHIELD);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_SHIELD);
        if n != p {
            list.push(format!("{}BUY_DEKU_SHIELD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BUY_DEKU_STICK_1);
        let p = old.cbits1.contains(flags::ContextBits1::BUY_DEKU_STICK_1);
        if n != p {
            list.push(format!("{}BUY_DEKU_STICK_1", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEFEAT_GANON);
        let p = old.cbits1.contains(flags::ContextBits1::DEFEAT_GANON);
        if n != p {
            list.push(format!("{}DEFEAT_GANON", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEFEAT_GOHMA);
        let p = old.cbits1.contains(flags::ContextBits1::DEFEAT_GOHMA);
        if n != p {
            list.push(format!("{}DEFEAT_GOHMA", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BACK_ROOM_WALL);
        if n != p {
            list.push(format!("{}DEKU_BACK_ROOM_WALL", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_BACK_ROOM_WEB);
        if n != p {
            list.push(format!("{}DEKU_BACK_ROOM_WEB", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_BLOCK);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_BLOCK", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SCRUBS);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_SCRUBS", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_BASEMENT_SWITCH);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_SWITCH", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_BASEMENT_WEB);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_BASEMENT_WEB);
        if n != p {
            list.push(format!("{}DEKU_BASEMENT_WEB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_LOBBY_WEB);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_LOBBY_WEB);
        if n != p {
            list.push(format!("{}DEKU_LOBBY_WEB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_NUT_DROP);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_NUT_DROP);
        if n != p {
            list.push(format!("{}DEKU_NUT_DROP", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_SHIELD_DROP);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_SHIELD_DROP);
        if n != p {
            list.push(format!("{}DEKU_SHIELD_DROP", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::DEKU_SLINGSHOT_SCRUB);
        if n != p {
            list.push(format!("{}DEKU_SLINGSHOT_SCRUB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEKU_STICK_DROP);
        let p = old.cbits1.contains(flags::ContextBits1::DEKU_STICK_DROP);
        if n != p {
            list.push(format!("{}DEKU_STICK_DROP", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::HYLIAN_SHIELD);
        let p = old.cbits1.contains(flags::ContextBits1::HYLIAN_SHIELD);
        if n != p {
            list.push(format!("{}HYLIAN_SHIELD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::KOKIRI_EMERALD);
        let p = old.cbits1.contains(flags::ContextBits1::KOKIRI_EMERALD);
        if n != p {
            list.push(format!("{}KOKIRI_EMERALD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::KOKIRI_SWORD);
        let p = old.cbits1.contains(flags::ContextBits1::KOKIRI_SWORD);
        if n != p {
            list.push(format!("{}KOKIRI_SWORD", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::MAGIC_METER);
        let p = old.cbits1.contains(flags::ContextBits1::MAGIC_METER);
        if n != p {
            list.push(format!("{}MAGIC_METER", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::OCARINA);
        let p = old.cbits1.contains(flags::ContextBits1::OCARINA);
        if n != p {
            list.push(format!("{}OCARINA", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::SHOWED_MIDO);
        let p = old.cbits1.contains(flags::ContextBits1::SHOWED_MIDO);
        if n != p {
            list.push(format!("{}SHOWED_MIDO", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::SLINGSHOT);
        let p = old.cbits1.contains(flags::ContextBits1::SLINGSHOT);
        if n != p {
            list.push(format!("{}SLINGSHOT", if n { "+" } else { "-" }));
        }
        for (loc_id, status) in self.status.iter() {
            if *status != old.status[loc_id] {
                list.push(format!("{:?}: {}", status, loc_id));
            }
        }

        if self.visits != old.visits {
            list.push(format!("Visits: {:+}", self.visits - old.visits));
        }

        if self.skips != old.skips {
            list.push(format!("Skips: {:+}", self.skips - old.skips));
        }

        if list.is_empty() {
            String::from("NONE")
        } else {
            list.join("\n")
        }
    }
}

impl Context {
    fn local_travel_time_b(
        &self,
        movement_state: movements::MovementState,
        dest: BigSpotId,
    ) -> u32 {
        movements::local_travel_time_b(movement_state, BigSpotId::None /*self.position*/, dest)
    }

    // settings
    pub fn triforce_count(&self) -> i16 {
        self.triforce_count
    }
    pub fn set_triforce_count(&mut self, val: i16) {
        self.triforce_count = val;
    }
    pub fn logic_deku_b1_skip(&self) -> bool {
        self.cbits1
            .contains(flags::ContextBits1::LOGIC_DEKU_B1_SKIP)
    }
    pub fn set_logic_deku_b1_skip(&mut self, val: bool) {
        self.cbits1
            .set(flags::ContextBits1::LOGIC_DEKU_B1_SKIP, val);
    }
    // context
    pub fn position(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.position,
                },
            },
        }
    }
    pub fn save(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    RegionId::Deku_Tree => SpotId::Deku_Tree__Lobby__Entry,
                    _ => self.save,
                },
            },
        }
    }
    pub fn set_save(&mut self, val: SpotId) {
        self.save = val;
    }
    pub fn child(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.cbits1.contains(flags::ContextBits1::CHILD),
                },
            },
        }
    }
    pub fn set_child(&mut self, val: bool) {
        self.cbits1.set(flags::ContextBits1::CHILD, val);
    }
    pub fn tod(&self) -> enums::Tod {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.tod,
                },
            },
        }
    }
    pub fn set_tod(&mut self, val: enums::Tod) {
        self.tod = val;
    }
    pub fn rupees(&self) -> i32 {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.rupees,
                },
            },
        }
    }
    pub fn set_rupees(&mut self, val: i32) {
        self.rupees = val;
    }
    pub fn deku_tree__compass_room__ctx__torch(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH),
                },
            },
        }
    }
    pub fn set_deku_tree__compass_room__ctx__torch(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::DEKU_TREE__COMPASS_ROOM__CTX__TORCH,
            val,
        );
    }
}
