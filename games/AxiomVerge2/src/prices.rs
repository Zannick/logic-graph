//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]

use serde::{Serialize, Deserialize};
use std::fmt;
use std::ops::{Add, Mul};

#[derive(Debug, PartialEq, Eq, Copy, Clone, Default, Hash, Ord, PartialOrd, Serialize, Deserialize)]
pub enum Currency {
    #[default] Free,
    Energy(i16),
    Flasks(i8),
    Refills(i8),
}

impl analyzer::world::Id for Currency {}

impl fmt::Display for Currency {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Free => write!(f, "Free"),
            Self::Energy(i) => write!(f, "{}:{}", "Energy", i),
            Self::Flasks(i) => write!(f, "{}:{}", "Flasks", i),
            Self::Refills(i) => write!(f, "{}:{}", "Refills", i),
        }
    }
}

impl std::str::FromStr for Currency {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s == "Free" {
            return Ok(Currency::Free);
        } else if let Some(t) = s.strip_suffix(")") {
            if let Some((price, val)) = t.split_once("(") {
                match price {
                    "Energy" => return Ok(Currency::Energy(
                        i16::from_str(val).map_err(|e| format!("{}", e))?)),
                    "Flasks" => return Ok(Currency::Flasks(
                        i8::from_str(val).map_err(|e| format!("{}", e))?)),
                    "Refills" => return Ok(Currency::Refills(
                        i8::from_str(val).map_err(|e| format!("{}", e))?)),
                    _ => (),
                }
            }
        }
        Err(format!("Could not recognize as a Currency: {}", s))
    }
}

impl Add for Currency {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        match (self, other) {
            (Currency::Free, _) => other,
            (_, Currency::Free) => self,
            (Currency::Energy(s), Currency::Energy(o)) => Currency::Energy(s + o),
            (Currency::Flasks(s), Currency::Flasks(o)) => Currency::Flasks(s + o),
            (Currency::Refills(s), Currency::Refills(o)) => Currency::Refills(s + o),
            #[allow(unreachable_patterns)]
            _ => panic!("Cannot add currencies of two different types: {} + {}", self, other),
        }
    }
}

impl Mul<f32> for Currency {
    type Output = Self;
    fn mul(self, other: f32) -> Self {
        match self {
            Currency::Free => self,
            Currency::Energy(i) => Currency::Energy((i as f32 * other) as i16),
            Currency::Flasks(i) => Currency::Flasks((i as f32 * other) as i8),
            Currency::Refills(i) => Currency::Refills((i as f32 * other) as i8),
        }
    }
}