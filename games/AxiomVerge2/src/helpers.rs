//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

/// $melee (  )
/// Ice_Axe or ^mode == 'drone'
#[macro_export]
macro_rules! helper__melee {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Ice_Axe) || $ctx.mode() == enums::Mode::Drone)
    }};
}

/// $boomerang (  )
/// ^mode != 'drone' and Boomerang
#[macro_export]
macro_rules! helper__boomerang {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Boomerang))
    }};
}

/// $can_damage (  )
/// $melee or Boomerang
#[macro_export]
macro_rules! helper__can_damage {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        (helper__melee!($ctx, $world) || $ctx.has(Item::Boomerang))
    }};
}

/// $grab (  )
/// ^mode != 'drone' and Ledge_Grab
#[macro_export]
macro_rules! helper__grab {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Ledge_Grab))
    }};
}

/// $climb (  )
/// ^mode != 'drone' and Wall_Climb
#[macro_export]
macro_rules! helper__climb {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Wall_Climb))
    }};
}

/// $hook (  )
/// ^mode == 'drone' and Slingshot_Hook
#[macro_export]
macro_rules! helper__hook {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Slingshot_Hook))
    }};
}

/// $hover (  )
/// ^mode == 'drone' and Drone_Hover
#[macro_export]
macro_rules! helper__hover {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Drone_Hover))
    }};
}

/// $charge (  )
/// ^mode == 'drone' and Slingshot_Charge
#[macro_export]
macro_rules! helper__charge {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Slingshot_Charge))
    }};
}

/// $spin (  )
/// ^mode == 'drone' and Slingshot_Weapon
#[macro_export]
macro_rules! helper__spin {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Slingshot_Weapon))
    }};
}

/// $can_deploy (  )
/// Remote_Drone and ^mode != 'drone' and not Anuman
#[macro_export]
macro_rules! helper__can_deploy {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        (($ctx.has(Item::Remote_Drone) && $ctx.mode() != enums::Mode::Drone)
            && !$ctx.has(Item::Anuman))
    }};
}

/// $can_recall (  )
/// ^mode == 'drone' and not Anuman
#[macro_export]
macro_rules! helper__can_recall {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() == enums::Mode::Drone && !$ctx.has(Item::Anuman))
    }};
}

/// $shockwave (  )
/// ^mode != 'drone' and Shockwave
#[macro_export]
macro_rules! helper__shockwave {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Shockwave))
    }};
}

/// $open (  )
/// Infect
#[macro_export]
macro_rules! helper__open {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect)
    }};
}

/// $activate (  )
/// Infect
#[macro_export]
macro_rules! helper__activate {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect)
    }};
}

/// $platform (  )
/// Infect
#[macro_export]
macro_rules! helper__platform {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect)
    }};
}

/// $overheat (  )
/// Infect
#[macro_export]
macro_rules! helper__overheat {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect)
    }};
}

/// $allegiance1 (  )
/// Infect
#[macro_export]
macro_rules! helper__allegiance1 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect)
    }};
}

/// $allegiance2 (  )
/// Infect_L1
#[macro_export]
macro_rules! helper__allegiance2 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect_L1)
    }};
}

/// $unlock2 (  )
/// Infect_L1
#[macro_export]
macro_rules! helper__unlock2 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect_L1)
    }};
}

/// $unlock3 (  )
/// Infect_L2
#[macro_export]
macro_rules! helper__unlock3 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect_L2)
    }};
}

/// $unlock4 (  )
/// Infect_L3
#[macro_export]
macro_rules! helper__unlock4 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Infect_L3)
    }};
}

/// $mist2 (  )
/// Nanite_Mist and Mist_Upgrade
#[macro_export]
macro_rules! helper__mist2 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Nanite_Mist) && $ctx.has(Item::Mist_Upgrade))
    }};
}

/// $ft_main (  )
/// Fast_Travel and ^realm == 'main'
#[macro_export]
macro_rules! helper__ft_main {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Fast_Travel) && data::realm($ctx.position()) == enums::Realm::Main)
    }};
}

/// $ft_breach (  )
/// Fast_Travel and ^realm == 'breach'
#[macro_export]
macro_rules! helper__ft_breach {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Fast_Travel) && data::realm($ctx.position()) == enums::Realm::Breach)
    }};
}

/// $range1 (  )
/// Infection_Range_2 or (Infection_Range and ^mode != 'drone')
#[macro_export]
macro_rules! helper__range1 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Infection_Range_2)
            || ($ctx.has(Item::Infection_Range) && $ctx.mode() != enums::Mode::Drone))
    }};
}

/// $range2 (  )
/// Infection_Range_3 or (Infection_Range_2 and ^mode != 'drone')
#[macro_export]
macro_rules! helper__range2 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Infection_Range_3)
            || ($ctx.has(Item::Infection_Range_2) && $ctx.mode() != enums::Mode::Drone))
    }};
}

/// $range3 (  )
/// Infection_Range_3 and ^mode != 'drone'
#[macro_export]
macro_rules! helper__range3 {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Infection_Range_3) && $ctx.mode() != enums::Mode::Drone)
    }};
}

/// $more_refills (  )
/// ^refills < $count(Power_Matrix)
#[macro_export]
macro_rules! helper__more_refills {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        Into::<i32>::into($ctx.refills()) < $ctx.count(Item::Power_Matrix).into()
    }};
}

/// $max_energy (  )
/// PER Nano_Points { 3 => 450, 2 => 400, 1 => 350, _ => 300 }
#[macro_export]
macro_rules! helper__max_energy {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        match $ctx.count(Item::Nano_Points) {
            3 => 450,
            2 => 400,
            1 => 350,
            _ => 300,
        }
    }};
}

/// $bs (  )
/// boomerang_steering and $boomerang
#[macro_export]
macro_rules! helper__bs {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.boomerang_steering() && helper__boomerang!($ctx, $world))
    }};
}

/// $offset (  )
/// major_glitches and $melee
#[macro_export]
macro_rules! helper__offset {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.major_glitches() && helper__melee!($ctx, $world))
    }};
}

/// $block_clip (  )
/// minor_glitches and ^mode == 'drone'
#[macro_export]
macro_rules! helper__block_clip {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.minor_glitches() && $ctx.mode() == enums::Mode::Drone)
    }};
}

/// $block_clip_escape (  )
/// minor_glitches and $hook
#[macro_export]
macro_rules! helper__block_clip_escape {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.minor_glitches() && helper__hook!($ctx, $world))
    }};
}

/// $infinite_climb (  )
/// Anuman and Wall_Climb and Drone_Hover
#[macro_export]
macro_rules! helper__infinite_climb {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        (($ctx.has(Item::Anuman) && $ctx.has(Item::Wall_Climb)) && $ctx.has(Item::Drone_Hover))
    }};
}

/// $attract (  )
/// Breach_Attractor and (Anuman or ^mode != 'drone' or ^indra WITHIN ^position)
#[macro_export]
macro_rules! helper__attract {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        ($ctx.has(Item::Breach_Attractor)
            && (($ctx.has(Item::Anuman) || $ctx.mode() != enums::Mode::Drone)
                || $ctx.indra() == $ctx.position()))
    }};
}

/// $all_notes (  )
/// [Dear_Ernest, Researchers_Missing, Letter_from_Trace,  Heretics_Tablet, Terminal_Breakthrough_1, Companies_Layoff, Record_Losses,  Under_Siege, The_Ideal_Kiengir, Building_of_the_School, Commemorative_Speech,  Terminal_Breakthrough_2, Dangerous_Ideas, Storm_Bomb, Suspension_Bridge, Plague_of_Thoughts,  Lament_for_Fools, Family_Tragedy, Destruction_Pogrom]
#[macro_export]
macro_rules! helper__all_notes {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Dear_Ernest)
            && $ctx.has(Item::Researchers_Missing)
            && $ctx.has(Item::Letter_from_Trace)
            && $ctx.has(Item::Heretics_Tablet)
            && $ctx.has(Item::Terminal_Breakthrough_1)
            && $ctx.has(Item::Companies_Layoff)
            && $ctx.has(Item::Record_Losses)
            && $ctx.has(Item::Under_Siege)
            && $ctx.has(Item::The_Ideal_Kiengir)
            && $ctx.has(Item::Building_of_the_School)
            && $ctx.has(Item::Commemorative_Speech)
            && $ctx.has(Item::Terminal_Breakthrough_2)
            && $ctx.has(Item::Dangerous_Ideas)
            && $ctx.has(Item::Storm_Bomb)
            && $ctx.has(Item::Suspension_Bridge)
            && $ctx.has(Item::Plague_of_Thoughts)
            && $ctx.has(Item::Lament_for_Fools)
            && $ctx.has(Item::Family_Tragedy)
            && $ctx.has(Item::Destruction_Pogrom)
    }};
}

/// $all_flasks (  )
/// [Flask{13}, Big_Flask]
#[macro_export]
macro_rules! helper__all_flasks {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.count(Item::Flask) >= 13 && $ctx.has(Item::Big_Flask)
    }};
}

/// $all_health (  )
/// [Health_Node, Health_Fragment{6}]
#[macro_export]
macro_rules! helper__all_health {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Health_Node) && $ctx.count(Item::Health_Fragment) >= 6
    }};
}

/// $all_weapons (  )
/// [Boomerang, Ice_Axe, Bronze_Axe]
#[macro_export]
macro_rules! helper__all_weapons {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Boomerang) && $ctx.has(Item::Ice_Axe) && $ctx.has(Item::Bronze_Axe)
    }};
}

/// $other_items (  )
/// [Compass, Power_Matrix, Nano_Lattice_2, Eye_Ring]
#[macro_export]
macro_rules! helper__other_items {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Compass)
            && $ctx.has(Item::Power_Matrix)
            && $ctx.has(Item::Nano_Lattice_2)
            && $ctx.has(Item::Eye_Ring)
    }};
}

/// $all_urns (  )
/// [Amashilama, Ledge_Grab, Infect, Remote_Drone, Shockwave, Wall_Climb, Slingshot_Hook, Breach_Sight,  Drone_Hover, Fast_Travel, Anuman]
#[macro_export]
macro_rules! helper__all_urns {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.has(Item::Amashilama)
            && $ctx.has(Item::Ledge_Grab)
            && $ctx.has(Item::Infect)
            && $ctx.has(Item::Remote_Drone)
            && $ctx.has(Item::Shockwave)
            && $ctx.has(Item::Wall_Climb)
            && $ctx.has(Item::Slingshot_Hook)
            && $ctx.has(Item::Breach_Sight)
            && $ctx.has(Item::Drone_Hover)
            && $ctx.has(Item::Fast_Travel)
            && $ctx.has(Item::Anuman)
    }};
}

/// $save (  )
/// ^save = ^position; $refill_energy
#[macro_export]
macro_rules! helper__save {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_save($ctx.position());
        helper__refill_energy!($ctx, $world);
    }};
}

/// $refill_energy (  )
/// ^energy = $max_energy
#[macro_export]
macro_rules! helper__refill_energy {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_energy(helper__max_energy!($ctx, $world));
    }};
}

/// $deploy_drone (  )
/// ^mode = 'drone'; ^indra = ^position;
#[macro_export]
macro_rules! helper__deploy_drone {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_mode(enums::Mode::Drone);
        $ctx.set_indra($ctx.position());
    }};
}

/// $deploy_drone_and_move ( TypedVar(name='indrapos', type='SpotId') )
/// ^mode = 'drone'; ^indra = ^indrapos;
#[macro_export]
macro_rules! helper__deploy_drone_and_move {
    ($ctx:expr, $world:expr, $indrapos:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_mode(enums::Mode::Drone);
        $ctx.set_indra($indrapos);
    }};
}

/// $save_last (  )
/// IF (^last WITHIN $default) { ^last = ^position }
#[macro_export]
macro_rules! helper__save_last {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        if $ctx.last() == Default::default() {
            $ctx.set_last($ctx.position());
        }
    }};
}

/// $reset_old_area ( TypedVar(name='newpos', type='SpotId') )
/// IF (^position NOT WITHIN `Menu`     AND ^position NOT WITHIN ^prev_area     AND ^newpos NOT WITHIN $get_area(^position)) {         IF (^newpos NOT WITHIN ^prev_area) {             $reset_area(^prev_area);         };         ^prev_area = $get_area(^position); } ELSE IF (^position WITHIN `Menu > Warp Only`            AND ^last NOT WITHIN ^prev_area            AND ^newpos NOT WITHIN $get_area(^last)) {                IF (^newpos NOT WITHIN ^prev_area) {                    $reset_area(^prev_area);                };                ^prev_area = $get_area(^last);                ^last = $default; }
#[macro_export]
macro_rules! helper__reset_old_area {
    ($ctx:expr, $world:expr, $newpos:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        if (($ctx.position() != SpotId::None
            && get_region($ctx.position()) != RegionId::Menu
            && $ctx.position() != SpotId::None
            && get_area($ctx.position()) != $ctx.prev_area())
            && get_area($newpos) != get_area($ctx.position()))
        {
            if get_area($newpos) != $ctx.prev_area() {
                $ctx.reset_area($ctx.prev_area(), $world);
            }
            $ctx.set_prev_area(get_area($ctx.position()));
        } else if (($ctx.position() != SpotId::None
            && get_area($ctx.position()) == AreaId::Menu__Warp_Only
            && $ctx.last() != SpotId::None
            && get_area($ctx.last()) != $ctx.prev_area())
            && get_area($newpos) != get_area($ctx.last()))
        {
            if get_area($newpos) != $ctx.prev_area() {
                $ctx.reset_area($ctx.prev_area(), $world);
            }
            $ctx.set_prev_area(get_area($ctx.last()));
            $ctx.set_last(Default::default());
        }
    }};
}

/// $main_portal_save_update (  )
/// ^save = ^portal_default
#[macro_export]
macro_rules! helper__main_portal_save_update {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_save(data::portal_default($ctx.position()));
    }};
}

/// $breach_portal_save_update (  )
/// ^breach_save = ^portal_default
#[macro_export]
macro_rules! helper__breach_portal_save_update {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_breach_save(data::portal_default($ctx.position()));
    }};
}

/// $clear_breach_save (  )
/// ^breach_save = $default
#[macro_export]
macro_rules! helper__clear_breach_save {
    ($ctx:expr, $world:expr) => {{
        #[allow(unused_imports)]
        use $crate::items::Item;
        $ctx.set_breach_save(Default::default());
    }};
}

/// Rule $victory
#[macro_export]
macro_rules! rule__victory {
    ($ctx:expr, $world:expr) => {{
        use $crate::graph_enums::*;
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => rules::access___escape_objective($ctx, $world),
            RuleVictory::JustObjective => rules::access___objective($ctx, $world),
        }
    }};
}

/// Rule $objective
#[macro_export]
macro_rules! rule__objective {
    ($ctx:expr, $world:expr) => {{
        use $crate::graph_enums::*;
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Start => rules::access___remote_drone($ctx, $world),
            RuleObjective::AllItems => {
                rules::access___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks(
                    $ctx, $world,
                )
            }
        }
    }};
}
