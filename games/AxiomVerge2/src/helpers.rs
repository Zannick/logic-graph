//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

/// $melee (  )
/// Ice_Axe or ^mode == 'drone'
#[macro_export]
macro_rules! helper__melee {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Ice_Axe) || $ctx.mode() == enums::Mode::Drone)
    }};
}
#[macro_export]
macro_rules! hexplain__melee {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Ice_Axe);
                $edict.insert("Ice_Axe", format!("{}", h));
                (h, vec!["Ice_Axe"])
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = $ctx.mode();
                        $edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    $edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__melee {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_ice_axe();
            $ctx.has(Item::Ice_Axe)
        } || {
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v == enums::Mode::Drone
        })
    }};
}

/// $boomerang (  )
/// ^mode != 'drone' and (Boomerang or Boomerang_Upgrade)
#[macro_export]
macro_rules! helper__boomerang {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() != enums::Mode::Drone
            && ($ctx.has(Item::Boomerang) || $ctx.has(Item::Boomerang_Upgrade)))
    }};
}
#[macro_export]
macro_rules! hexplain__boomerang {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let h = $ctx.has(Item::Boomerang);
                        $edict.insert("Boomerang", format!("{}", h));
                        (h, vec!["Boomerang"])
                    };
                    if left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = $ctx.has(Item::Boomerang_Upgrade);
                            $edict.insert("Boomerang_Upgrade", format!("{}", h));
                            (h, vec!["Boomerang_Upgrade"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__boomerang {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        } && ({
            $full_obs.observe_boomerang();
            $ctx.has(Item::Boomerang)
        } || {
            $full_obs.observe_boomerang_upgrade();
            $ctx.has(Item::Boomerang_Upgrade)
        }))
    }};
}

/// $remote_boomerang (  )
/// ^mode != 'drone' and Remote_Boomerang
#[macro_export]
macro_rules! helper__remote_boomerang {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Remote_Boomerang))
    }};
}
#[macro_export]
macro_rules! hexplain__remote_boomerang {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Remote_Boomerang);
                    $edict.insert("Remote_Boomerang", format!("{}", h));
                    (h, vec!["Remote_Boomerang"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__remote_boomerang {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        } && ({
            $full_obs.observe_remote_boomerang();
            $ctx.has(Item::Remote_Boomerang)
        }))
    }};
}

/// $can_damage (  )
/// $melee or Boomerang or Boomerang_Upgrade
#[macro_export]
macro_rules! helper__can_damage {
    ($ctx:expr, $world:expr) => {{
        ((helper__melee!($ctx, $world) || $ctx.has(Item::Boomerang))
            || $ctx.has(Item::Boomerang_Upgrade))
    }};
}
#[macro_export]
macro_rules! hexplain__can_damage {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__melee!($ctx, $world, $edict);
                    $edict.insert("$melee", format!("{:?}", res));
                    refs.push("$melee");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = $ctx.has(Item::Boomerang);
                        $edict.insert("Boomerang", format!("{}", h));
                        (h, vec!["Boomerang"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Boomerang_Upgrade);
                    $edict.insert("Boomerang_Upgrade", format!("{}", h));
                    (h, vec!["Boomerang_Upgrade"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_damage {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ((hobserve__melee!($ctx, $world, $full_obs) || {
            $full_obs.observe_boomerang();
            $ctx.has(Item::Boomerang)
        }) || {
            $full_obs.observe_boomerang_upgrade();
            $ctx.has(Item::Boomerang_Upgrade)
        })
    }};
}

/// $grab (  )
/// ^mode != 'drone' and Ledge_Grab
#[macro_export]
macro_rules! helper__grab {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Ledge_Grab))
    }};
}
#[macro_export]
macro_rules! hexplain__grab {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Ledge_Grab);
                    $edict.insert("Ledge_Grab", format!("{}", h));
                    (h, vec!["Ledge_Grab"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__grab {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        } && ({
            $full_obs.observe_ledge_grab();
            $ctx.has(Item::Ledge_Grab)
        }))
    }};
}

/// $climb (  )
/// ^mode != 'drone' and Wall_Climb
#[macro_export]
macro_rules! helper__climb {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Wall_Climb))
    }};
}
#[macro_export]
macro_rules! hexplain__climb {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Wall_Climb);
                    $edict.insert("Wall_Climb", format!("{}", h));
                    (h, vec!["Wall_Climb"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__climb {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        } && ({
            $full_obs.observe_wall_climb();
            $ctx.has(Item::Wall_Climb)
        }))
    }};
}

/// $hook (  )
/// ^mode == 'drone' and Slingshot_Hook
#[macro_export]
macro_rules! helper__hook {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Slingshot_Hook))
    }};
}
#[macro_export]
macro_rules! hexplain__hook {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Slingshot_Hook);
                    $edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__hook {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v == enums::Mode::Drone
        } && ({
            $full_obs.observe_slingshot_hook();
            $ctx.has(Item::Slingshot_Hook)
        }))
    }};
}

/// $hover (  )
/// ^mode == 'drone' and Drone_Hover
#[macro_export]
macro_rules! helper__hover {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Drone_Hover))
    }};
}
#[macro_export]
macro_rules! hexplain__hover {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Drone_Hover);
                    $edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__hover {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v == enums::Mode::Drone
        } && ({
            $full_obs.observe_drone_hover();
            $ctx.has(Item::Drone_Hover)
        }))
    }};
}

/// $charge (  )
/// ^mode == 'drone' and Slingshot_Hook and Slingshot_Charge
#[macro_export]
macro_rules! helper__charge {
    ($ctx:expr, $world:expr) => {{
        (($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Slingshot_Hook))
            && $ctx.has(Item::Slingshot_Charge))
    }};
}
#[macro_export]
macro_rules! hexplain__charge {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = $ctx.mode();
                        $edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    $edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = $ctx.has(Item::Slingshot_Hook);
                        $edict.insert("Slingshot_Hook", format!("{}", h));
                        (h, vec!["Slingshot_Hook"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Slingshot_Charge);
                    $edict.insert("Slingshot_Charge", format!("{}", h));
                    (h, vec!["Slingshot_Charge"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__charge {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v == enums::Mode::Drone
        } && ({
            $full_obs.observe_slingshot_hook();
            $ctx.has(Item::Slingshot_Hook)
        })) && ({
            $full_obs.observe_slingshot_charge();
            $ctx.has(Item::Slingshot_Charge)
        }))
    }};
}

/// $spin (  )
/// ^mode == 'drone' and Slingshot_Hook and Slingshot_Weapon
#[macro_export]
macro_rules! helper__spin {
    ($ctx:expr, $world:expr) => {{
        (($ctx.mode() == enums::Mode::Drone && $ctx.has(Item::Slingshot_Hook))
            && $ctx.has(Item::Slingshot_Weapon))
    }};
}
#[macro_export]
macro_rules! hexplain__spin {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = $ctx.mode();
                        $edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    $edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = $ctx.has(Item::Slingshot_Hook);
                        $edict.insert("Slingshot_Hook", format!("{}", h));
                        (h, vec!["Slingshot_Hook"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Slingshot_Weapon);
                    $edict.insert("Slingshot_Weapon", format!("{}", h));
                    (h, vec!["Slingshot_Weapon"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__spin {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v == enums::Mode::Drone
        } && ({
            $full_obs.observe_slingshot_hook();
            $ctx.has(Item::Slingshot_Hook)
        })) && ({
            $full_obs.observe_slingshot_weapon();
            $ctx.has(Item::Slingshot_Weapon)
        }))
    }};
}

/// $can_deploy (  )
/// Remote_Drone and ^mode != 'drone' and not Anuman
#[macro_export]
macro_rules! helper__can_deploy {
    ($ctx:expr, $world:expr) => {{
        (($ctx.has(Item::Remote_Drone) && $ctx.mode() != enums::Mode::Drone)
            && !$ctx.has(Item::Anuman))
    }};
}
#[macro_export]
macro_rules! hexplain__can_deploy {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let h = $ctx.has(Item::Remote_Drone);
                    $edict.insert("Remote_Drone", format!("{}", h));
                    (h, vec!["Remote_Drone"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let mut refs = vec!["^mode"];
                        let mut left = {
                            let r = $ctx.mode();
                            $edict.insert("^mode", format!("{:?}", r));
                            (r, vec!["^mode"])
                        };
                        let right = enums::Mode::Drone;
                        $edict.insert("^mode", format!("{}", left.0));
                        refs.append(&mut left.1);
                        (left.0 != right, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Anuman);
                    $edict.insert("Anuman", format!("{}", h));
                    (!h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_deploy {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (({
            $full_obs.observe_remote_drone();
            $ctx.has(Item::Remote_Drone)
        } && ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        })) && ({
            $full_obs.observe_anuman();
            !$ctx.has(Item::Anuman)
        }))
    }};
}

/// $can_recall (  )
/// ^mode == 'drone' and not Anuman
#[macro_export]
macro_rules! helper__can_recall {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() == enums::Mode::Drone && !$ctx.has(Item::Anuman))
    }};
}
#[macro_export]
macro_rules! hexplain__can_recall {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Anuman);
                    $edict.insert("Anuman", format!("{}", h));
                    (!h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__can_recall {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v == enums::Mode::Drone
        } && ({
            $full_obs.observe_anuman();
            !$ctx.has(Item::Anuman)
        }))
    }};
}

/// $shockwave (  )
/// ^mode != 'drone' and Shockwave
#[macro_export]
macro_rules! helper__shockwave {
    ($ctx:expr, $world:expr) => {{
        ($ctx.mode() != enums::Mode::Drone && $ctx.has(Item::Shockwave))
    }};
}
#[macro_export]
macro_rules! hexplain__shockwave {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = $ctx.mode();
                    $edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                $edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Shockwave);
                    $edict.insert("Shockwave", format!("{}", h));
                    (h, vec!["Shockwave"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__shockwave {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        } && ({
            $full_obs.observe_shockwave();
            $ctx.has(Item::Shockwave)
        }))
    }};
}

/// $open (  )
/// Infect
#[macro_export]
macro_rules! helper__open {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__open {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__open {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $activate (  )
/// Infect
#[macro_export]
macro_rules! helper__activate {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__activate {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__activate {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $platform (  )
/// Infect
#[macro_export]
macro_rules! helper__platform {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__platform {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__platform {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $overheat (  )
/// Infect
#[macro_export]
macro_rules! helper__overheat {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__overheat {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__overheat {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $slow (  )
/// Infect
#[macro_export]
macro_rules! helper__slow {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__slow {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__slow {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $sync (  )
/// Infect
#[macro_export]
macro_rules! helper__sync {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__sync {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__sync {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $allegiance1 (  )
/// Infect
#[macro_export]
macro_rules! helper__allegiance1 {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect)
    }};
}
#[macro_export]
macro_rules! hexplain__allegiance1 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect);
            $edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__allegiance1 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }
    }};
}

/// $allegiance2 (  )
/// Infect_L1
#[macro_export]
macro_rules! helper__allegiance2 {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect_L1)
    }};
}
#[macro_export]
macro_rules! hexplain__allegiance2 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect_L1);
            $edict.insert("Infect_L1", format!("{}", h));
            (h, vec!["Infect_L1"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__allegiance2 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect_l1();
            $ctx.has(Item::Infect_L1)
        }
    }};
}

/// $unlock2 (  )
/// Infect_L1
#[macro_export]
macro_rules! helper__unlock2 {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect_L1)
    }};
}
#[macro_export]
macro_rules! hexplain__unlock2 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect_L1);
            $edict.insert("Infect_L1", format!("{}", h));
            (h, vec!["Infect_L1"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__unlock2 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect_l1();
            $ctx.has(Item::Infect_L1)
        }
    }};
}

/// $unlock3 (  )
/// Infect_L2
#[macro_export]
macro_rules! helper__unlock3 {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect_L2)
    }};
}
#[macro_export]
macro_rules! hexplain__unlock3 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect_L2);
            $edict.insert("Infect_L2", format!("{}", h));
            (h, vec!["Infect_L2"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__unlock3 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect_l2();
            $ctx.has(Item::Infect_L2)
        }
    }};
}

/// $unlock4 (  )
/// Infect_L3
#[macro_export]
macro_rules! helper__unlock4 {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Infect_L3)
    }};
}
#[macro_export]
macro_rules! hexplain__unlock4 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let h = $ctx.has(Item::Infect_L3);
            $edict.insert("Infect_L3", format!("{}", h));
            (h, vec!["Infect_L3"])
        }
    }};
}
#[macro_export]
macro_rules! hobserve__unlock4 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_infect_l3();
            $ctx.has(Item::Infect_L3)
        }
    }};
}

/// $mist2 (  )
/// Nanite_Mist and Mist_Upgrade
#[macro_export]
macro_rules! helper__mist2 {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Nanite_Mist) && $ctx.has(Item::Mist_Upgrade))
    }};
}
#[macro_export]
macro_rules! hexplain__mist2 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Nanite_Mist);
                $edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Mist_Upgrade);
                    $edict.insert("Mist_Upgrade", format!("{}", h));
                    (h, vec!["Mist_Upgrade"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__mist2 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_nanite_mist();
            $ctx.has(Item::Nanite_Mist)
        } && ({
            $full_obs.observe_mist_upgrade();
            $ctx.has(Item::Mist_Upgrade)
        }))
    }};
}

/// $ft_main (  )
/// Fast_Travel and ^realm == 'main'
#[macro_export]
macro_rules! helper__ft_main {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Fast_Travel) && data::realm($ctx.position()) == enums::Realm::Main)
    }};
}
#[macro_export]
macro_rules! hexplain__ft_main {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Fast_Travel);
                $edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^realm"];
                    let mut left = {
                        let r = data::realm($ctx.position());
                        $edict.insert("^realm", format!("{:?}", r));
                        (r, vec!["^realm"])
                    };
                    let right = enums::Realm::Main;
                    $edict.insert("^realm", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__ft_main {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_fast_travel();
            $ctx.has(Item::Fast_Travel)
        } && ({
            let v = data::realm($ctx.position());
            v == enums::Realm::Main
        }))
    }};
}

/// $ft_breach (  )
/// Fast_Travel and ^realm == 'breach'
#[macro_export]
macro_rules! helper__ft_breach {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Fast_Travel) && data::realm($ctx.position()) == enums::Realm::Breach)
    }};
}
#[macro_export]
macro_rules! hexplain__ft_breach {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Fast_Travel);
                $edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^realm"];
                    let mut left = {
                        let r = data::realm($ctx.position());
                        $edict.insert("^realm", format!("{:?}", r));
                        (r, vec!["^realm"])
                    };
                    let right = enums::Realm::Breach;
                    $edict.insert("^realm", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__ft_breach {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_fast_travel();
            $ctx.has(Item::Fast_Travel)
        } && ({
            let v = data::realm($ctx.position());
            v == enums::Realm::Breach
        }))
    }};
}

/// $range1 (  )
/// Infection_Range_2 or (Infection_Range and ^mode != 'drone')
#[macro_export]
macro_rules! helper__range1 {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Infection_Range_2)
            || ($ctx.has(Item::Infection_Range) && $ctx.mode() != enums::Mode::Drone))
    }};
}
#[macro_export]
macro_rules! hexplain__range1 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Infection_Range_2);
                $edict.insert("Infection_Range_2", format!("{}", h));
                (h, vec!["Infection_Range_2"])
            };
            if left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let h = $ctx.has(Item::Infection_Range);
                        $edict.insert("Infection_Range", format!("{}", h));
                        (h, vec!["Infection_Range"])
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let mut refs = vec!["^mode"];
                            let mut left = {
                                let r = $ctx.mode();
                                $edict.insert("^mode", format!("{:?}", r));
                                (r, vec!["^mode"])
                            };
                            let right = enums::Mode::Drone;
                            $edict.insert("^mode", format!("{}", left.0));
                            refs.append(&mut left.1);
                            (left.0 != right, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__range1 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_infection_range_2();
            $ctx.has(Item::Infection_Range_2)
        } || ({
            $full_obs.observe_infection_range();
            $ctx.has(Item::Infection_Range)
        } && ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        })))
    }};
}

/// $range2 (  )
/// Infection_Range_3 or (Infection_Range_2 and ^mode != 'drone')
#[macro_export]
macro_rules! helper__range2 {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Infection_Range_3)
            || ($ctx.has(Item::Infection_Range_2) && $ctx.mode() != enums::Mode::Drone))
    }};
}
#[macro_export]
macro_rules! hexplain__range2 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Infection_Range_3);
                $edict.insert("Infection_Range_3", format!("{}", h));
                (h, vec!["Infection_Range_3"])
            };
            if left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let h = $ctx.has(Item::Infection_Range_2);
                        $edict.insert("Infection_Range_2", format!("{}", h));
                        (h, vec!["Infection_Range_2"])
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let mut refs = vec!["^mode"];
                            let mut left = {
                                let r = $ctx.mode();
                                $edict.insert("^mode", format!("{:?}", r));
                                (r, vec!["^mode"])
                            };
                            let right = enums::Mode::Drone;
                            $edict.insert("^mode", format!("{}", left.0));
                            refs.append(&mut left.1);
                            (left.0 != right, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__range2 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_infection_range_3();
            $ctx.has(Item::Infection_Range_3)
        } || ({
            $full_obs.observe_infection_range_2();
            $ctx.has(Item::Infection_Range_2)
        } && ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        })))
    }};
}

/// $range3 (  )
/// Infection_Range_3 and ^mode != 'drone'
#[macro_export]
macro_rules! helper__range3 {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Infection_Range_3) && $ctx.mode() != enums::Mode::Drone)
    }};
}
#[macro_export]
macro_rules! hexplain__range3 {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Infection_Range_3);
                $edict.insert("Infection_Range_3", format!("{}", h));
                (h, vec!["Infection_Range_3"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = $ctx.mode();
                        $edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    $edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 != right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__range3 {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_infection_range_3();
            $ctx.has(Item::Infection_Range_3)
        } && ({
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        }))
    }};
}

/// $more_refills (  )
/// ^refills < $count(Power_Matrix)
#[macro_export]
macro_rules! helper__more_refills {
    ($ctx:expr, $world:expr) => {{
        Into::<i32>::into($ctx.refills()) < $ctx.count(Item::Power_Matrix).into()
    }};
}
#[macro_export]
macro_rules! hexplain__more_refills {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = vec!["^refills", "$count(Power_Matrix)"];
            let mut left = {
                let r = $ctx.refills();
                $edict.insert("^refills", format!("{:?}", r));
                (r, vec!["^refills"])
            };
            let mut right = {
                let f = $ctx.count(Item::Power_Matrix);
                $edict.insert("$count(Power_Matrix)", format!("{}", f));
                (f, vec!["$count(Power_Matrix)"])
            };
            $edict.insert("^refills", format!("{:?}", left.0));
            $edict.insert("$count(Power_Matrix)", format!("{:?}", right.0));
            refs.append(&mut left.1);
            refs.append(&mut right.1);
            (Into::<i32>::into(left.0) < right.0.into(), refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__more_refills {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            let n: i32 = $ctx.count(Item::Power_Matrix).into();
            $full_obs.observe_refills(IntegerObservation::Ge(n as i8));
            i32::from($ctx.refills()) < n
        }
    }};
}

/// $max_energy (  )
/// PER Nano_Points { 3 => 450, 2 => 400, 1 => 350, _ => 300 }
#[macro_export]
macro_rules! helper__max_energy {
    ($ctx:expr, $world:expr) => {{
        match $ctx.count(Item::Nano_Points) {
            3 => 450,
            2 => 400,
            1 => 350,
            _ => 300,
        }
    }};
}
#[macro_export]
macro_rules! hexplain__max_energy {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = vec!["Nano_Points count"];
            let ct = $ctx.count(Item::Nano_Points);
            $edict.insert("Nano_Points count", format!("{}", ct));
            let mut m = match ct {
                3 => (450, vec![]),
                2 => (400, vec![]),
                1 => (350, vec![]),
                _ => (300, vec![]),
            };
            refs.append(&mut m.1);
            m
        }
    }};
}
#[macro_export]
macro_rules! hobserve__max_energy {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        {
            $full_obs.observe_nano_points();
            match $ctx.count(Item::Nano_Points) {
                3 => 450,
                2 => 400,
                1 => 350,
                _ => 300,
            }
        }
    }};
}

/// $bs (  )
/// boomerang_steering and $boomerang
#[macro_export]
macro_rules! helper__bs {
    ($ctx:expr, $world:expr) => {{
        ($world.boomerang_steering && helper__boomerang!($ctx, $world))
    }};
}
#[macro_export]
macro_rules! hexplain__bs {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let s = $world.boomerang_steering;
                $edict.insert("boomerang_steering", format!("{}", s));
                (s, vec!["boomerang_steering"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__boomerang!($ctx, $world, $edict);
                    $edict.insert("$boomerang", format!("{:?}", res));
                    refs.push("$boomerang");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__bs {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ($world.boomerang_steering && (hobserve__boomerang!($ctx, $world, $full_obs)))
    }};
}

/// $offset (  )
/// major_glitches and $melee
#[macro_export]
macro_rules! helper__offset {
    ($ctx:expr, $world:expr) => {{
        ($world.major_glitches && helper__melee!($ctx, $world))
    }};
}
#[macro_export]
macro_rules! hexplain__offset {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let s = $world.major_glitches;
                $edict.insert("major_glitches", format!("{}", s));
                (s, vec!["major_glitches"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__melee!($ctx, $world, $edict);
                    $edict.insert("$melee", format!("{:?}", res));
                    refs.push("$melee");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__offset {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ($world.major_glitches && (hobserve__melee!($ctx, $world, $full_obs)))
    }};
}

/// $block_clip (  )
/// minor_glitches and ^mode == 'drone'
#[macro_export]
macro_rules! helper__block_clip {
    ($ctx:expr, $world:expr) => {{
        ($world.minor_glitches && $ctx.mode() == enums::Mode::Drone)
    }};
}
#[macro_export]
macro_rules! hexplain__block_clip {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let s = $world.minor_glitches;
                $edict.insert("minor_glitches", format!("{}", s));
                (s, vec!["minor_glitches"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = $ctx.mode();
                        $edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    $edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__block_clip {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ($world.minor_glitches
            && ({
                let v = {
                    $full_obs.observe_mode();
                    $ctx.mode()
                };
                v == enums::Mode::Drone
            }))
    }};
}

/// $block_clip_escape (  )
/// minor_glitches and $hook
#[macro_export]
macro_rules! helper__block_clip_escape {
    ($ctx:expr, $world:expr) => {{
        ($world.minor_glitches && helper__hook!($ctx, $world))
    }};
}
#[macro_export]
macro_rules! hexplain__block_clip_escape {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let s = $world.minor_glitches;
                $edict.insert("minor_glitches", format!("{}", s));
                (s, vec!["minor_glitches"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!($ctx, $world, $edict);
                    $edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__block_clip_escape {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ($world.minor_glitches && (hobserve__hook!($ctx, $world, $full_obs)))
    }};
}

/// $infinite_climb (  )
/// Anuman and Wall_Climb and Drone_Hover
#[macro_export]
macro_rules! helper__infinite_climb {
    ($ctx:expr, $world:expr) => {{
        (($ctx.has(Item::Anuman) && $ctx.has(Item::Wall_Climb)) && $ctx.has(Item::Drone_Hover))
    }};
}
#[macro_export]
macro_rules! hexplain__infinite_climb {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let mut left = {
                    let h = $ctx.has(Item::Anuman);
                    $edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = $ctx.has(Item::Wall_Climb);
                        $edict.insert("Wall_Climb", format!("{}", h));
                        (h, vec!["Wall_Climb"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = $ctx.has(Item::Drone_Hover);
                    $edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__infinite_climb {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        (({
            $full_obs.observe_anuman();
            $ctx.has(Item::Anuman)
        } && ({
            $full_obs.observe_wall_climb();
            $ctx.has(Item::Wall_Climb)
        })) && ({
            $full_obs.observe_drone_hover();
            $ctx.has(Item::Drone_Hover)
        }))
    }};
}

/// $attract (  )
/// Breach_Attractor and (Anuman or ^mode != 'drone' or ^indra WITHIN ^position)
#[macro_export]
macro_rules! helper__attract {
    ($ctx:expr, $world:expr) => {{
        ($ctx.has(Item::Breach_Attractor)
            && (($ctx.has(Item::Anuman) || $ctx.mode() != enums::Mode::Drone)
                || $ctx.indra() == $ctx.position()))
    }};
}
#[macro_export]
macro_rules! hexplain__attract {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut left = {
                let h = $ctx.has(Item::Breach_Attractor);
                $edict.insert("Breach_Attractor", format!("{}", h));
                (h, vec!["Breach_Attractor"])
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let mut left = {
                            let h = $ctx.has(Item::Anuman);
                            $edict.insert("Anuman", format!("{}", h));
                            (h, vec!["Anuman"])
                        };
                        if left.0 {
                            left
                        } else {
                            let mut right = {
                                let mut refs = vec!["^mode"];
                                let mut left = {
                                    let r = $ctx.mode();
                                    $edict.insert("^mode", format!("{:?}", r));
                                    (r, vec!["^mode"])
                                };
                                let right = enums::Mode::Drone;
                                $edict.insert("^mode", format!("{}", left.0));
                                refs.append(&mut left.1);
                                (left.0 != right, refs)
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    };
                    if left.0 {
                        left
                    } else {
                        let mut right = {
                            let mut r0 = {
                                let r = $ctx.indra();
                                $edict.insert("^indra", format!("{:?}", r));
                                (r, vec!["^indra"])
                            };
                            let mut r1 = {
                                let r = $ctx.position();
                                $edict.insert("^position", format!("{:?}", r));
                                (r, vec!["^position"])
                            };
                            r0.1.append(&mut r1.1);
                            (r0.0 == r1.0, r0.1)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        }
    }};
}
#[macro_export]
macro_rules! hobserve__attract {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_breach_attractor();
            $ctx.has(Item::Breach_Attractor)
        } && (({
            $full_obs.observe_anuman();
            $ctx.has(Item::Anuman)
        } || {
            let v = {
                $full_obs.observe_mode();
                $ctx.mode()
            };
            v != enums::Mode::Drone
        }) || {
            $full_obs.observe_indra();
            $ctx.indra()
        } == {
            $full_obs.observe_position();
            $ctx.position()
        }))
    }};
}

/// $all_notes (  )
/// [Dear_Ernest, Researchers_Missing, Letter_from_Trace,  Heretics_Tablet, Terminal_Breakthrough_1, Companies_Layoff, Record_Losses,  Under_Siege, The_Ideal_Kiengir, Building_of_the_School, Commemorative_Speech,  Terminal_Breakthrough_2, Dangerous_Ideas, Storm_Bomb, Suspension_Bridge, Plague_of_Thoughts,  Lament_for_Fools, Family_Tragedy, Destruction_Pogrom, The_Eternal_Arm]
#[macro_export]
macro_rules! helper__all_notes {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Dear_Ernest)
            && $ctx.has(Item::Researchers_Missing)
            && $ctx.has(Item::Letter_from_Trace)
            && $ctx.has(Item::Heretics_Tablet)
            && $ctx.has(Item::Terminal_Breakthrough_1)
            && $ctx.has(Item::Companies_Layoff)
            && $ctx.has(Item::Record_Losses)
            && $ctx.has(Item::Under_Siege)
            && $ctx.has(Item::The_Ideal_Kiengir)
            && $ctx.has(Item::Building_of_the_School)
            && $ctx.has(Item::Commemorative_Speech)
            && $ctx.has(Item::Terminal_Breakthrough_2)
            && $ctx.has(Item::Dangerous_Ideas)
            && $ctx.has(Item::Storm_Bomb)
            && $ctx.has(Item::Suspension_Bridge)
            && $ctx.has(Item::Plague_of_Thoughts)
            && $ctx.has(Item::Lament_for_Fools)
            && $ctx.has(Item::Family_Tragedy)
            && $ctx.has(Item::Destruction_Pogrom)
            && $ctx.has(Item::The_Eternal_Arm)
    }};
}
#[macro_export]
macro_rules! hexplain__all_notes {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = Vec::new();
            let mut h = {
                let h = $ctx.has(Item::Dear_Ernest);
                $edict.insert("Dear_Ernest", format!("{}", h));
                (h, vec!["Dear_Ernest"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Researchers_Missing);
                $edict.insert("Researchers_Missing", format!("{}", h));
                (h, vec!["Researchers_Missing"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Letter_from_Trace);
                $edict.insert("Letter_from_Trace", format!("{}", h));
                (h, vec!["Letter_from_Trace"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Heretics_Tablet);
                $edict.insert("Heretics_Tablet", format!("{}", h));
                (h, vec!["Heretics_Tablet"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Terminal_Breakthrough_1);
                $edict.insert("Terminal_Breakthrough_1", format!("{}", h));
                (h, vec!["Terminal_Breakthrough_1"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Companies_Layoff);
                $edict.insert("Companies_Layoff", format!("{}", h));
                (h, vec!["Companies_Layoff"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Record_Losses);
                $edict.insert("Record_Losses", format!("{}", h));
                (h, vec!["Record_Losses"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Under_Siege);
                $edict.insert("Under_Siege", format!("{}", h));
                (h, vec!["Under_Siege"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::The_Ideal_Kiengir);
                $edict.insert("The_Ideal_Kiengir", format!("{}", h));
                (h, vec!["The_Ideal_Kiengir"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Building_of_the_School);
                $edict.insert("Building_of_the_School", format!("{}", h));
                (h, vec!["Building_of_the_School"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Commemorative_Speech);
                $edict.insert("Commemorative_Speech", format!("{}", h));
                (h, vec!["Commemorative_Speech"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Terminal_Breakthrough_2);
                $edict.insert("Terminal_Breakthrough_2", format!("{}", h));
                (h, vec!["Terminal_Breakthrough_2"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Dangerous_Ideas);
                $edict.insert("Dangerous_Ideas", format!("{}", h));
                (h, vec!["Dangerous_Ideas"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Storm_Bomb);
                $edict.insert("Storm_Bomb", format!("{}", h));
                (h, vec!["Storm_Bomb"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Suspension_Bridge);
                $edict.insert("Suspension_Bridge", format!("{}", h));
                (h, vec!["Suspension_Bridge"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Plague_of_Thoughts);
                $edict.insert("Plague_of_Thoughts", format!("{}", h));
                (h, vec!["Plague_of_Thoughts"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Lament_for_Fools);
                $edict.insert("Lament_for_Fools", format!("{}", h));
                (h, vec!["Lament_for_Fools"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Family_Tragedy);
                $edict.insert("Family_Tragedy", format!("{}", h));
                (h, vec!["Family_Tragedy"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Destruction_Pogrom);
                $edict.insert("Destruction_Pogrom", format!("{}", h));
                (h, vec!["Destruction_Pogrom"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::The_Eternal_Arm);
                $edict.insert("The_Eternal_Arm", format!("{}", h));
                (h, vec!["The_Eternal_Arm"])
            };
            refs.append(&mut h.1);
            (h.0, refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__all_notes {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_dear_ernest();
            $ctx.has(Item::Dear_Ernest)
        }) && ({
            $full_obs.observe_researchers_missing();
            $ctx.has(Item::Researchers_Missing)
        }) && ({
            $full_obs.observe_letter_from_trace();
            $ctx.has(Item::Letter_from_Trace)
        }) && ({
            $full_obs.observe_heretics_tablet();
            $ctx.has(Item::Heretics_Tablet)
        }) && ({
            $full_obs.observe_terminal_breakthrough_1();
            $ctx.has(Item::Terminal_Breakthrough_1)
        }) && ({
            $full_obs.observe_companies_layoff();
            $ctx.has(Item::Companies_Layoff)
        }) && ({
            $full_obs.observe_record_losses();
            $ctx.has(Item::Record_Losses)
        }) && ({
            $full_obs.observe_under_siege();
            $ctx.has(Item::Under_Siege)
        }) && ({
            $full_obs.observe_the_ideal_kiengir();
            $ctx.has(Item::The_Ideal_Kiengir)
        }) && ({
            $full_obs.observe_building_of_the_school();
            $ctx.has(Item::Building_of_the_School)
        }) && ({
            $full_obs.observe_commemorative_speech();
            $ctx.has(Item::Commemorative_Speech)
        }) && ({
            $full_obs.observe_terminal_breakthrough_2();
            $ctx.has(Item::Terminal_Breakthrough_2)
        }) && ({
            $full_obs.observe_dangerous_ideas();
            $ctx.has(Item::Dangerous_Ideas)
        }) && ({
            $full_obs.observe_storm_bomb();
            $ctx.has(Item::Storm_Bomb)
        }) && ({
            $full_obs.observe_suspension_bridge();
            $ctx.has(Item::Suspension_Bridge)
        }) && ({
            $full_obs.observe_plague_of_thoughts();
            $ctx.has(Item::Plague_of_Thoughts)
        }) && ({
            $full_obs.observe_lament_for_fools();
            $ctx.has(Item::Lament_for_Fools)
        }) && ({
            $full_obs.observe_family_tragedy();
            $ctx.has(Item::Family_Tragedy)
        }) && ({
            $full_obs.observe_destruction_pogrom();
            $ctx.has(Item::Destruction_Pogrom)
        }) && ({
            $full_obs.observe_the_eternal_arm();
            $ctx.has(Item::The_Eternal_Arm)
        })
    }};
}

/// $all_flasks (  )
/// [Flask{14}, Big_Flask]
#[macro_export]
macro_rules! helper__all_flasks {
    ($ctx:expr, $world:expr) => {{
        $ctx.count(Item::Flask) >= 14 && $ctx.has(Item::Big_Flask)
    }};
}
#[macro_export]
macro_rules! hexplain__all_flasks {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = Vec::new();
            let mut h = {
                let ct = $ctx.count(Item::Flask);
                $edict.insert("Flask count", format!("{}", ct));
                (ct >= 14, vec!["Flask count"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Big_Flask);
                $edict.insert("Big_Flask", format!("{}", h));
                (h, vec!["Big_Flask"])
            };
            refs.append(&mut h.1);
            (h.0, refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__all_flasks {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_flask(IntegerObservation::Ge(14));
            $ctx.count(Item::Flask) >= 14
        }) && ({
            $full_obs.observe_big_flask();
            $ctx.has(Item::Big_Flask)
        })
    }};
}

/// $all_health (  )
/// [Health_Node, Health_Fragment{6}]
#[macro_export]
macro_rules! helper__all_health {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Health_Node) && $ctx.count(Item::Health_Fragment) >= 6
    }};
}
#[macro_export]
macro_rules! hexplain__all_health {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = Vec::new();
            let mut h = {
                let h = $ctx.has(Item::Health_Node);
                $edict.insert("Health_Node", format!("{}", h));
                (h, vec!["Health_Node"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let ct = $ctx.count(Item::Health_Fragment);
                $edict.insert("Health_Fragment count", format!("{}", ct));
                (ct >= 6, vec!["Health_Fragment count"])
            };
            refs.append(&mut h.1);
            (h.0, refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__all_health {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_health_node();
            $ctx.has(Item::Health_Node)
        }) && ({
            $full_obs.observe_health_fragment(IntegerObservation::Ge(6));
            $ctx.count(Item::Health_Fragment) >= 6
        })
    }};
}

/// $all_weapons (  )
/// [Boomerang, Ice_Axe, Bronze_Axe]
#[macro_export]
macro_rules! helper__all_weapons {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Boomerang) && $ctx.has(Item::Ice_Axe) && $ctx.has(Item::Bronze_Axe)
    }};
}
#[macro_export]
macro_rules! hexplain__all_weapons {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = Vec::new();
            let mut h = {
                let h = $ctx.has(Item::Boomerang);
                $edict.insert("Boomerang", format!("{}", h));
                (h, vec!["Boomerang"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Ice_Axe);
                $edict.insert("Ice_Axe", format!("{}", h));
                (h, vec!["Ice_Axe"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Bronze_Axe);
                $edict.insert("Bronze_Axe", format!("{}", h));
                (h, vec!["Bronze_Axe"])
            };
            refs.append(&mut h.1);
            (h.0, refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__all_weapons {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_boomerang();
            $ctx.has(Item::Boomerang)
        }) && ({
            $full_obs.observe_ice_axe();
            $ctx.has(Item::Ice_Axe)
        }) && ({
            $full_obs.observe_bronze_axe();
            $ctx.has(Item::Bronze_Axe)
        })
    }};
}

/// $other_items (  )
/// [Compass, Power_Matrix, Nano_Lattice_2, Eye_Ring]
#[macro_export]
macro_rules! helper__other_items {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Compass)
            && $ctx.has(Item::Power_Matrix)
            && $ctx.has(Item::Nano_Lattice_2)
            && $ctx.has(Item::Eye_Ring)
    }};
}
#[macro_export]
macro_rules! hexplain__other_items {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = Vec::new();
            let mut h = {
                let h = $ctx.has(Item::Compass);
                $edict.insert("Compass", format!("{}", h));
                (h, vec!["Compass"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Power_Matrix);
                $edict.insert("Power_Matrix", format!("{}", h));
                (h, vec!["Power_Matrix"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Nano_Lattice_2);
                $edict.insert("Nano_Lattice_2", format!("{}", h));
                (h, vec!["Nano_Lattice_2"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Eye_Ring);
                $edict.insert("Eye_Ring", format!("{}", h));
                (h, vec!["Eye_Ring"])
            };
            refs.append(&mut h.1);
            (h.0, refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__other_items {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_compass();
            $ctx.has(Item::Compass)
        }) && ({
            $full_obs.observe_power_matrix();
            $ctx.has(Item::Power_Matrix)
        }) && ({
            $full_obs.observe_nano_lattice_2();
            $ctx.has(Item::Nano_Lattice_2)
        }) && ({
            $full_obs.observe_eye_ring();
            $ctx.has(Item::Eye_Ring)
        })
    }};
}

/// $all_urns (  )
/// [Amashilama, Ledge_Grab, Infect, Remote_Drone, Shockwave, Wall_Climb, Slingshot_Hook, Breach_Sight,  Drone_Hover, Fast_Travel, Anuman]
#[macro_export]
macro_rules! helper__all_urns {
    ($ctx:expr, $world:expr) => {{
        $ctx.has(Item::Amashilama)
            && $ctx.has(Item::Ledge_Grab)
            && $ctx.has(Item::Infect)
            && $ctx.has(Item::Remote_Drone)
            && $ctx.has(Item::Shockwave)
            && $ctx.has(Item::Wall_Climb)
            && $ctx.has(Item::Slingshot_Hook)
            && $ctx.has(Item::Breach_Sight)
            && $ctx.has(Item::Drone_Hover)
            && $ctx.has(Item::Fast_Travel)
            && $ctx.has(Item::Anuman)
    }};
}
#[macro_export]
macro_rules! hexplain__all_urns {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        {
            let mut refs = Vec::new();
            let mut h = {
                let h = $ctx.has(Item::Amashilama);
                $edict.insert("Amashilama", format!("{}", h));
                (h, vec!["Amashilama"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Ledge_Grab);
                $edict.insert("Ledge_Grab", format!("{}", h));
                (h, vec!["Ledge_Grab"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Infect);
                $edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Remote_Drone);
                $edict.insert("Remote_Drone", format!("{}", h));
                (h, vec!["Remote_Drone"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Shockwave);
                $edict.insert("Shockwave", format!("{}", h));
                (h, vec!["Shockwave"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Wall_Climb);
                $edict.insert("Wall_Climb", format!("{}", h));
                (h, vec!["Wall_Climb"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Slingshot_Hook);
                $edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Breach_Sight);
                $edict.insert("Breach_Sight", format!("{}", h));
                (h, vec!["Breach_Sight"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Drone_Hover);
                $edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Fast_Travel);
                $edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            refs.append(&mut h.1);
            if !h.0 {
                return (false, refs);
            };
            let mut h = {
                let h = $ctx.has(Item::Anuman);
                $edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            refs.append(&mut h.1);
            (h.0, refs)
        }
    }};
}
#[macro_export]
macro_rules! hobserve__all_urns {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        ({
            $full_obs.observe_amashilama();
            $ctx.has(Item::Amashilama)
        }) && ({
            $full_obs.observe_ledge_grab();
            $ctx.has(Item::Ledge_Grab)
        }) && ({
            $full_obs.observe_infect();
            $ctx.has(Item::Infect)
        }) && ({
            $full_obs.observe_remote_drone();
            $ctx.has(Item::Remote_Drone)
        }) && ({
            $full_obs.observe_shockwave();
            $ctx.has(Item::Shockwave)
        }) && ({
            $full_obs.observe_wall_climb();
            $ctx.has(Item::Wall_Climb)
        }) && ({
            $full_obs.observe_slingshot_hook();
            $ctx.has(Item::Slingshot_Hook)
        }) && ({
            $full_obs.observe_breach_sight();
            $ctx.has(Item::Breach_Sight)
        }) && ({
            $full_obs.observe_drone_hover();
            $ctx.has(Item::Drone_Hover)
        }) && ({
            $full_obs.observe_fast_travel();
            $ctx.has(Item::Fast_Travel)
        }) && ({
            $full_obs.observe_anuman();
            $ctx.has(Item::Anuman)
        })
    }};
}

/// $save (  )
/// IF (^realm == 'breach') { ^breach_save = ^position; } ELSE { ^save = ^position; }; $refill_energy
#[macro_export]
macro_rules! helper__save {
    ($ctx:expr, $world:expr) => {{
        if data::realm($ctx.position()) == enums::Realm::Breach {
            $ctx.set_breach_save($ctx.position());
        } else {
            $ctx.set_save($ctx.position());
        }
        helper__refill_energy!($ctx, $world);
    }};
}
#[macro_export]
macro_rules! hobserve__save {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        if {
            let v = data::realm($ctx.position());
            v == enums::Realm::Breach
        } {
        } else {
        }
        hobserve__refill_energy!($ctx, $world, $full_obs);
    }};
}

/// $breach_save (  )
/// ^breach_save = ^position; $refill_energy
#[macro_export]
macro_rules! helper__breach_save {
    ($ctx:expr, $world:expr) => {{
        $ctx.set_breach_save($ctx.position());
        helper__refill_energy!($ctx, $world);
    }};
}
#[macro_export]
macro_rules! hobserve__breach_save {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        hobserve__refill_energy!($ctx, $world, $full_obs);
    }};
}

/// $refill_energy (  )
/// ^energy = $max_energy
#[macro_export]
macro_rules! helper__refill_energy {
    ($ctx:expr, $world:expr) => {{
        $ctx.set_energy(helper__max_energy!($ctx, $world));
    }};
}
#[macro_export]
macro_rules! hobserve__refill_energy {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{}};
}

/// $deploy_drone (  )
/// ^mode = 'drone'; ^indra = ^position;
#[macro_export]
macro_rules! helper__deploy_drone {
    ($ctx:expr, $world:expr) => {{
        $ctx.set_mode(enums::Mode::Drone);
        $ctx.set_indra($ctx.position());
    }};
}
#[macro_export]
macro_rules! hobserve__deploy_drone {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{}};
}

/// $deploy_drone_and_move ( TypedVar(name='indrapos', type='SpotId') )
/// ^mode = 'drone'; ^indra = ^indrapos;
#[macro_export]
macro_rules! helper__deploy_drone_and_move {
    ($ctx:expr, $world:expr, $indrapos:expr) => {{
        $ctx.set_mode(enums::Mode::Drone);
        $ctx.set_indra($indrapos);
    }};
}
#[macro_export]
macro_rules! hobserve__deploy_drone_and_move {
    ($ctx:expr, $world:expr, $indrapos:expr, $full_obs:expr) => {{}};
}

/// $save_last (  )
/// IF (^last WITHIN $default) { ^last = ^position }
#[macro_export]
macro_rules! helper__save_last {
    ($ctx:expr, $world:expr) => {{
        if $ctx.last() == Default::default() {
            $ctx.set_last($ctx.position());
        }
    }};
}
#[macro_export]
macro_rules! hobserve__save_last {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        if {
            $full_obs.observe_last();
            $ctx.last()
        } == Default::default()
        {}
    }};
}

/// $reset_old_area ( TypedVar(name='newpos', type='SpotId') )
/// IF (^position NOT WITHIN `Menu`     AND ^position NOT WITHIN ^prev_area     AND ^newpos NOT WITHIN $get_area(^position)) {         IF (^newpos NOT WITHIN ^prev_area) {             $reset_area(^prev_area);             ^prev_portal = ^portal;             ^portal = @^newpos^portal_start;         } ELSE {             SWAP ^portal, ^prev_portal;         };         ^prev_area = $get_area(^position); } ELSE IF (^position WITHIN `Menu > Warp Only`            AND ^last NOT WITHIN ^prev_area            AND ^newpos NOT WITHIN $get_area(^last)) {               IF (^newpos NOT WITHIN ^prev_area) {                   $reset_area(^prev_area);                   ^prev_portal = ^portal;                   ^portal = @^newpos^portal_start;               } ELSE {                   SWAP ^portal, ^prev_portal;               };               ^prev_area = $get_area(^last);               ^last = $default; }
#[macro_export]
macro_rules! helper__reset_old_area {
    ($ctx:expr, $world:expr, $newpos:expr) => {{
        if (($ctx.position() != SpotId::None
            && get_region($ctx.position()) != RegionId::Menu
            && $ctx.position() != SpotId::None
            && get_area($ctx.position()) != $ctx.prev_area())
            && get_area($newpos) != get_area($ctx.position()))
        {
            if get_area($newpos) != $ctx.prev_area() {
                $ctx.reset_area($ctx.prev_area(), $world);
                $ctx.set_prev_portal($ctx.portal());
                $ctx.set_portal(data::portal_start($newpos));
            } else {
                std::mem::swap(&mut $ctx.portal, &mut $ctx.prev_portal);
            }
            $ctx.set_prev_area(get_area($ctx.position()));
        } else if (($ctx.position() != SpotId::None
            && get_area($ctx.position()) == AreaId::Menu__Warp_Only
            && $ctx.last() != SpotId::None
            && get_area($ctx.last()) != $ctx.prev_area())
            && get_area($newpos) != get_area($ctx.last()))
        {
            if get_area($newpos) != $ctx.prev_area() {
                $ctx.reset_area($ctx.prev_area(), $world);
                $ctx.set_prev_portal($ctx.portal());
                $ctx.set_portal(data::portal_start($newpos));
            } else {
                std::mem::swap(&mut $ctx.portal, &mut $ctx.prev_portal);
            }
            $ctx.set_prev_area(get_area($ctx.last()));
            $ctx.set_last(Default::default());
        }
    }};
}
#[macro_export]
macro_rules! hobserve__reset_old_area {
    ($ctx:expr, $world:expr, $newpos:expr, $full_obs:expr) => {{
        if (({
            $full_obs.observe_position();
            $ctx.position()
        } != SpotId::None
            && get_region({
                $full_obs.observe_position();
                $ctx.position()
            }) != RegionId::Menu
            && ({
                $full_obs.observe_position();
                $ctx.position()
            } != SpotId::None
                && get_area({
                    $full_obs.observe_position();
                    $ctx.position()
                }) != {
                    $full_obs.observe_prev_area();
                    $ctx.prev_area()
                }))
            && (get_area($newpos) != get_area($ctx.position())))
        {
            if get_area($newpos) != {
                $full_obs.observe_prev_area();
                $ctx.prev_area()
            } {
            } else {
                $full_obs.swap_portal__prev_portal()
            }
            {
                let _set = get_area({
                    $full_obs.observe_position();
                    $ctx.position()
                });
            }
        } else if (({
            $full_obs.observe_position();
            $ctx.position()
        } != SpotId::None
            && get_area({
                $full_obs.observe_position();
                $ctx.position()
            }) == AreaId::Menu__Warp_Only
            && ({
                $full_obs.observe_last();
                $ctx.last()
            } != SpotId::None
                && get_area({
                    $full_obs.observe_last();
                    $ctx.last()
                }) != {
                    $full_obs.observe_prev_area();
                    $ctx.prev_area()
                }))
            && (get_area($newpos) != get_area($ctx.last())))
        {
            if get_area($newpos) != {
                $full_obs.observe_prev_area();
                $ctx.prev_area()
            } {
            } else {
                $full_obs.swap_portal__prev_portal()
            }
            {
                let _set = get_area({
                    $full_obs.observe_last();
                    $ctx.last()
                });
            }
        }
    }};
}

/// $main_portal_save_update (  )
/// ^save = ^portal_default
#[macro_export]
macro_rules! helper__main_portal_save_update {
    ($ctx:expr, $world:expr) => {{
        $ctx.set_save(data::portal_default($ctx.position()));
    }};
}
#[macro_export]
macro_rules! hobserve__main_portal_save_update {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{}};
}

/// $breach_portal_save_update (  )
/// ^breach_save = ^portal_default
#[macro_export]
macro_rules! helper__breach_portal_save_update {
    ($ctx:expr, $world:expr) => {{
        $ctx.set_breach_save(data::portal_default($ctx.position()));
    }};
}
#[macro_export]
macro_rules! hobserve__breach_portal_save_update {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{}};
}

/// $clear_breach_save (  )
/// ^breach_save = $default
#[macro_export]
macro_rules! helper__clear_breach_save {
    ($ctx:expr, $world:expr) => {{
        $ctx.set_breach_save(Default::default());
    }};
}
#[macro_export]
macro_rules! hobserve__clear_breach_save {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{}};
}

/// Rule $victory
#[macro_export]
macro_rules! rule__victory {
    ($ctx:expr, $world:expr) => {{
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => rules::access___escape_objective($ctx, $world),
            RuleVictory::JustObjective => rules::access___objective($ctx, $world),
            RuleVictory::Bench => rules::access___remote_drone_flask__6($ctx, $world),
        }
    }};
}
#[macro_export]
macro_rules! rexplain__victory {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => rules::explain___escape_objective($ctx, $world, $edict),
            RuleVictory::JustObjective => rules::explain___objective($ctx, $world, $edict),
            RuleVictory::Bench => rules::explain___remote_drone_flask__6($ctx, $world, $edict),
        }
    }};
}
#[macro_export]
macro_rules! robserve__victory {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        use $crate::rules;
        match $world.rule_victory {
            RuleVictory::Default => {
                rules::observe_access___escape_objective($ctx, $world, $full_obs)
            }
            RuleVictory::JustObjective => {
                rules::observe_access___objective($ctx, $world, $full_obs)
            }
            RuleVictory::Bench => {
                rules::observe_access___remote_drone_flask__6($ctx, $world, $full_obs)
            }
        }
    }};
}

/// Rule $objective
#[macro_export]
macro_rules! rule__objective {
    ($ctx:expr, $world:expr) => {{
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Start => {
                rules::access___remote_drone($ctx, $world)
            }
            RuleObjective::AllItems => {
                rules::access___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks_hammond_auth($ctx, $world)
            }
        }
    }};
}
#[macro_export]
macro_rules! rexplain__objective {
    ($ctx:expr, $world:expr, $edict:expr) => {{
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Start => {
                rules::explain___remote_drone($ctx, $world, $edict)
            }
            RuleObjective::AllItems => {
                rules::explain___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks_hammond_auth($ctx, $world, $edict)
            }
        }
    }};
}
#[macro_export]
macro_rules! robserve__objective {
    ($ctx:expr, $world:expr, $full_obs:expr) => {{
        use $crate::rules;
        match $world.rule_objective {
            RuleObjective::Start => {
                rules::observe_access___remote_drone($ctx, $world, $full_obs)
            }
            RuleObjective::AllItems => {
                rules::observe_access___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks_hammond_auth($ctx, $world, $full_obs)
            }
        }
    }};
}
