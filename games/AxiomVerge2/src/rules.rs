//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::*;
use crate::graph::{self, *};
use crate::graph_enums::*;
use crate::items::Item;
use crate::observe::*;
use crate::prices::Currency;
use crate::*;
use analyzer::context::Ctx;
use analyzer::matchertrie::observe::IntegerObservation;
use analyzer::world::{self, World};
use rustc_hash::FxHashMap;

pub fn access_default(_ctx: &Context, _world: &graph::World) -> bool {
    true
}

pub fn access___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // [$all_urns, $all_weapons, $other_items, $all_notes, $all_health, $all_flasks]
    helper__all_urns!(ctx, world)
        && helper__all_weapons!(ctx, world)
        && helper__other_items!(ctx, world)
        && helper__all_notes!(ctx, world)
        && helper__all_health!(ctx, world)
        && helper__all_flasks!(ctx, world)
}
pub fn access___escape_objective(ctx: &Context, world: &graph::World) -> bool {
    // [Escape, $objective]
    ctx.has(Item::Escape) && rule__objective!(ctx, world)
}
pub fn access___objective(ctx: &Context, world: &graph::World) -> bool {
    // [$objective]
    rule__objective!(ctx, world)
}
pub fn access___remote_drone(ctx: &Context, world: &graph::World) -> bool {
    // [Remote_Drone]
    ctx.has(Item::Remote_Drone)
}
pub fn access___remote_drone_flask__6(ctx: &Context, world: &graph::World) -> bool {
    // [Remote_Drone, Flask{6}]
    ctx.has(Item::Remote_Drone) && ctx.count(Item::Flask) >= 6
}
pub fn access_activate(ctx: &Context, world: &graph::World) -> bool {
    // $activate
    helper__activate!(ctx, world)
}
pub fn access_amagi__main_area__carving__ex__secret_outcropping_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo and ($grab or $climb)
    (ctx.amagi__main_area__ctx__combo()
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_amagi__main_area__carving__ex__secret_outcropping_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo and $hook
    (ctx.amagi__main_area__ctx__combo() && helper__hook!(ctx, world))
}
pub fn access_amagi__main_area__carving__key_combo__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_combo
    !ctx.amagi__main_area__ctx__combo()
}
pub fn access_amagi_dragon_eye_passage(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_Dragon_Eye_Passage
    ctx.has(Item::Amagi_Dragon_Eye_Passage)
}
pub fn access_amagi_stronghold_boulder_1(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_Stronghold_Boulder_1
    ctx.has(Item::Amagi_Stronghold_Boulder_1)
}
pub fn access_amagi_stronghold_boulder_1_and_underwater_movement_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Amagi_Stronghold_Boulder_1 and Underwater_Movement and ($grab or $climb)
    ((ctx.has(Item::Amagi_Stronghold_Boulder_1) && ctx.has(Item::Underwater_Movement))
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_amagi_stronghold_boulder_2(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_Stronghold_Boulder_2
    ctx.has(Item::Amagi_Stronghold_Boulder_2)
}
pub fn access_amagi_stronghold_boulder_2_and_grab(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_Stronghold_Boulder_2 and $grab
    (ctx.has(Item::Amagi_Stronghold_Boulder_2) && helper__grab!(ctx, world))
}
pub fn access_amagi_stronghold_wall_1(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_Stronghold_Wall_1
    ctx.has(Item::Amagi_Stronghold_Wall_1)
}
pub fn access_amagi_stronghold_wall_2(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_Stronghold_Wall_2
    ctx.has(Item::Amagi_Stronghold_Wall_2)
}
pub fn access_amagi_west_lake_surface_wall(ctx: &Context, world: &graph::World) -> bool {
    // Amagi_West_Lake_Surface_Wall
    ctx.has(Item::Amagi_West_Lake_Surface_Wall)
}
pub fn access_annuna__east_bridge__tower_east_ledge__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_combo
    !ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_east_ledge__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_mid_air_west__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_secret__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_combo
    !ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_secret__ex__tower_east_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_secret__ex__tower_mid_air_east_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_secret__ex__tower_mid_air_west_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_secret__ex__tower_peak_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo and $grab
    (ctx.annuna__east_bridge__ctx__combo() && helper__grab!(ctx, world))
}
pub fn access_annuna__east_bridge__tower_secret__ex__tower_peak_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo and $hook
    (ctx.annuna__east_bridge__ctx__combo() && helper__hook!(ctx, world))
}
pub fn access_annuna__east_bridge__tower_secret__ex__tower_west_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_west_ledge__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_combo
    !ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__tower_west_ledge__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__west_climb__cache__ex__switch_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.annuna__west_climb__ctx__door_opened()
}
pub fn access_annuna__west_climb__switch_ledge__ex__cache_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.annuna__west_climb__ctx__door_opened()
}
pub fn access_annuna__west_climb__switch_ledge__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $unlock4 and not ^_door_opened
    (helper__unlock4!(ctx, world) && !ctx.annuna__west_climb__ctx__door_opened())
}
pub fn access_annuna_east_bridge_gate(ctx: &Context, world: &graph::World) -> bool {
    // Annuna_East_Bridge_Gate
    ctx.has(Item::Annuna_East_Bridge_Gate)
}
pub fn access_annuna_mirror_match_switch(ctx: &Context, world: &graph::World) -> bool {
    // Annuna_Mirror_Match_Switch
    ctx.has(Item::Annuna_Mirror_Match_Switch)
}
pub fn access_anuman(ctx: &Context, world: &graph::World) -> bool {
    // Anuman
    ctx.has(Item::Anuman)
}
pub fn access_anuman_and_grab(ctx: &Context, world: &graph::World) -> bool {
    // Anuman and $grab
    (ctx.has(Item::Anuman) && helper__grab!(ctx, world))
}
pub fn access_anunna_vertical_room_gate(ctx: &Context, world: &graph::World) -> bool {
    // Anunna_Vertical_Room_Gate
    ctx.has(Item::Anunna_Vertical_Room_Gate)
}
pub fn access_apocalypse_bomb(ctx: &Context, world: &graph::World) -> bool {
    // Apocalypse_Bomb
    ctx.has(Item::Apocalypse_Bomb)
}
pub fn access_block_clip_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Left
    (helper__block_clip!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Left))
}
pub fn access_block_clip_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Right
    (helper__block_clip!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Right))
}
pub fn access_block_clip_escape_and_not_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $block_clip_escape and not Uhrum_Annuna_Corridor_Block
    (helper__block_clip_escape!(ctx, world) && !ctx.has(Item::Uhrum_Annuna_Corridor_Block))
}
pub fn access_boomerang(ctx: &Context, world: &graph::World) -> bool {
    // $boomerang
    helper__boomerang!(ctx, world)
}
pub fn access_boomerang1(ctx: &Context, world: &graph::World) -> bool {
    // Boomerang
    ctx.has(Item::Boomerang)
}
pub fn access_boomerang2(ctx: &Context, world: &graph::World) -> bool {
    // Boomerang
    ctx.has(Item::Boomerang)
}
pub fn access_boomerang3(ctx: &Context, world: &graph::World) -> bool {
    // Boomerang
    ctx.has(Item::Boomerang)
}
pub fn access_boomerang4(ctx: &Context, world: &graph::World) -> bool {
    // Boomerang
    ctx.has(Item::Boomerang)
}
pub fn access_boomerang5(ctx: &Context, world: &graph::World) -> bool {
    // Boomerang
    ctx.has(Item::Boomerang)
}
pub fn access_bs(ctx: &Context, world: &graph::World) -> bool {
    // $bs
    helper__bs!(ctx, world)
}
pub fn access_can_damage(ctx: &Context, world: &graph::World) -> bool {
    // $can_damage
    helper__can_damage!(ctx, world)
}
pub fn access_can_deploy(ctx: &Context, world: &graph::World) -> bool {
    // $can_deploy
    helper__can_deploy!(ctx, world)
}
pub fn access_can_deploy_and_drone_hover(ctx: &Context, world: &graph::World) -> bool {
    // $can_deploy and Drone_Hover
    (helper__can_deploy!(ctx, world) && ctx.has(Item::Drone_Hover))
}
pub fn access_can_deploy_and_slingshot_hook(ctx: &Context, world: &graph::World) -> bool {
    // $can_deploy and Slingshot_Hook
    (helper__can_deploy!(ctx, world) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_can_deploy_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $can_deploy and Slingshot_Hook and Drone_Hover
    ((helper__can_deploy!(ctx, world) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_charge(ctx: &Context, world: &graph::World) -> bool {
    // $charge
    helper__charge!(ctx, world)
}
pub fn access_climb(ctx: &Context, world: &graph::World) -> bool {
    // $climb
    helper__climb!(ctx, world)
}
pub fn access_climb_and_annuna_east_bridge_gate(ctx: &Context, world: &graph::World) -> bool {
    // $climb and Annuna_East_Bridge_Gate
    (helper__climb!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_climb_and_can_deploy_and_hover_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $climb and $can_deploy and Hover and Slingshot_Hook
    (((helper__climb!(ctx, world) && helper__can_deploy!(ctx, world)) && ctx.has(Item::Hover))
        && ctx.has(Item::Slingshot_Hook))
}
pub fn access_climb_and_grab(ctx: &Context, world: &graph::World) -> bool {
    // $climb and $grab
    (helper__climb!(ctx, world) && helper__grab!(ctx, world))
}
pub fn access_climb_and_grab_and_anuman(ctx: &Context, world: &graph::World) -> bool {
    // $climb and $grab and Anuman
    ((helper__climb!(ctx, world) && helper__grab!(ctx, world)) && ctx.has(Item::Anuman))
}
pub fn access_climb_or_hook(ctx: &Context, world: &graph::World) -> bool {
    // $climb or $hook
    (helper__climb!(ctx, world) || helper__hook!(ctx, world))
}
pub fn access_defeat_mus_a_m20(ctx: &Context, world: &graph::World) -> bool {
    // Defeat_MUS_A_M20
    ctx.has(Item::Defeat_MUS_A_M20)
}
pub fn access_drone_melee_damage(ctx: &Context, world: &graph::World) -> bool {
    // Drone_Melee_Damage
    ctx.has(Item::Drone_Melee_Damage)
}
pub fn access_drone_melee_damage_2(ctx: &Context, world: &graph::World) -> bool {
    // Drone_Melee_Damage_2
    ctx.has(Item::Drone_Melee_Damage_2)
}
pub fn access_drone_melee_speed(ctx: &Context, world: &graph::World) -> bool {
    // Drone_Melee_Speed
    ctx.has(Item::Drone_Melee_Speed)
}
pub fn access_drone_melee_speed_2(ctx: &Context, world: &graph::World) -> bool {
    // Drone_Melee_Speed_2
    ctx.has(Item::Drone_Melee_Speed_2)
}
pub fn access_ebih__base_camp__left_platform__move_left_platform__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $activate and not ^_left_platform_moved
    (helper__activate!(ctx, world) && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_ebih__base_camp__left_platform_moved__reset_left_platform__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $activate and ^_left_platform_moved
    (helper__activate!(ctx, world) && ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_ebih__base_camp__top_platform__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hover and not ^_left_platform_moved
    (helper__hover!(ctx, world) && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_ebih__base_camp__top_platform__ex__left_platform_moved_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_left_platform_moved
    ctx.ebih__base_camp__ctx__left_platform_moved()
}
pub fn access_ebih__base_camp__west_11__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $platform and $hook and not ^_left_platform_moved
    ((helper__platform!(ctx, world) && helper__hook!(ctx, world))
        && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_ebih__base_camp__west_11__ex__left_platform_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hover and not ^_left_platform_moved
    (helper__hover!(ctx, world) && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_ebih__drone_room__pit_left__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and ^_platform_moved
    (ctx.has(Item::Infect) && ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_ebih__drone_room__pit_left__activate_lift_but_get_off_early__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and ^_platform_moved
    (ctx.has(Item::Infect) && ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_ebih__drone_room__portal_exit__activate_platform__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and not ^_platform_moved
    (ctx.has(Item::Infect) && !ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_ebih__drone_room__portal_exit__ex__moving_platform_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and not ^_platform_moved
    (ctx.has(Item::Infect) && !ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_ebih__drone_room__portal_exit__ex__moving_platform_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hook and not ^_platform_moved
    (helper__hook!(ctx, world) && !ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_ebih__ebih_east__dispenser__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and ^_platform2_moved and ($grab or $hook)
    ((ctx.has(Item::Infect) && ctx.ebih__ebih_east__ctx__platform2_moved())
        && (helper__grab!(ctx, world) || helper__hook!(ctx, world)))
}
pub fn access_ebih__ebih_east__dispenser__ex__lower_moving_platform_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $grab and not ^_platform2_moved
    (helper__grab!(ctx, world) && !ctx.ebih__ebih_east__ctx__platform2_moved())
}
pub fn access_ebih__ebih_east__dispenser__ex__lower_moving_platform_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hook and not ^_platform2_moved
    (helper__hook!(ctx, world) && !ctx.ebih__ebih_east__ctx__platform2_moved())
}
pub fn access_ebih__ebih_east__lower_moving_platform__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and $grab and not ^_platform2_moved
    ((ctx.has(Item::Infect) && helper__grab!(ctx, world))
        && !ctx.ebih__ebih_east__ctx__platform2_moved())
}
pub fn access_ebih__ebih_east__lower_moving_platform__activate_ride__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and not ^_platform2_moved
    (ctx.has(Item::Infect) && !ctx.ebih__ebih_east__ctx__platform2_moved())
}
pub fn access_ebih__ebih_east__moving_platform__activate_ride__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Infect and $grab and not ^_platform1_moved
    ((ctx.has(Item::Infect) && helper__grab!(ctx, world))
        && !ctx.ebih__ebih_east__ctx__platform1_moved())
}
pub fn access_ebih__ebih_west__above_door__ex__below_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__ebih_west__ctx__door_open()
}
pub fn access_ebih__ebih_west__above_door__ex__refill_station_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_door_open or $grab
    (!ctx.ebih__ebih_west__ctx__door_open() || helper__grab!(ctx, world))
}
pub fn access_ebih__ebih_west__above_door__ex__small_gap_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_door_open
    !ctx.ebih__ebih_west__ctx__door_open()
}
pub fn access_ebih__ebih_west__below_door__ex__above_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $grab and ^_door_open
    (helper__grab!(ctx, world) && ctx.ebih__ebih_west__ctx__door_open())
}
pub fn access_ebih__ebih_west__below_door__ex__refill_station_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hook and ^_door_open
    (helper__hook!(ctx, world) && ctx.ebih__ebih_west__ctx__door_open())
}
pub fn access_ebih__grid_25_10_12__door__ex__door_left_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__grid_25_10_12__ctx__door_open()
}
pub fn access_ebih__grid_25_10_12__door__ex__east_11_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__grid_25_10_12__ctx__door_open()
}
pub fn access_ebih__grid_25_10_12__door_left__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__grid_25_10_12__ctx__door_open()
}
pub fn access_ebih__grid_25_10_12__east_11__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__grid_25_10_12__ctx__door_open()
}
pub fn access_ebih__vertical_interchange__door__ex__door_east_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__vertical_interchange__ctx__door_open()
}
pub fn access_ebih__vertical_interchange__door__ex__door_west_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__vertical_interchange__ctx__door_open()
}
pub fn access_ebih__vertical_interchange__door_east__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__vertical_interchange__ctx__door_open()
}
pub fn access_ebih__vertical_interchange__door_west__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.ebih__vertical_interchange__ctx__door_open()
}
pub fn access_ebih__vertical_interchange__west_13__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $open and not ^_door_open
    (helper__open!(ctx, world) && !ctx.ebih__vertical_interchange__ctx__door_open())
}
pub fn access_ebih__waterfall__west_door__ex__west_door_left_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_west_door_open
    ctx.ebih__waterfall__ctx__west_door_open()
}
pub fn access_ebih__waterfall__west_door__ex__west_door_right_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_west_door_open
    ctx.ebih__waterfall__ctx__west_door_open()
}
pub fn access_ebih__waterfall__west_door_left__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_west_door_open
    ctx.ebih__waterfall__ctx__west_door_open()
}
pub fn access_ebih__waterfall__west_door_right__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_west_door_open
    ctx.ebih__waterfall__ctx__west_door_open()
}
pub fn access_ebih_alu(ctx: &Context, world: &graph::World) -> bool {
    // Ebih_Alu
    ctx.has(Item::Ebih_Alu)
}
pub fn access_ebih_interchange_block(ctx: &Context, world: &graph::World) -> bool {
    // Ebih_Interchange_Block
    ctx.has(Item::Ebih_Interchange_Block)
}
pub fn access_ebih_interchange_gate(ctx: &Context, world: &graph::World) -> bool {
    // Ebih_Interchange_Gate
    ctx.has(Item::Ebih_Interchange_Gate)
}
pub fn access_ebih_interchange_gate_and_ebih_interchange_block_and_grab(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $grab
    ((ctx.has(Item::Ebih_Interchange_Gate) && ctx.has(Item::Ebih_Interchange_Block))
        && helper__grab!(ctx, world))
}
pub fn access_ebih_interchange_gate_and_ebih_interchange_block_and_hook(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $hook
    ((ctx.has(Item::Ebih_Interchange_Gate) && ctx.has(Item::Ebih_Interchange_Block))
        && helper__hook!(ctx, world))
}
pub fn access_ebih_interchange_gate_and_not_ebih_interchange_block_and_grab(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $grab
    ((ctx.has(Item::Ebih_Interchange_Gate) && !ctx.has(Item::Ebih_Interchange_Block))
        && helper__grab!(ctx, world))
}
pub fn access_ebih_interchange_gate_and_not_ebih_interchange_block_and_hook(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $hook
    ((ctx.has(Item::Ebih_Interchange_Gate) && !ctx.has(Item::Ebih_Interchange_Block))
        && helper__hook!(ctx, world))
}
pub fn access_ebih_wasteland_door(ctx: &Context, world: &graph::World) -> bool {
    // Ebih_Wasteland_Door
    ctx.has(Item::Ebih_Wasteland_Door)
}
pub fn access_ebih_waterfall_wall(ctx: &Context, world: &graph::World) -> bool {
    // Ebih_Waterfall_Wall
    ctx.has(Item::Ebih_Waterfall_Wall)
}
pub fn access_ebih_west_block(ctx: &Context, world: &graph::World) -> bool {
    // Ebih_West_Block
    ctx.has(Item::Ebih_West_Block)
}
pub fn access_fast_travel(ctx: &Context, world: &graph::World) -> bool {
    // Fast_Travel
    ctx.has(Item::Fast_Travel)
}
pub fn access_ft_main_and___map_spot_within_menu_gt_kiengir_map(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $ft_main and (^map_spot WITHIN `Menu > Kiengir Map`)
    (helper__ft_main!(ctx, world)
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Kiengir_Map))
}
pub fn access_giguna__carnelian__door__ex__switch_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__carnelian__ctx__door_opened()
}
pub fn access_giguna__carnelian__door__ex__vault_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__carnelian__ctx__door_opened()
}
pub fn access_giguna__carnelian__lower_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_lower_susar
    !ctx.giguna__carnelian__ctx__lower_susar()
}
pub fn access_giguna__carnelian__lower_susar__ex__rock_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_lower_susar
    ctx.giguna__carnelian__ctx__lower_susar()
}
pub fn access_giguna__carnelian__lower_susar__ex__west_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_lower_susar and $grab
    (ctx.giguna__carnelian__ctx__lower_susar() && helper__grab!(ctx, world))
}
pub fn access_giguna__carnelian__lower_susar__ex__west_ledge_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_lower_susar and $hook
    (ctx.giguna__carnelian__ctx__lower_susar() && helper__hook!(ctx, world))
}
pub fn access_giguna__carnelian__lower_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!ctx.giguna__carnelian__ctx__lower_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__carnelian__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__carnelian__ctx__door_opened()
}
pub fn access_giguna__carnelian__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $unlock3 and not ^_door_opened
    (helper__unlock3!(ctx, world) && !ctx.giguna__carnelian__ctx__door_opened())
}
pub fn access_giguna__carnelian__upper_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_upper_susar
    !ctx.giguna__carnelian__ctx__upper_susar()
}
pub fn access_giguna__carnelian__upper_susar__ex__east_cliff_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__carnelian__ctx__upper_susar()
}
pub fn access_giguna__carnelian__upper_susar__ex__middle_platforms_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__carnelian__ctx__upper_susar()
}
pub fn access_giguna__carnelian__upper_susar__ex__upper_path_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__carnelian__ctx__upper_susar()
}
pub fn access_giguna__carnelian__upper_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!ctx.giguna__carnelian__ctx__upper_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__carnelian__vault__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__carnelian__ctx__door_opened()
}
pub fn access_giguna__clouds__platform_start__hack_and_get_off_early__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_platform_and_portal and $activate
    (!ctx.giguna__clouds__ctx__platform_and_portal() && helper__activate!(ctx, world))
}
pub fn access_giguna__clouds__platform_start__hack_and_ride_to_portal__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_platform_and_portal and $activate and $attract and Breach_Sight and Remote_Drone
    ((((!ctx.giguna__clouds__ctx__platform_and_portal() && helper__activate!(ctx, world))
        && helper__attract!(ctx, world))
        && ctx.has(Item::Breach_Sight))
        && ctx.has(Item::Remote_Drone))
}
pub fn access_giguna__clouds__platform_start__hack_deploy_ride_to_portal__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_platform_and_portal and $activate and $can_deploy and $attract and Breach_Sight
    ((((!ctx.giguna__clouds__ctx__platform_and_portal() && helper__activate!(ctx, world))
        && helper__can_deploy!(ctx, world))
        && helper__attract!(ctx, world))
        && ctx.has(Item::Breach_Sight))
}
pub fn access_giguna__clouds__platform_stop__ex__flipside_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_platform_and_portal and ^mode == 'drone'
    (ctx.giguna__clouds__ctx__platform_and_portal() && ctx.mode() == enums::Mode::Drone)
}
pub fn access_giguna__east_caverns__arc_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    ((ctx.mode() == enums::Mode::Drone && ctx.has(Item::Mist_Upgrade))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__arc_passage__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and ^_combo_entered
    (ctx.mode() == enums::Mode::Drone && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__arc_passage__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hook and ^_combo_entered
    (helper__hook!(ctx, world) && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__lower_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_lower_susar
    !ctx.giguna__east_caverns__ctx__lower_susar()
}
pub fn access_giguna__east_caverns__lower_susar__ex__east_grass_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_lower_susar
    ctx.giguna__east_caverns__ctx__lower_susar()
}
pub fn access_giguna__east_caverns__lower_susar__ex__under_lower_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_lower_susar
    ctx.giguna__east_caverns__ctx__lower_susar()
}
pub fn access_giguna__east_caverns__lower_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__lower_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__east_caverns__mid_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_mid_susar
    !ctx.giguna__east_caverns__ctx__mid_susar()
}
pub fn access_giguna__east_caverns__mid_susar__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $grab and ^_mid_susar
    (helper__grab!(ctx, world) && ctx.giguna__east_caverns__ctx__mid_susar())
}
pub fn access_giguna__east_caverns__mid_susar__ex__middle_ledge_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hook and ^_mid_susar
    (helper__hook!(ctx, world) && ctx.giguna__east_caverns__ctx__mid_susar())
}
pub fn access_giguna__east_caverns__mid_susar__ex__middle_rock_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_mid_susar
    ctx.giguna__east_caverns__ctx__mid_susar()
}
pub fn access_giguna__east_caverns__mid_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_mid_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__mid_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__east_caverns__middle_rock__ex__hidden_passage_east_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and ^_combo_entered
    (ctx.mode() == enums::Mode::Drone && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__midwest_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hover and $hook and ^_combo_entered
    ((helper__hover!(ctx, world) && helper__hook!(ctx, world))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__midwest_ledge__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    ((ctx.mode() == enums::Mode::Drone && ctx.has(Item::Mist_Upgrade))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__statues_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $hover and $hook and ^_combo_entered
    ((helper__hover!(ctx, world) && helper__hook!(ctx, world))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__statues_ledge__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    ((ctx.mode() == enums::Mode::Drone && ctx.has(Item::Mist_Upgrade))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_giguna__east_caverns__statues_ledge__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_door_opened and $unlock2 and $range1
    ((!ctx.giguna__east_caverns__ctx__door_opened() && helper__unlock2!(ctx, world))
        && helper__range1!(ctx, world))
}
pub fn access_giguna__east_caverns__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__east_caverns__ctx__door_opened()
}
pub fn access_giguna__east_caverns__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_door_opened and $unlock2
    (!ctx.giguna__east_caverns__ctx__door_opened() && helper__unlock2!(ctx, world))
}
pub fn access_giguna__east_caverns__upper_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_upper_susar
    !ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar__ex__top_past_susar_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar__ex__upper_floor_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar__ex__upper_platforms_right_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar_jump_from_east__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_upper_susar
    !ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar_jump_from_east__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar_jump_from_east__ex__midwest_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar_jump_from_east__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__upper_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__east_caverns__upper_susar_mid_jump__ex__top_past_susar_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__east_caverns__upper_susar_mid_jump__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__upper_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__east_caverns__west_14__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_combo_entered
    !ctx.giguna__east_caverns__ctx__combo_entered()
}
pub fn access_giguna__east_caverns__west_16__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__east_caverns__ctx__door_opened()
}
pub fn access_giguna__east_caverns__west_16__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_door_opened and $open and $range2
    ((!ctx.giguna__east_caverns__ctx__door_opened() && helper__open!(ctx, world))
        && helper__range2!(ctx, world))
}
pub fn access_giguna__gateway__door__ex__block_left_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__gateway__ctx__door_opened()
}
pub fn access_giguna__gateway__door__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__gateway__ctx__door_opened()
}
pub fn access_giguna__gateway__door__ex__passage_entry_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__gateway__ctx__door_opened()
}
pub fn access_giguna__gateway__passage_entry__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__gateway__ctx__door_opened()
}
pub fn access_giguna__giguna_base__below_gate__ex__kari_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open and $grab and $climb
    ((ctx.giguna__giguna_base__ctx__door_open() && helper__grab!(ctx, world))
        && helper__climb!(ctx, world))
}
pub fn access_giguna__giguna_base__below_gate__ex__kari_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open and $hook
    (ctx.giguna__giguna_base__ctx__door_open() && helper__hook!(ctx, world))
}
pub fn access_giguna__giguna_base__below_gate__ex__middle_platform_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open and $grab and $climb
    ((ctx.giguna__giguna_base__ctx__door_open() && helper__grab!(ctx, world))
        && helper__climb!(ctx, world))
}
pub fn access_giguna__giguna_base__below_gate__ex__middle_platform_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open and $hook
    (ctx.giguna__giguna_base__ctx__door_open() && helper__hook!(ctx, world))
}
pub fn access_giguna__giguna_base__kari__ex__below_gate_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.giguna__giguna_base__ctx__door_open()
}
pub fn access_giguna__giguna_base__middle_platform__ex__below_gate_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_open
    ctx.giguna__giguna_base__ctx__door_open()
}
pub fn access_giguna__giguna_northeast__right_column__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__giguna_northeast__ctx__door_opened()
}
pub fn access_giguna__giguna_northeast__right_column__open_door_from_afar__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $unlock3 and Infection_Range_3 and not ^_door_opened
    ((helper__unlock3!(ctx, world) && ctx.has(Item::Infection_Range_3))
        && !ctx.giguna__giguna_northeast__ctx__door_opened())
}
pub fn access_giguna__giguna_northeast__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened and ($grab or $hook)
    (ctx.giguna__giguna_northeast__ctx__door_opened()
        && (helper__grab!(ctx, world) || helper__hook!(ctx, world)))
}
pub fn access_giguna__giguna_northeast__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $unlock3 and not ^_door_opened
    (helper__unlock3!(ctx, world) && !ctx.giguna__giguna_northeast__ctx__door_opened())
}
pub fn access_giguna__giguna_northeast__vault__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna__giguna_northeast__ctx__door_opened()
}
pub fn access_giguna__giguna_northeast__vault__ex__door_2__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened and $hook
    (ctx.giguna__giguna_northeast__ctx__door_opened() && helper__hook!(ctx, world))
}
pub fn access_giguna__ruins_top__east_7__ex__east_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__east_door__ex__east_7_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__east_door__ex__portal_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__entryway__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__portal__ex__east_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__west_7__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__west_door__ex__entryway_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_top__west_door__ex__west_7_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__ruins_west__lower_ledge__destroy_kishib__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_kishib_handled and $shockwave
    (!ctx.giguna__ruins_west__ctx__kishib_handled() && helper__shockwave!(ctx, world))
}
pub fn access_giguna__ruins_west__lower_ledge__ex__upper_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $grab and ^_kishib_handled
    (helper__grab!(ctx, world) && ctx.giguna__ruins_west__ctx__kishib_handled())
}
pub fn access_giguna__ruins_west__lower_ledge__hack_kishib__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_kishib_handled and $allegiance1
    (!ctx.giguna__ruins_west__ctx__kishib_handled() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna__west_caverns__east_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_east_susar
    !ctx.giguna__west_caverns__ctx__east_susar()
}
pub fn access_giguna__west_caverns__east_susar__ex__east_12_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_east_susar
    ctx.giguna__west_caverns__ctx__east_susar()
}
pub fn access_giguna__west_caverns__east_susar__ex__tunnel_fork_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_east_susar
    ctx.giguna__west_caverns__ctx__east_susar()
}
pub fn access_giguna__west_caverns__east_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_east_susar and $allegiance1
    (!ctx.giguna__west_caverns__ctx__east_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_giguna_boulder(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Boulder
    ctx.has(Item::Giguna_Boulder)
}
pub fn access_giguna_breach__sw_save__side_door__ex__west_11_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna_breach__sw_save__ctx__door_opened()
}
pub fn access_giguna_breach__sw_save__west_11__ex__side_door_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_door_opened
    ctx.giguna_breach__sw_save__ctx__door_opened()
}
pub fn access_giguna_breach__sw_save__west_11__open_door__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_door_opened
    !ctx.giguna_breach__sw_save__ctx__door_opened()
}
pub fn access_giguna_dual_path_switch(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Dual_Path_Switch
    ctx.has(Item::Giguna_Dual_Path_Switch)
}
pub fn access_giguna_dual_path_switch_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Giguna_Dual_Path_Switch and ($grab or $climb)
    (ctx.has(Item::Giguna_Dual_Path_Switch)
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_giguna_dual_path_switch_and_climb(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Dual_Path_Switch and $climb
    (ctx.has(Item::Giguna_Dual_Path_Switch) && helper__climb!(ctx, world))
}
pub fn access_giguna_dual_path_switch_and_hook(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Dual_Path_Switch and $hook
    (ctx.has(Item::Giguna_Dual_Path_Switch) && helper__hook!(ctx, world))
}
pub fn access_giguna_gateway_block(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Gateway_Block
    ctx.has(Item::Giguna_Gateway_Block)
}
pub fn access_giguna_gateway_gate(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Gateway_Gate
    ctx.has(Item::Giguna_Gateway_Gate)
}
pub fn access_giguna_gubi(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Gubi
    ctx.has(Item::Giguna_Gubi)
}
pub fn access_giguna_northeast_gate(ctx: &Context, world: &graph::World) -> bool {
    // Giguna_Northeast_Gate
    ctx.has(Item::Giguna_Northeast_Gate)
}
pub fn access_grab(ctx: &Context, world: &graph::World) -> bool {
    // $grab
    helper__grab!(ctx, world)
}
pub fn access_grab_and_annuna_east_bridge_gate(ctx: &Context, world: &graph::World) -> bool {
    // $grab and Annuna_East_Bridge_Gate
    (helper__grab!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_grab_and_anuman(ctx: &Context, world: &graph::World) -> bool {
    // $grab and Anuman
    (helper__grab!(ctx, world) && ctx.has(Item::Anuman))
}
pub fn access_grab_and_can_deploy(ctx: &Context, world: &graph::World) -> bool {
    // $grab and $can_deploy
    (helper__grab!(ctx, world) && helper__can_deploy!(ctx, world))
}
pub fn access_grab_and_climb(ctx: &Context, world: &graph::World) -> bool {
    // $grab and $climb
    (helper__grab!(ctx, world) && helper__climb!(ctx, world))
}
pub fn access_grab_and_giguna_gateway_block(ctx: &Context, world: &graph::World) -> bool {
    // $grab and Giguna_Gateway_Block
    (helper__grab!(ctx, world) && ctx.has(Item::Giguna_Gateway_Block))
}
pub fn access_grab_and_switch_40_12(ctx: &Context, world: &graph::World) -> bool {
    // $grab and Switch_40_12
    (helper__grab!(ctx, world) && ctx.has(Item::Switch_40_12))
}
pub fn access_grab_and_water_movement(ctx: &Context, world: &graph::World) -> bool {
    // $grab and Water_Movement
    (helper__grab!(ctx, world) && ctx.has(Item::Water_Movement))
}
pub fn access_grab_or_anuman(ctx: &Context, world: &graph::World) -> bool {
    // $grab or Anuman
    (helper__grab!(ctx, world) || ctx.has(Item::Anuman))
}
pub fn access_grab_or_climb(ctx: &Context, world: &graph::World) -> bool {
    // $grab or $climb
    (helper__grab!(ctx, world) || helper__climb!(ctx, world))
}
pub fn access_grab_or_climb_or_hook(ctx: &Context, world: &graph::World) -> bool {
    // $grab or $climb or $hook
    ((helper__grab!(ctx, world) || helper__climb!(ctx, world)) || helper__hook!(ctx, world))
}
pub fn access_grab_or_hook(ctx: &Context, world: &graph::World) -> bool {
    // $grab or $hook
    (helper__grab!(ctx, world) || helper__hook!(ctx, world))
}
pub fn access_grab_or_underwater_movement(ctx: &Context, world: &graph::World) -> bool {
    // $grab or Underwater_Movement
    (helper__grab!(ctx, world) || ctx.has(Item::Underwater_Movement))
}
pub fn access_health_upgrade(ctx: &Context, world: &graph::World) -> bool {
    // Health_Upgrade
    ctx.has(Item::Health_Upgrade)
}
pub fn access_health_upgrade_2(ctx: &Context, world: &graph::World) -> bool {
    // Health_Upgrade_2
    ctx.has(Item::Health_Upgrade_2)
}
pub fn access_health_upgrade_3(ctx: &Context, world: &graph::World) -> bool {
    // Health_Upgrade_3
    ctx.has(Item::Health_Upgrade_3)
}
pub fn access_health_upgrade_4(ctx: &Context, world: &graph::World) -> bool {
    // Health_Upgrade_4
    ctx.has(Item::Health_Upgrade_4)
}
pub fn access_hook(ctx: &Context, world: &graph::World) -> bool {
    // $hook
    helper__hook!(ctx, world)
}
pub fn access_hook_and_annuna_east_bridge_gate(ctx: &Context, world: &graph::World) -> bool {
    // $hook and Annuna_East_Bridge_Gate
    (helper__hook!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_hook_and_giguna_gateway_block(ctx: &Context, world: &graph::World) -> bool {
    // $hook and Giguna_Gateway_Block
    (helper__hook!(ctx, world) && ctx.has(Item::Giguna_Gateway_Block))
}
pub fn access_hook_and_hover(ctx: &Context, world: &graph::World) -> bool {
    // $hook and $hover
    (helper__hook!(ctx, world) && helper__hover!(ctx, world))
}
pub fn access_hook_and_hover_and_underwater_movement(ctx: &Context, world: &graph::World) -> bool {
    // $hook and $hover and Underwater_Movement
    ((helper__hook!(ctx, world) && helper__hover!(ctx, world))
        && ctx.has(Item::Underwater_Movement))
}
pub fn access_hook_and_not_ebih_waterfall_block_left(ctx: &Context, world: &graph::World) -> bool {
    // $hook and not Ebih_Waterfall_Block_Left
    (helper__hook!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Left))
}
pub fn access_hook_and_not_ebih_waterfall_block_right(ctx: &Context, world: &graph::World) -> bool {
    // $hook and not Ebih_Waterfall_Block_Right
    (helper__hook!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Right))
}
pub fn access_hook_and_underwater_movement(ctx: &Context, world: &graph::World) -> bool {
    // $hook and Underwater_Movement
    (helper__hook!(ctx, world) && ctx.has(Item::Underwater_Movement))
}
pub fn access_hook_and_water_movement(ctx: &Context, world: &graph::World) -> bool {
    // $hook and Water_Movement
    (helper__hook!(ctx, world) && ctx.has(Item::Water_Movement))
}
pub fn access_hook_or_hover(ctx: &Context, world: &graph::World) -> bool {
    // $hook or $hover
    (helper__hook!(ctx, world) || helper__hover!(ctx, world))
}
pub fn access_hover(ctx: &Context, world: &graph::World) -> bool {
    // $hover
    helper__hover!(ctx, world)
}
pub fn access_hover_and_anuman(ctx: &Context, world: &graph::World) -> bool {
    // $hover and Anuman
    (helper__hover!(ctx, world) && ctx.has(Item::Anuman))
}
pub fn access_hover_and_hook(ctx: &Context, world: &graph::World) -> bool {
    // $hover and $hook
    (helper__hover!(ctx, world) && helper__hook!(ctx, world))
}
pub fn access_hover_and_hook_and_mist2(ctx: &Context, world: &graph::World) -> bool {
    // $hover and $hook and $mist2
    ((helper__hover!(ctx, world) && helper__hook!(ctx, world)) && helper__mist2!(ctx, world))
}
pub fn access_hover_and_mist_upgrade(ctx: &Context, world: &graph::World) -> bool {
    // $hover and Mist_Upgrade
    (helper__hover!(ctx, world) && ctx.has(Item::Mist_Upgrade))
}
pub fn access_hover_or_hook(ctx: &Context, world: &graph::World) -> bool {
    // $hover or $hook
    (helper__hover!(ctx, world) || helper__hook!(ctx, world))
}
pub fn access_hover_or_mist2(ctx: &Context, world: &graph::World) -> bool {
    // $hover or $mist2
    (helper__hover!(ctx, world) || helper__mist2!(ctx, world))
}
pub fn access_infect(ctx: &Context, world: &graph::World) -> bool {
    // Infect
    ctx.has(Item::Infect)
}
pub fn access_infect_and_anuman(ctx: &Context, world: &graph::World) -> bool {
    // Infect and Anuman
    (ctx.has(Item::Infect) && ctx.has(Item::Anuman))
}
pub fn access_infect_and_not_anuman(ctx: &Context, world: &graph::World) -> bool {
    // Infect and not Anuman
    (ctx.has(Item::Infect) && !ctx.has(Item::Anuman))
}
pub fn access_infect_l1(ctx: &Context, world: &graph::World) -> bool {
    // Infect_L1
    ctx.has(Item::Infect_L1)
}
pub fn access_infect_l2(ctx: &Context, world: &graph::World) -> bool {
    // Infect_L2
    ctx.has(Item::Infect_L2)
}
pub fn access_infection_range(ctx: &Context, world: &graph::World) -> bool {
    // Infection_Range
    ctx.has(Item::Infection_Range)
}
pub fn access_infection_range_2(ctx: &Context, world: &graph::World) -> bool {
    // Infection_Range_2
    ctx.has(Item::Infection_Range_2)
}
pub fn access_infection_speed(ctx: &Context, world: &graph::World) -> bool {
    // Infection_Speed
    ctx.has(Item::Infection_Speed)
}
pub fn access_infinite_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $infinite_climb and Annuna_East_Bridge_Gate
    (helper__infinite_climb!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_infinite_climb_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $infinite_climb and not Annuna_East_Bridge_Gate
    (helper__infinite_climb!(ctx, world) && !ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_infinite_climb_and_slingshot_hook(ctx: &Context, world: &graph::World) -> bool {
    // $infinite_climb and Slingshot_Hook
    (helper__infinite_climb!(ctx, world) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_infinite_climb_and_slingshot_hook_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // $infinite_climb and Slingshot_Hook and not Annuna_East_Bridge_Gate
    ((helper__infinite_climb!(ctx, world) && ctx.has(Item::Slingshot_Hook))
        && !ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_irikar__basement_portal__ledge__ex__moving_platform_start_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_platform_moved
    !ctx.irikar__basement_portal__ctx__platform_moved()
}
pub fn access_irikar__basement_portal__middle_platform__ex__moving_platform_end_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^_platform_moved and $hook
    (ctx.irikar__basement_portal__ctx__platform_moved() && helper__hook!(ctx, world))
}
pub fn access_irikar__basement_portal__portal_stand__ex__moving_platform_start_1__req(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not ^_platform_moved
    !ctx.irikar__basement_portal__ctx__platform_moved()
}
pub fn access_irikar_gudam(ctx: &Context, world: &graph::World) -> bool {
    // Irikar_Gudam
    ctx.has(Item::Irikar_Gudam)
}
pub fn access_irikar_royal_storage_wall(ctx: &Context, world: &graph::World) -> bool {
    // Irikar_Royal_Storage_Wall
    ctx.has(Item::Irikar_Royal_Storage_Wall)
}
pub fn access_map__amagi__main_area__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__amagi__main_area__save
    ctx.map__amagi__main_area__save()
}
pub fn access_map__annuna__center_save__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__annuna__center_save__save
    ctx.map__annuna__center_save__save()
}
pub fn access_map__annuna__factory_entrance__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__annuna__factory_entrance__save
    ctx.map__annuna__factory_entrance__save()
}
pub fn access_map__annuna__mirror_match__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__annuna__mirror_match__save
    ctx.map__annuna__mirror_match__save()
}
pub fn access_map__ebih__base_camp__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__ebih__base_camp__save
    ctx.map__ebih__base_camp__save()
}
pub fn access_map__ebih__ebih_west__lower_save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__ebih__ebih_west__lower_save
    ctx.map__ebih__ebih_west__lower_save()
}
pub fn access_map__ebih__ebih_west__mid_save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__ebih__ebih_west__mid_save
    ctx.map__ebih__ebih_west__mid_save()
}
pub fn access_map__ebih__ebih_west__upper_save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__ebih__ebih_west__upper_save
    ctx.map__ebih__ebih_west__upper_save()
}
pub fn access_map__giguna__giguna_base__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__giguna__giguna_base__save
    ctx.map__giguna__giguna_base__save()
}
pub fn access_map__giguna__giguna_northeast__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__giguna__giguna_northeast__save
    ctx.map__giguna__giguna_northeast__save()
}
pub fn access_map__giguna__ruins_top__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__giguna__ruins_top__save
    ctx.map__giguna__ruins_top__save()
}
pub fn access_map__giguna__ruins_west__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__giguna__ruins_west__save
    ctx.map__giguna__ruins_west__save()
}
pub fn access_map__giguna_breach__peak__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__giguna_breach__peak__save
    ctx.map__giguna_breach__peak__save()
}
pub fn access_map__giguna_breach__sw_save__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__giguna_breach__sw_save__save
    ctx.map__giguna_breach__sw_save__save()
}
pub fn access_map__glacier__revival__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__glacier__revival__save
    ctx.map__glacier__revival__save()
}
pub fn access_map__irikar__hub__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__irikar__hub__save
    ctx.map__irikar__hub__save()
}
pub fn access_map__irikar_breach__gauntlet__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__irikar_breach__gauntlet__save
    ctx.map__irikar_breach__gauntlet__save()
}
pub fn access_map__irikar_breach__save_room__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__irikar_breach__save_room__save
    ctx.map__irikar_breach__save_room__save()
}
pub fn access_map__uhrum__annuna_corridor__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__uhrum__annuna_corridor__save
    ctx.map__uhrum__annuna_corridor__save()
}
pub fn access_map__uhrum__save_room__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__uhrum__save_room__save
    ctx.map__uhrum__save_room__save()
}
pub fn access_map__uhrum__west_entrance__save(ctx: &Context, world: &graph::World) -> bool {
    // ^map__uhrum__west_entrance__save
    ctx.map__uhrum__west_entrance__save()
}
pub fn access_melee_damage(ctx: &Context, world: &graph::World) -> bool {
    // Melee_Damage
    ctx.has(Item::Melee_Damage)
}
pub fn access_melee_damage_2(ctx: &Context, world: &graph::World) -> bool {
    // Melee_Damage_2
    ctx.has(Item::Melee_Damage_2)
}
pub fn access_melee_speed(ctx: &Context, world: &graph::World) -> bool {
    // Melee_Speed
    ctx.has(Item::Melee_Speed)
}
pub fn access_melee_speed_2(ctx: &Context, world: &graph::World) -> bool {
    // Melee_Speed_2
    ctx.has(Item::Melee_Speed_2)
}
pub fn access_mist2(ctx: &Context, world: &graph::World) -> bool {
    // $mist2
    helper__mist2!(ctx, world)
}
pub fn access_mist_upgrade(ctx: &Context, world: &graph::World) -> bool {
    // Mist_Upgrade
    ctx.has(Item::Mist_Upgrade)
}
pub fn access_mode_eq_drone(ctx: &Context, world: &graph::World) -> bool {
    // ^mode == 'drone'
    ctx.mode() == enums::Mode::Drone
}
pub fn access_mode_eq_drone_and_breach_sight(ctx: &Context, world: &graph::World) -> bool {
    // ^mode == 'drone' and Breach_Sight
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Breach_Sight))
}
pub fn access_mode_eq_drone_and_ebih_wasteland_passage_h(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and Ebih_Wasteland_Passage_H
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Ebih_Wasteland_Passage_H))
}
pub fn access_mode_eq_drone_and_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Left
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Ebih_Waterfall_Block_Left))
}
pub fn access_mode_eq_drone_and_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Right
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Ebih_Waterfall_Block_Right))
}
pub fn access_mode_eq_drone_and_giguna_dual_path_wall(ctx: &Context, world: &graph::World) -> bool {
    // ^mode == 'drone' and Giguna_Dual_Path_Wall
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Giguna_Dual_Path_Wall))
}
pub fn access_mode_eq_drone_and_mist2(ctx: &Context, world: &graph::World) -> bool {
    // ^mode == 'drone' and $mist2
    (ctx.mode() == enums::Mode::Drone && helper__mist2!(ctx, world))
}
pub fn access_mode_eq_drone_and_mist_upgrade(ctx: &Context, world: &graph::World) -> bool {
    // ^mode == 'drone' and Mist_Upgrade
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Mist_Upgrade))
}
pub fn access_mode_eq_drone_and_sniper_valley_rock_2(ctx: &Context, world: &graph::World) -> bool {
    // ^mode == 'drone' and Sniper_Valley_Rock_2
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Sniper_Valley_Rock_2))
}
pub fn access_mode_ne_drone(ctx: &Context, world: &graph::World) -> bool {
    // ^mode != 'drone'
    ctx.mode() != enums::Mode::Drone
}
pub fn access_more_refills(ctx: &Context, world: &graph::World) -> bool {
    // $more_refills
    helper__more_refills!(ctx, world)
}
pub fn access_nanite_mist(ctx: &Context, world: &graph::World) -> bool {
    // Nanite_Mist
    ctx.has(Item::Nanite_Mist)
}
pub fn access_nanite_mist_and_mist_upgrade(ctx: &Context, world: &graph::World) -> bool {
    // Nanite_Mist and Mist_Upgrade
    (ctx.has(Item::Nanite_Mist) && ctx.has(Item::Mist_Upgrade))
}
pub fn access_nano_points(ctx: &Context, world: &graph::World) -> bool {
    // Nano_Points
    ctx.has(Item::Nano_Points)
}
pub fn access_nano_points_2(ctx: &Context, world: &graph::World) -> bool {
    // Nano_Points_2
    ctx.has(Item::Nano_Points_2)
}
pub fn access_not_amashilama(ctx: &Context, world: &graph::World) -> bool {
    // NOT Amashilama
    !ctx.has(Item::Amashilama)
}
pub fn access_not_ebih_interchange_block(ctx: &Context, world: &graph::World) -> bool {
    // not Ebih_Interchange_Block
    !ctx.has(Item::Ebih_Interchange_Block)
}
pub fn access_not_ebih_waterfall_wall_and_nanite_mist_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not Ebih_Waterfall_Wall and Nanite_Mist and Mist_Upgrade
    ((!ctx.has(Item::Ebih_Waterfall_Wall) && ctx.has(Item::Nanite_Mist))
        && ctx.has(Item::Mist_Upgrade))
}
pub fn access_not_irikar_royal_storage_wall_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not Irikar_Royal_Storage_Wall and Mist_Upgrade
    (!ctx.has(Item::Irikar_Royal_Storage_Wall) && ctx.has(Item::Mist_Upgrade))
}
pub fn access_not_irikar_royal_storage_wall_and_shockwave(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // not Irikar_Royal_Storage_Wall and $shockwave
    (!ctx.has(Item::Irikar_Royal_Storage_Wall) && helper__shockwave!(ctx, world))
}
pub fn access_not_separation_or_defeat_indra(ctx: &Context, world: &graph::World) -> bool {
    // NOT Separation or Defeat_Indra
    (!ctx.has(Item::Separation) || ctx.has(Item::Defeat_Indra))
}
pub fn access_not_slingshot_hook(ctx: &Context, world: &graph::World) -> bool {
    // not Slingshot_Hook
    !ctx.has(Item::Slingshot_Hook)
}
pub fn access_not_within_menu_and_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // NOT WITHIN `Menu` and Anuman and ^mode != 'drone'
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ctx.has(Item::Anuman))
        && ctx.mode() != enums::Mode::Drone)
}
pub fn access_not_within_menu_and_can_deploy(ctx: &Context, world: &graph::World) -> bool {
    // NOT WITHIN `Menu` and $can_deploy
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && helper__can_deploy!(ctx, world))
}
pub fn access_not_within_menu_and_flasks_gt_0(ctx: &Context, world: &graph::World) -> bool {
    // NOT WITHIN `Menu` and ^flasks > 0
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && Into::<i32>::into(ctx.flasks()) > 0.into())
}
pub fn access_not_within_menu_and_ft_main_and_can_recall_and___map_spot_not_within_default(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // NOT WITHIN `Menu` and $ft_main and $can_recall and (^map_spot NOT WITHIN $default)
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && helper__ft_main!(ctx, world))
        && helper__can_recall!(ctx, world))
        && (data::map_spot(ctx.position()) != Default::default()))
}
pub fn access_not_within_menu_and_realm_ne_breach_and_anuman_and_mode_eq_drone(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and Anuman and ^mode == 'drone'
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && data::realm(ctx.position()) != enums::Realm::Breach)
        && ctx.has(Item::Anuman))
        && ctx.mode() == enums::Mode::Drone)
}
pub fn access_not_within_menu_and_realm_ne_breach_and_can_recall(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and $can_recall
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && data::realm(ctx.position()) != enums::Realm::Breach)
        && helper__can_recall!(ctx, world))
}
pub fn access_offset(ctx: &Context, world: &graph::World) -> bool {
    // $offset
    helper__offset!(ctx, world)
}
pub fn access_open(ctx: &Context, world: &graph::World) -> bool {
    // $open
    helper__open!(ctx, world)
}
pub fn access_open_and_range1(ctx: &Context, world: &graph::World) -> bool {
    // $open and $range1
    (helper__open!(ctx, world) && helper__range1!(ctx, world))
}
pub fn access_open_and_range2(ctx: &Context, world: &graph::World) -> bool {
    // $open and $range2
    (helper__open!(ctx, world) && helper__range2!(ctx, world))
}
pub fn access_open_and_range3(ctx: &Context, world: &graph::World) -> bool {
    // $open and $range3
    (helper__open!(ctx, world) && helper__range3!(ctx, world))
}
pub fn access_overheat(ctx: &Context, world: &graph::World) -> bool {
    // $overheat
    helper__overheat!(ctx, world)
}
pub fn access_overheat_and_can_damage(ctx: &Context, world: &graph::World) -> bool {
    // $overheat and $can_damage
    (helper__overheat!(ctx, world) && helper__can_damage!(ctx, world))
}
pub fn access_platform_and_hook_and_hover(ctx: &Context, world: &graph::World) -> bool {
    // $platform and $hook and $hover
    ((helper__platform!(ctx, world) && helper__hook!(ctx, world)) && helper__hover!(ctx, world))
}
pub fn access_ranged_damage(ctx: &Context, world: &graph::World) -> bool {
    // Ranged_Damage
    ctx.has(Item::Ranged_Damage)
}
pub fn access_ranged_damage_2(ctx: &Context, world: &graph::World) -> bool {
    // Ranged_Damage_2
    ctx.has(Item::Ranged_Damage_2)
}
pub fn access_ranged_speed(ctx: &Context, world: &graph::World) -> bool {
    // Ranged_Speed
    ctx.has(Item::Ranged_Speed)
}
pub fn access_ranged_speed_2(ctx: &Context, world: &graph::World) -> bool {
    // Ranged_Speed_2
    ctx.has(Item::Ranged_Speed_2)
}
pub fn access_realm_eq_breach(ctx: &Context, world: &graph::World) -> bool {
    // ^realm == 'breach'
    data::realm(ctx.position()) == enums::Realm::Breach
}
pub fn access_realm_eq_breach_and_exit_breach_and___flipside_not_within_default(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^realm == 'breach' and Exit_Breach and (^flipside NOT WITHIN $default)
    ((data::realm(ctx.position()) == enums::Realm::Breach && ctx.has(Item::Exit_Breach))
        && (data::flipside(ctx.position()) != Default::default()))
}
pub fn access_realm_in___main_interior_emergence_and_amashilama(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // ^realm IN ['main', 'interior', 'emergence'] and Amashilama
    (matches!(
        data::realm(ctx.position()),
        enums::Realm::Main | enums::Realm::Interior | enums::Realm::Emergence
    ) && ctx.has(Item::Amashilama))
}
pub fn access_remote_drone(ctx: &Context, world: &graph::World) -> bool {
    // Remote_Drone
    ctx.has(Item::Remote_Drone)
}
pub fn access_separation(ctx: &Context, world: &graph::World) -> bool {
    // Separation
    ctx.has(Item::Separation)
}
pub fn access_separation_and_not_defeat_indra_and_mist2(
    ctx: &Context,
    world: &graph::World,
) -> bool {
    // Separation and NOT Defeat_Indra and $mist2
    ((ctx.has(Item::Separation) && !ctx.has(Item::Defeat_Indra)) && helper__mist2!(ctx, world))
}
pub fn access_shockwave(ctx: &Context, world: &graph::World) -> bool {
    // $shockwave
    helper__shockwave!(ctx, world)
}
pub fn access_shockwave_and_not_defeat_mus_a_m20(ctx: &Context, world: &graph::World) -> bool {
    // $shockwave and not Defeat_MUS_A_M20
    (helper__shockwave!(ctx, world) && !ctx.has(Item::Defeat_MUS_A_M20))
}
pub fn access_sniper_valley_rock_1(ctx: &Context, world: &graph::World) -> bool {
    // Sniper_Valley_Rock_1
    ctx.has(Item::Sniper_Valley_Rock_1)
}
pub fn access_spin(ctx: &Context, world: &graph::World) -> bool {
    // $spin
    helper__spin!(ctx, world)
}
pub fn access_station_power(ctx: &Context, world: &graph::World) -> bool {
    // Station_Power
    ctx.has(Item::Station_Power)
}
pub fn access_switch_36_11(ctx: &Context, world: &graph::World) -> bool {
    // Switch_36_11
    ctx.has(Item::Switch_36_11)
}
pub fn access_switch_40_12(ctx: &Context, world: &graph::World) -> bool {
    // Switch_40_12
    ctx.has(Item::Switch_40_12)
}
pub fn access_uhrum_annuna_corridor_block(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_Annuna_Corridor_Block
    ctx.has(Item::Uhrum_Annuna_Corridor_Block)
}
pub fn access_uhrum_waterfall_wall(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_Waterfall_Wall
    ctx.has(Item::Uhrum_Waterfall_Wall)
}
pub fn access_uhrum_waterfalls_block(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_Waterfalls_Block
    ctx.has(Item::Uhrum_Waterfalls_Block)
}
pub fn access_uhrum_waterfalls_block_and_grab(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_Waterfalls_Block and $grab
    (ctx.has(Item::Uhrum_Waterfalls_Block) && helper__grab!(ctx, world))
}
pub fn access_uhrum_waterfalls_block_and_hook(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_Waterfalls_Block and $hook
    (ctx.has(Item::Uhrum_Waterfalls_Block) && helper__hook!(ctx, world))
}
pub fn access_uhrum_west_entrance_gate(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_West_Entrance_Gate
    ctx.has(Item::Uhrum_West_Entrance_Gate)
}
pub fn access_uhrum_west_entrance_gate_and_hover(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_West_Entrance_Gate and $hover
    (ctx.has(Item::Uhrum_West_Entrance_Gate) && helper__hover!(ctx, world))
}
pub fn access_uhrum_west_entrance_lower_wall(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_West_Entrance_Lower_Wall
    ctx.has(Item::Uhrum_West_Entrance_Lower_Wall)
}
pub fn access_uhrum_west_entrance_upper_wall(ctx: &Context, world: &graph::World) -> bool {
    // Uhrum_West_Entrance_Upper_Wall
    ctx.has(Item::Uhrum_West_Entrance_Upper_Wall)
}
pub fn access_underwater_movement(ctx: &Context, world: &graph::World) -> bool {
    // Underwater_Movement
    ctx.has(Item::Underwater_Movement)
}
pub fn access_underwater_movement_and___grab_or_climb(ctx: &Context, world: &graph::World) -> bool {
    // Underwater_Movement and ($grab or $climb)
    (ctx.has(Item::Underwater_Movement)
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_underwater_movement_and_grab(ctx: &Context, world: &graph::World) -> bool {
    // Underwater_Movement and $grab
    (ctx.has(Item::Underwater_Movement) && helper__grab!(ctx, world))
}
pub fn access_underwater_movement_and_hook(ctx: &Context, world: &graph::World) -> bool {
    // Underwater_Movement and $hook
    (ctx.has(Item::Underwater_Movement) && helper__hook!(ctx, world))
}
pub fn access_within_antarctica(ctx: &Context, world: &graph::World) -> bool {
    // WITHIN `Antarctica`
    (match get_region(ctx.position()) {
        RegionId::Antarctica => true,
        _ => false,
    })
}
pub fn access_within_menu_gt_upgrade_menu(ctx: &Context, world: &graph::World) -> bool {
    // WITHIN `Menu > Upgrade Menu`
    (match get_area(ctx.position()) {
        AreaId::Menu__Upgrade_Menu => true,
        _ => false,
    })
}
pub fn action_amagi__main_area__carving__key_combo__do(ctx: &mut Context, world: &graph::World) {
    // ^_combo = true
    ctx.set_amagi__main_area__ctx__combo(true);
}
pub fn action_annuna__east_bridge__tower_east_ledge__enter_combo__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_combo = true
    ctx.set_annuna__east_bridge__ctx__combo(true);
}
pub fn action_annuna__east_bridge__tower_secret__enter_combo__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_combo = true
    ctx.set_annuna__east_bridge__ctx__combo(true);
}
pub fn action_annuna__east_bridge__tower_west_ledge__enter_combo__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_combo = true
    ctx.set_annuna__east_bridge__ctx__combo(true);
}
pub fn action_annuna__west_climb__switch_ledge__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_opened = true
    ctx.set_annuna__west_climb__ctx__door_opened(true);
}
pub fn action_breach_portal_save_update(ctx: &mut Context, world: &graph::World) {
    // $breach_portal_save_update
    helper__breach_portal_save_update!(ctx, world);
}
pub fn action_clear_breach_save(ctx: &mut Context, world: &graph::World) {
    // $clear_breach_save
    helper__clear_breach_save!(ctx, world);
}
pub fn action_collect__irikar_royal_storage_wall_collect__flask_visit__irikar_gt_hub_gt_royal_storage_in_wall_gt_item(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $collect(Irikar_Royal_Storage_Wall); $collect(Flask); $visit(`Irikar > Hub > Royal Storage in Wall > Item`);
    ctx.collect(Item::Irikar_Royal_Storage_Wall, world);
    ctx.collect(Item::Flask, world);
    ctx.visit(LocationId::Irikar__Hub__Royal_Storage_in_Wall__Item);
}
pub fn action_deploy_drone(ctx: &mut Context, world: &graph::World) {
    // $deploy_drone
    helper__deploy_drone!(ctx, world);
}
pub fn action_deploy_drone_and_move__annuna_gt_east_bridge_gt_center_corridor(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Center Corridor`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Annuna__East_Bridge__Center_Corridor);
}
pub fn action_deploy_drone_and_move__annuna_gt_east_bridge_gt_tower_base_east(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Tower Base East`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Annuna__East_Bridge__Tower_Base_East);
}
pub fn action_deploy_drone_and_move__ebih_gt_drone_room_gt_tree(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Ebih > Drone Room > Tree`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Drone_Room__Tree);
}
pub fn action_deploy_drone_and_move__ebih_gt_ebih_west_gt_alcove_entrance(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Ebih > Ebih West > Alcove Entrance`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Ebih_West__Alcove_Entrance);
}
pub fn action_deploy_drone_and_move__giguna_gt_giguna_base_gt_kari(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Giguna > Giguna Base > Kari`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Giguna_Base__Kari);
}
pub fn action_deploy_drone_and_move__giguna_gt_ruins_top_gt_west_7(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Giguna > Ruins Top > West 7`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Ruins_Top__West_7);
}
pub fn action_deploy_drone_and_move__giguna_gt_wasteland_gt_middle_path(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $deploy_drone_and_move(`Giguna > Wasteland > Middle Path`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Wasteland__Middle_Path);
}
pub fn action_ebih__base_camp__left_platform__move_left_platform__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_left_platform_moved = true
    ctx.set_ebih__base_camp__ctx__left_platform_moved(true);
}
pub fn action_ebih__base_camp__left_platform_moved__reset_left_platform__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_left_platform_moved = false
    ctx.set_ebih__base_camp__ctx__left_platform_moved(false);
}
pub fn action_ebih__drone_room__pit_left__activate_lift__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_moved = false
    ctx.set_ebih__drone_room__ctx__platform_moved(false);
}
pub fn action_ebih__drone_room__pit_left__activate_lift_but_get_off_early__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_moved = false
    ctx.set_ebih__drone_room__ctx__platform_moved(false);
}
pub fn action_ebih__drone_room__portal_exit__activate_platform__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_moved = true
    ctx.set_ebih__drone_room__ctx__platform_moved(true);
}
pub fn action_ebih__ebih_east__dispenser__activate_lift__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform2_moved = false
    ctx.set_ebih__ebih_east__ctx__platform2_moved(false);
}
pub fn action_ebih__ebih_east__lower_moving_platform__activate_lift__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform2_moved = true
    ctx.set_ebih__ebih_east__ctx__platform2_moved(true);
}
pub fn action_ebih__ebih_east__lower_moving_platform__activate_ride__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform2_moved = true
    ctx.set_ebih__ebih_east__ctx__platform2_moved(true);
}
pub fn action_ebih__ebih_east__moving_platform__activate_ride__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform1_moved = true
    ctx.set_ebih__ebih_east__ctx__platform1_moved(true);
}
pub fn action_ebih__ebih_west__below_door__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_door_open = true; IF (^indra WITHIN `Ebih > Ebih West > Above Door`) { ^indra = `Ebih > Ebih West > Below Door`; }
    ctx.set_ebih__ebih_west__ctx__door_open(true);
    if ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door {
        ctx.set_indra(SpotId::Ebih__Ebih_West__Below_Door);
    }
}
pub fn action_ebih__ebih_west__left_of_switch__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true; IF (^indra WITHIN `Ebih > Ebih West > Above Door`) { ^indra = `Ebih > Ebih West > Below Door`; }
    ctx.set_ebih__ebih_west__ctx__door_open(true);
    if ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door {
        ctx.set_indra(SpotId::Ebih__Ebih_West__Below_Door);
    }
}
pub fn action_ebih__grid_25_10_12__door_left__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true
    ctx.set_ebih__grid_25_10_12__ctx__door_open(true);
}
pub fn action_ebih__grid_25_10_12__east_11__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_door_open = true
    ctx.set_ebih__grid_25_10_12__ctx__door_open(true);
}
pub fn action_ebih__vertical_interchange__west_13__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true
    ctx.set_ebih__vertical_interchange__ctx__door_open(true);
}
pub fn action_ebih__waterfall__below_left_switch__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_west_door_open = true
    ctx.set_ebih__waterfall__ctx__west_door_open(true);
}
pub fn action_ebih__waterfall__west_8__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_west_door_open = true
    ctx.set_ebih__waterfall__ctx__west_door_open(true);
}
pub fn action_flasks_incr_1(ctx: &mut Context, world: &graph::World) {
    // ^flasks += 1
    ctx.flasks += 1;
}
pub fn action_flasks_incr_2(ctx: &mut Context, world: &graph::World) {
    // ^flasks += 2
    ctx.flasks += 2;
}
pub fn action_giguna__carnelian__lower_susar__caught__do(ctx: &mut Context, world: &graph::World) {
    // ^_lower_susar = true
    ctx.set_giguna__carnelian__ctx__lower_susar(true);
}
pub fn action_giguna__carnelian__lower_susar__hack__do(ctx: &mut Context, world: &graph::World) {
    // ^_lower_susar = true
    ctx.set_giguna__carnelian__ctx__lower_susar(true);
}
pub fn action_giguna__carnelian__switch__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_door_opened = true
    ctx.set_giguna__carnelian__ctx__door_opened(true);
}
pub fn action_giguna__carnelian__upper_susar__caught__do(ctx: &mut Context, world: &graph::World) {
    // ^_upper_susar = true
    ctx.set_giguna__carnelian__ctx__upper_susar(true);
}
pub fn action_giguna__carnelian__upper_susar__hack__do(ctx: &mut Context, world: &graph::World) {
    // ^_upper_susar = true
    ctx.set_giguna__carnelian__ctx__upper_susar(true);
}
pub fn action_giguna__clouds__platform_start__hack_and_get_off_early__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_and_portal = true
    ctx.set_giguna__clouds__ctx__platform_and_portal(true);
}
pub fn action_giguna__clouds__platform_start__hack_and_ride_to_portal__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_and_portal = true; if (^indra WITHIN ^position) { ^indra = `Giguna > Clouds > Platform Stop` }
    ctx.set_giguna__clouds__ctx__platform_and_portal(true);
    if ctx.indra() == ctx.position() {
        ctx.set_indra(SpotId::Giguna__Clouds__Platform_Stop);
    }
}
pub fn action_giguna__clouds__platform_start__hack_deploy_ride_to_portal__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_and_portal = true; $deploy_drone_and_move(`Giguna > Clouds > Platform Stop`)
    ctx.set_giguna__clouds__ctx__platform_and_portal(true);
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Clouds__Platform_Stop);
}
pub fn action_giguna__east_caverns__lower_susar__caught__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_lower_susar = true
    ctx.set_giguna__east_caverns__ctx__lower_susar(true);
}
pub fn action_giguna__east_caverns__lower_susar__hack__do(ctx: &mut Context, world: &graph::World) {
    // ^_lower_susar = true
    ctx.set_giguna__east_caverns__ctx__lower_susar(true);
}
pub fn action_giguna__east_caverns__mid_susar__caught__do(ctx: &mut Context, world: &graph::World) {
    // ^_mid_susar = true
    ctx.set_giguna__east_caverns__ctx__mid_susar(true);
}
pub fn action_giguna__east_caverns__mid_susar__hack__do(ctx: &mut Context, world: &graph::World) {
    // ^_mid_susar = true
    ctx.set_giguna__east_caverns__ctx__mid_susar(true);
}
pub fn action_giguna__east_caverns__statues_ledge__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_opened = true
    ctx.set_giguna__east_caverns__ctx__door_opened(true);
}
pub fn action_giguna__east_caverns__switch__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_door_opened = true
    ctx.set_giguna__east_caverns__ctx__door_opened(true);
}
pub fn action_giguna__east_caverns__upper_susar__caught__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_upper_susar = true
    ctx.set_giguna__east_caverns__ctx__upper_susar(true);
}
pub fn action_giguna__east_caverns__upper_susar_jump_from_east__caught__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_upper_susar = true
    ctx.set_giguna__east_caverns__ctx__upper_susar(true);
}
pub fn action_giguna__east_caverns__upper_susar_jump_from_east__hack__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_upper_susar = true
    ctx.set_giguna__east_caverns__ctx__upper_susar(true);
}
pub fn action_giguna__east_caverns__upper_susar_mid_jump__hack__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_upper_susar = true
    ctx.set_giguna__east_caverns__ctx__upper_susar(true);
}
pub fn action_giguna__east_caverns__west_14__enter_combo__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_combo_entered = true
    ctx.set_giguna__east_caverns__ctx__combo_entered(true);
}
pub fn action_giguna__east_caverns__west_16__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_opened = true
    ctx.set_giguna__east_caverns__ctx__door_opened(true);
}
pub fn action_giguna__gateway__flask_ledge__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_door_opened = true
    ctx.set_giguna__gateway__ctx__door_opened(true);
}
pub fn action_giguna__gateway__one_jump__open_door__do(ctx: &mut Context, world: &graph::World) {
    // ^_door_opened = true
    ctx.set_giguna__gateway__ctx__door_opened(true);
}
pub fn action_giguna__giguna_base__switch_distance_1__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true
    ctx.set_giguna__giguna_base__ctx__door_open(true);
}
pub fn action_giguna__giguna_base__switch_distance_2__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true
    ctx.set_giguna__giguna_base__ctx__door_open(true);
}
pub fn action_giguna__giguna_base__switch_distance_3__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true
    ctx.set_giguna__giguna_base__ctx__door_open(true);
}
pub fn action_giguna__giguna_base__switch_distance_4__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_open = true
    ctx.set_giguna__giguna_base__ctx__door_open(true);
}
pub fn action_giguna__giguna_northeast__right_column__open_door_from_afar__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_opened = true
    ctx.set_giguna__giguna_northeast__ctx__door_opened(true);
}
pub fn action_giguna__giguna_northeast__switch__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_opened = true
    ctx.set_giguna__giguna_northeast__ctx__door_opened(true);
}
pub fn action_giguna__ruins_top__switch__open_doors__do(ctx: &mut Context, world: &graph::World) {
    // ^_doors_open = true
    ctx.set_giguna__ruins_top__ctx__doors_open(true);
}
pub fn action_giguna__ruins_west__lower_ledge__destroy_kishib__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_kishib_handled = true
    ctx.set_giguna__ruins_west__ctx__kishib_handled(true);
}
pub fn action_giguna__ruins_west__lower_ledge__hack_kishib__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_kishib_handled = true
    ctx.set_giguna__ruins_west__ctx__kishib_handled(true);
}
pub fn action_giguna__west_caverns__east_susar__caught__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_east_susar = true
    ctx.set_giguna__west_caverns__ctx__east_susar(true);
}
pub fn action_giguna__west_caverns__east_susar__hack__do(ctx: &mut Context, world: &graph::World) {
    // ^_east_susar = true
    ctx.set_giguna__west_caverns__ctx__east_susar(true);
}
pub fn action_giguna_breach__sw_save__west_11__open_door__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_door_opened = true
    ctx.set_giguna_breach__sw_save__ctx__door_opened(true);
}
pub fn action_indra_set_default(ctx: &mut Context, world: &graph::World) {
    // ^indra = $default
    ctx.set_indra(Default::default());
}
pub fn action_indra_set_default_refill_energy(ctx: &mut Context, world: &graph::World) {
    // ^indra = $default; $refill_energy
    ctx.set_indra(Default::default());
    helper__refill_energy!(ctx, world);
}
pub fn action_irikar__basement_portal__moving_platform_start__activate_platform__do(
    ctx: &mut Context,
    world: &graph::World,
) {
    // ^_platform_moved = true
    ctx.set_irikar__basement_portal__ctx__platform_moved(true);
}
pub fn action_last_set_default(ctx: &mut Context, world: &graph::World) {
    // ^last = $default
    ctx.set_last(Default::default());
}
pub fn action_last_set_position(ctx: &mut Context, world: &graph::World) {
    // ^last = ^position
    ctx.set_last(ctx.position());
}
pub fn action_main_portal_save_update(ctx: &mut Context, world: &graph::World) {
    // $main_portal_save_update
    helper__main_portal_save_update!(ctx, world);
}
pub fn action_mode_set_drone(ctx: &mut Context, world: &graph::World) {
    // ^mode = 'drone'
    ctx.set_mode(enums::Mode::Drone);
}
pub fn action_mode_set_drone_indra_set_position(ctx: &mut Context, world: &graph::World) {
    // ^mode = 'drone'; ^indra = ^position
    ctx.set_mode(enums::Mode::Drone);
    ctx.set_indra(ctx.position());
}
pub fn action_mode_set_indra(ctx: &mut Context, world: &graph::World) {
    // ^mode = 'Indra'
    ctx.set_mode(enums::Mode::Indra);
}
pub fn action_mode_set_indra_last_set_indra(ctx: &mut Context, world: &graph::World) {
    // ^mode = 'Indra'; ^last = ^indra
    ctx.set_mode(enums::Mode::Indra);
    ctx.set_last(ctx.indra());
}
pub fn action_pass(ctx: &mut Context, world: &graph::World) {
    // $pass
    ();
}
pub fn action_refill_energy(ctx: &mut Context, world: &graph::World) {
    // $refill_energy
    helper__refill_energy!(ctx, world);
}
pub fn action_refills_incr_1(ctx: &mut Context, world: &graph::World) {
    // ^refills += 1
    ctx.refills += 1;
}
pub fn action_reset_old_area__newpos(ctx: &mut Context, world: &graph::World, newpos: SpotId) {
    // $reset_old_area(^newpos)
    helper__reset_old_area!(ctx, world, newpos);
}
pub fn action_save(ctx: &mut Context, world: &graph::World) {
    // $save
    helper__save!(ctx, world);
}
pub fn action_save_last(ctx: &mut Context, world: &graph::World, newpos: SpotId) {
    // $save_last
    helper__save_last!(ctx, world);
}
pub fn action_save_set_glacier_gt_revival_gt_save_point(ctx: &mut Context, world: &graph::World) {
    // ^save = `Glacier > Revival > Save Point`
    ctx.set_save(SpotId::Glacier__Revival__Save_Point);
}
pub fn action_skip__amagi_gt_west_lake_gt_cavern_refill_station_gt_break_wall_add_item__amagi_dragon_eye_passage(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $skip(`Amagi > West Lake > Cavern Refill Station > Break Wall`); $add_item(Amagi_Dragon_Eye_Passage);
    ctx.skip(LocationId::Amagi__West_Lake__Cavern_Refill_Station__Break_Wall);
    ctx.add_item(Item::Amagi_Dragon_Eye_Passage);
}
pub fn action_skip__amagi_gt_west_lake_gt_stronghold_ceiling_left_gt_knock_down_left_boulder_add_item__amagi_stronghold_wall_1_add_item__amagi_stronghold_boulder_1(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $skip(`Amagi > West Lake > Stronghold Ceiling Left > Knock Down Left Boulder`); $add_item(Amagi_Stronghold_Wall_1); $add_item(Amagi_Stronghold_Boulder_1);
    ctx.skip(LocationId::Amagi__West_Lake__Stronghold_Ceiling_Left__Knock_Down_Left_Boulder);
    ctx.add_item(Item::Amagi_Stronghold_Wall_1);
    ctx.add_item(Item::Amagi_Stronghold_Boulder_1);
}
pub fn action_skip__amagi_gt_west_lake_gt_stronghold_ceiling_right_gt_knock_down_right_boulder_add_item__amagi_stronghold_wall_2_add_item__amagi_stronghold_boulder_2(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $skip(`Amagi > West Lake > Stronghold Ceiling Right > Knock Down Right Boulder`); $add_item(Amagi_Stronghold_Wall_2); $add_item(Amagi_Stronghold_Boulder_2);
    ctx.skip(LocationId::Amagi__West_Lake__Stronghold_Ceiling_Right__Knock_Down_Right_Boulder);
    ctx.add_item(Item::Amagi_Stronghold_Wall_2);
    ctx.add_item(Item::Amagi_Stronghold_Boulder_2);
}
pub fn action_skip__ebih_gt_waterfall_gt_alcove_gt_block_left_skip__ebih_gt_waterfall_gt_alcove_gt_block_right_skip__ebih_gt_waterfall_gt_alcove_left_gt_block_left_skip__ebih_gt_waterfall_gt_alcove_right_gt_block_right_add_item__ebih_waterfall_block_right_add_item__ebih_waterfall_block_left(
    ctx: &mut Context,
    world: &graph::World,
) {
    // $skip(`Ebih > Waterfall > Alcove > Block Left`); $skip(`Ebih > Waterfall > Alcove > Block Right`); $skip(`Ebih > Waterfall > Alcove Left > Block Left`); $skip(`Ebih > Waterfall > Alcove Right > Block Right`); $add_item(Ebih_Waterfall_Block_Right); $add_item(Ebih_Waterfall_Block_Left);
    ctx.skip(LocationId::Ebih__Waterfall__Alcove__Block_Left);
    ctx.skip(LocationId::Ebih__Waterfall__Alcove__Block_Right);
    ctx.skip(LocationId::Ebih__Waterfall__Alcove_Left__Block_Left);
    ctx.skip(LocationId::Ebih__Waterfall__Alcove_Right__Block_Right);
    ctx.add_item(Item::Ebih_Waterfall_Block_Right);
    ctx.add_item(Item::Ebih_Waterfall_Block_Left);
}
pub fn explain___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [$all_urns, $all_weapons, $other_items, $all_notes, $all_health, $all_flasks]
    {
        let mut refs = Vec::new();
        let mut h = hexplain__all_urns!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_weapons!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__other_items!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_notes!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_health!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_flasks!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___escape_objective(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Escape, $objective]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Escape);
            edict.insert("Escape", format!("{}", h));
            (h, vec!["Escape"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = rexplain__objective!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___objective(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [$objective]
    {
        let mut refs = Vec::new();
        let mut h = rexplain__objective!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___remote_drone(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Remote_Drone]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Remote_Drone);
            edict.insert("Remote_Drone", format!("{}", h));
            (h, vec!["Remote_Drone"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___remote_drone_flask__6(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Remote_Drone, Flask{6}]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Remote_Drone);
            edict.insert("Remote_Drone", format!("{}", h));
            (h, vec!["Remote_Drone"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = {
            let ct = ctx.count(Item::Flask);
            edict.insert("Flask count", format!("{}", ct));
            (ct >= 6, vec!["Flask count"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain_activate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $activate
    {
        let (res, mut refs) = hexplain__activate!(ctx, world, edict);
        edict.insert("$activate", format!("{:?}", res));
        refs.push("$activate");
        (res, refs)
    }
}
pub fn explain_amagi__main_area__carving__ex__secret_outcropping_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and ($grab or $climb)
    {
        let mut left = {
            let r = ctx.amagi__main_area__ctx__combo();
            edict.insert("^amagi__main_area__ctx__combo", format!("{:?}", r));
            (r, vec!["^amagi__main_area__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__main_area__carving__ex__secret_outcropping_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and $hook
    {
        let mut left = {
            let r = ctx.amagi__main_area__ctx__combo();
            edict.insert("^amagi__main_area__ctx__combo", format!("{:?}", r));
            (r, vec!["^amagi__main_area__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__main_area__carving__key_combo__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo
    {
        let val = {
            let r = ctx.amagi__main_area__ctx__combo();
            edict.insert("^amagi__main_area__ctx__combo", format!("{:?}", r));
            (r, vec!["^amagi__main_area__ctx__combo"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_amagi_dragon_eye_passage(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Dragon_Eye_Passage
    {
        let h = ctx.has(Item::Amagi_Dragon_Eye_Passage);
        edict.insert("Amagi_Dragon_Eye_Passage", format!("{}", h));
        (h, vec!["Amagi_Dragon_Eye_Passage"])
    }
}
pub fn explain_amagi_stronghold_boulder_1(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_1
    {
        let h = ctx.has(Item::Amagi_Stronghold_Boulder_1);
        edict.insert("Amagi_Stronghold_Boulder_1", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Boulder_1"])
    }
}
pub fn explain_amagi_stronghold_boulder_1_and_underwater_movement_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_1 and Underwater_Movement and ($grab or $climb)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Amagi_Stronghold_Boulder_1);
                edict.insert("Amagi_Stronghold_Boulder_1", format!("{}", h));
                (h, vec!["Amagi_Stronghold_Boulder_1"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_stronghold_boulder_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_2
    {
        let h = ctx.has(Item::Amagi_Stronghold_Boulder_2);
        edict.insert("Amagi_Stronghold_Boulder_2", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Boulder_2"])
    }
}
pub fn explain_amagi_stronghold_boulder_2_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_2 and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Amagi_Stronghold_Boulder_2);
            edict.insert("Amagi_Stronghold_Boulder_2", format!("{}", h));
            (h, vec!["Amagi_Stronghold_Boulder_2"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_stronghold_wall_1(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Wall_1
    {
        let h = ctx.has(Item::Amagi_Stronghold_Wall_1);
        edict.insert("Amagi_Stronghold_Wall_1", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Wall_1"])
    }
}
pub fn explain_amagi_stronghold_wall_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Wall_2
    {
        let h = ctx.has(Item::Amagi_Stronghold_Wall_2);
        edict.insert("Amagi_Stronghold_Wall_2", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Wall_2"])
    }
}
pub fn explain_amagi_west_lake_surface_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_West_Lake_Surface_Wall
    {
        let h = ctx.has(Item::Amagi_West_Lake_Surface_Wall);
        edict.insert("Amagi_West_Lake_Surface_Wall", format!("{}", h));
        (h, vec!["Amagi_West_Lake_Surface_Wall"])
    }
}
pub fn explain_annuna__east_bridge__tower_east_ledge__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo
    {
        let val = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_annuna__east_bridge__tower_east_ledge__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__tower_mid_air_west__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__tower_secret__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo
    {
        let val = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_annuna__east_bridge__tower_secret__ex__tower_east_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__tower_secret__ex__tower_mid_air_east_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__tower_secret__ex__tower_mid_air_west_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__tower_secret__ex__tower_peak_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and $grab
    {
        let mut left = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__east_bridge__tower_secret__ex__tower_peak_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and $hook
    {
        let mut left = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__east_bridge__tower_secret__ex__tower_west_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__tower_west_ledge__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo
    {
        let val = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_annuna__east_bridge__tower_west_ledge__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__west_climb__cache__ex__switch_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.annuna__west_climb__ctx__door_opened();
        edict.insert("^annuna__west_climb__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^annuna__west_climb__ctx__door_opened"])
    }
}
pub fn explain_annuna__west_climb__switch_ledge__ex__cache_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.annuna__west_climb__ctx__door_opened();
        edict.insert("^annuna__west_climb__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^annuna__west_climb__ctx__door_opened"])
    }
}
pub fn explain_annuna__west_climb__switch_ledge__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and not ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
            edict.insert("$unlock4", format!("{:?}", res));
            refs.push("$unlock4");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.annuna__west_climb__ctx__door_opened();
                    edict.insert("^annuna__west_climb__ctx__door_opened", format!("{:?}", r));
                    (r, vec!["^annuna__west_climb__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_East_Bridge_Gate
    {
        let h = ctx.has(Item::Annuna_East_Bridge_Gate);
        edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
        (h, vec!["Annuna_East_Bridge_Gate"])
    }
}
pub fn explain_annuna_mirror_match_switch(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Mirror_Match_Switch
    {
        let h = ctx.has(Item::Annuna_Mirror_Match_Switch);
        edict.insert("Annuna_Mirror_Match_Switch", format!("{}", h));
        (h, vec!["Annuna_Mirror_Match_Switch"])
    }
}
pub fn explain_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman
    {
        let h = ctx.has(Item::Anuman);
        edict.insert("Anuman", format!("{}", h));
        (h, vec!["Anuman"])
    }
}
pub fn explain_anuman_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anunna_vertical_room_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anunna_Vertical_Room_Gate
    {
        let h = ctx.has(Item::Anunna_Vertical_Room_Gate);
        edict.insert("Anunna_Vertical_Room_Gate", format!("{}", h));
        (h, vec!["Anunna_Vertical_Room_Gate"])
    }
}
pub fn explain_apocalypse_bomb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Apocalypse_Bomb
    {
        let h = ctx.has(Item::Apocalypse_Bomb);
        edict.insert("Apocalypse_Bomb", format!("{}", h));
        (h, vec!["Apocalypse_Bomb"])
    }
}
pub fn explain_block_clip_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip and not Ebih_Waterfall_Block_Left
    {
        let mut left = {
            let (res, mut refs) = hexplain__block_clip!(ctx, world, edict);
            edict.insert("$block_clip", format!("{:?}", res));
            refs.push("$block_clip");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Left);
                edict.insert("Ebih_Waterfall_Block_Left", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Left"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_block_clip_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip and not Ebih_Waterfall_Block_Right
    {
        let mut left = {
            let (res, mut refs) = hexplain__block_clip!(ctx, world, edict);
            edict.insert("$block_clip", format!("{:?}", res));
            refs.push("$block_clip");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Right);
                edict.insert("Ebih_Waterfall_Block_Right", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Right"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_block_clip_escape_and_not_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip_escape and not Uhrum_Annuna_Corridor_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__block_clip_escape!(ctx, world, edict);
            edict.insert("$block_clip_escape", format!("{:?}", res));
            refs.push("$block_clip_escape");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Uhrum_Annuna_Corridor_Block);
                edict.insert("Uhrum_Annuna_Corridor_Block", format!("{}", h));
                (!h, vec!["Uhrum_Annuna_Corridor_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_boomerang(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $boomerang
    {
        let (res, mut refs) = hexplain__boomerang!(ctx, world, edict);
        edict.insert("$boomerang", format!("{:?}", res));
        refs.push("$boomerang");
        (res, refs)
    }
}
pub fn explain_boomerang1(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Boomerang
    {
        let h = ctx.has(Item::Boomerang);
        edict.insert("Boomerang", format!("{}", h));
        (h, vec!["Boomerang"])
    }
}
pub fn explain_boomerang2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Boomerang
    {
        let h = ctx.has(Item::Boomerang);
        edict.insert("Boomerang", format!("{}", h));
        (h, vec!["Boomerang"])
    }
}
pub fn explain_boomerang3(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Boomerang
    {
        let h = ctx.has(Item::Boomerang);
        edict.insert("Boomerang", format!("{}", h));
        (h, vec!["Boomerang"])
    }
}
pub fn explain_boomerang4(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Boomerang
    {
        let h = ctx.has(Item::Boomerang);
        edict.insert("Boomerang", format!("{}", h));
        (h, vec!["Boomerang"])
    }
}
pub fn explain_boomerang5(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Boomerang
    {
        let h = ctx.has(Item::Boomerang);
        edict.insert("Boomerang", format!("{}", h));
        (h, vec!["Boomerang"])
    }
}
pub fn explain_bs(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $bs
    {
        let (res, mut refs) = hexplain__bs!(ctx, world, edict);
        edict.insert("$bs", format!("{:?}", res));
        refs.push("$bs");
        (res, refs)
    }
}
pub fn explain_can_damage(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_damage
    {
        let (res, mut refs) = hexplain__can_damage!(ctx, world, edict);
        edict.insert("$can_damage", format!("{:?}", res));
        refs.push("$can_damage");
        (res, refs)
    }
}
pub fn explain_can_deploy(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy
    {
        let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
        edict.insert("$can_deploy", format!("{:?}", res));
        refs.push("$can_deploy");
        (res, refs)
    }
}
pub fn explain_can_deploy_and_drone_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Drone_Hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
            edict.insert("$can_deploy", format!("{:?}", res));
            refs.push("$can_deploy");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_can_deploy_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Slingshot_Hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
            edict.insert("$can_deploy", format!("{:?}", res));
            refs.push("$can_deploy");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_can_deploy_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_charge(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $charge
    {
        let (res, mut refs) = hexplain__charge!(ctx, world, edict);
        edict.insert("$charge", format!("{:?}", res));
        refs.push("$charge");
        (res, refs)
    }
}
pub fn explain_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb
    {
        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
        edict.insert("$climb", format!("{:?}", res));
        refs.push("$climb");
        (res, refs)
    }
}
pub fn explain_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_climb_and_can_deploy_and_hover_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and $can_deploy and Hover and Slingshot_Hook
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                    edict.insert("$climb", format!("{:?}", res));
                    refs.push("$climb");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                        edict.insert("$can_deploy", format!("{:?}", res));
                        refs.push("$can_deploy");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Hover);
                    edict.insert("Hover", format!("{}", h));
                    (h, vec!["Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_climb_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and $grab
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_climb_and_grab_and_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and $grab and Anuman
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_climb_or_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb or $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_defeat_mus_a_m20(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Defeat_MUS_A_M20
    {
        let h = ctx.has(Item::Defeat_MUS_A_M20);
        edict.insert("Defeat_MUS_A_M20", format!("{}", h));
        (h, vec!["Defeat_MUS_A_M20"])
    }
}
pub fn explain_drone_melee_damage(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Damage
    {
        let h = ctx.has(Item::Drone_Melee_Damage);
        edict.insert("Drone_Melee_Damage", format!("{}", h));
        (h, vec!["Drone_Melee_Damage"])
    }
}
pub fn explain_drone_melee_damage_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Damage_2
    {
        let h = ctx.has(Item::Drone_Melee_Damage_2);
        edict.insert("Drone_Melee_Damage_2", format!("{}", h));
        (h, vec!["Drone_Melee_Damage_2"])
    }
}
pub fn explain_drone_melee_speed(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Speed
    {
        let h = ctx.has(Item::Drone_Melee_Speed);
        edict.insert("Drone_Melee_Speed", format!("{}", h));
        (h, vec!["Drone_Melee_Speed"])
    }
}
pub fn explain_drone_melee_speed_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Speed_2
    {
        let h = ctx.has(Item::Drone_Melee_Speed_2);
        edict.insert("Drone_Melee_Speed_2", format!("{}", h));
        (h, vec!["Drone_Melee_Speed_2"])
    }
}
pub fn explain_ebih__base_camp__left_platform__move_left_platform__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $activate and not ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
            edict.insert("$activate", format!("{:?}", res));
            refs.push("$activate");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__base_camp__left_platform_moved__reset_left_platform__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $activate and ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
            edict.insert("$activate", format!("{:?}", res));
            refs.push("$activate");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                edict.insert(
                    "^ebih__base_camp__ctx__left_platform_moved",
                    format!("{:?}", r),
                );
                (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__base_camp__top_platform__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and not ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__base_camp__top_platform__ex__left_platform_moved_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_left_platform_moved
    {
        let r = ctx.ebih__base_camp__ctx__left_platform_moved();
        edict.insert(
            "^ebih__base_camp__ctx__left_platform_moved",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
    }
}
pub fn explain_ebih__base_camp__west_11__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $platform and $hook and not ^_left_platform_moved
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__platform!(ctx, world, edict);
                edict.insert("$platform", format!("{:?}", res));
                refs.push("$platform");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__base_camp__west_11__ex__left_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and not ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__drone_room__pit_left__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and ^_platform_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__drone_room__ctx__platform_moved();
                edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                (r, vec!["^ebih__drone_room__ctx__platform_moved"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__drone_room__pit_left__activate_lift_but_get_off_early__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and ^_platform_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__drone_room__ctx__platform_moved();
                edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                (r, vec!["^ebih__drone_room__ctx__platform_moved"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__drone_room__portal_exit__activate_platform__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not ^_platform_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__drone_room__ctx__platform_moved();
                    edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                    (r, vec!["^ebih__drone_room__ctx__platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__drone_room__portal_exit__ex__moving_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not ^_platform_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__drone_room__ctx__platform_moved();
                    edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                    (r, vec!["^ebih__drone_room__ctx__platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__drone_room__portal_exit__ex__moving_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not ^_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__drone_room__ctx__platform_moved();
                    edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                    (r, vec!["^ebih__drone_room__ctx__platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_east__dispenser__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and ^_platform2_moved and ($grab or $hook)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                        edict.insert("$hook", format!("{:?}", res));
                        refs.push("$hook");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_east__dispenser__ex__lower_moving_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and not ^_platform2_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_east__dispenser__ex__lower_moving_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not ^_platform2_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_east__lower_moving_platform__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and $grab and not ^_platform2_moved
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_east__lower_moving_platform__activate_ride__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not ^_platform2_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_east__moving_platform__activate_ride__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and $grab and not ^_platform1_moved
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform1_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform1_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform1_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_west__above_door__ex__below_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__ebih_west__ctx__door_open();
        edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__ebih_west__ctx__door_open"])
    }
}
pub fn explain_ebih__ebih_west__above_door__ex__refill_station_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_open or $grab
    {
        let mut left = {
            let val = {
                let r = ctx.ebih__ebih_west__ctx__door_open();
                edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__ebih_west__ctx__door_open"])
            };
            (!val.0, val.1)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_west__above_door__ex__small_gap_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_open
    {
        let val = {
            let r = ctx.ebih__ebih_west__ctx__door_open();
            edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
            (r, vec!["^ebih__ebih_west__ctx__door_open"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_ebih__ebih_west__below_door__ex__above_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__ebih_west__ctx__door_open();
                edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__ebih_west__ctx__door_open"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__ebih_west__below_door__ex__refill_station_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__ebih_west__ctx__door_open();
                edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__ebih_west__ctx__door_open"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__grid_25_10_12__door__ex__door_left_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__grid_25_10_12__ctx__door_open();
        edict.insert("^ebih__grid_25_10_12__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__grid_25_10_12__ctx__door_open"])
    }
}
pub fn explain_ebih__grid_25_10_12__door__ex__east_11_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__grid_25_10_12__ctx__door_open();
        edict.insert("^ebih__grid_25_10_12__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__grid_25_10_12__ctx__door_open"])
    }
}
pub fn explain_ebih__grid_25_10_12__door_left__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__grid_25_10_12__ctx__door_open();
        edict.insert("^ebih__grid_25_10_12__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__grid_25_10_12__ctx__door_open"])
    }
}
pub fn explain_ebih__grid_25_10_12__east_11__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__grid_25_10_12__ctx__door_open();
        edict.insert("^ebih__grid_25_10_12__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__grid_25_10_12__ctx__door_open"])
    }
}
pub fn explain_ebih__vertical_interchange__door__ex__door_east_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__vertical_interchange__ctx__door_open();
        edict.insert(
            "^ebih__vertical_interchange__ctx__door_open",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
    }
}
pub fn explain_ebih__vertical_interchange__door__ex__door_west_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__vertical_interchange__ctx__door_open();
        edict.insert(
            "^ebih__vertical_interchange__ctx__door_open",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
    }
}
pub fn explain_ebih__vertical_interchange__door_east__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__vertical_interchange__ctx__door_open();
        edict.insert(
            "^ebih__vertical_interchange__ctx__door_open",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
    }
}
pub fn explain_ebih__vertical_interchange__door_west__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__vertical_interchange__ctx__door_open();
        edict.insert(
            "^ebih__vertical_interchange__ctx__door_open",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
    }
}
pub fn explain_ebih__vertical_interchange__west_13__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and not ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__vertical_interchange__ctx__door_open();
                    edict.insert(
                        "^ebih__vertical_interchange__ctx__door_open",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__waterfall__west_door__ex__west_door_left_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_door_open
    {
        let r = ctx.ebih__waterfall__ctx__west_door_open();
        edict.insert("^ebih__waterfall__ctx__west_door_open", format!("{:?}", r));
        (r, vec!["^ebih__waterfall__ctx__west_door_open"])
    }
}
pub fn explain_ebih__waterfall__west_door__ex__west_door_right_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_door_open
    {
        let r = ctx.ebih__waterfall__ctx__west_door_open();
        edict.insert("^ebih__waterfall__ctx__west_door_open", format!("{:?}", r));
        (r, vec!["^ebih__waterfall__ctx__west_door_open"])
    }
}
pub fn explain_ebih__waterfall__west_door_left__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_door_open
    {
        let r = ctx.ebih__waterfall__ctx__west_door_open();
        edict.insert("^ebih__waterfall__ctx__west_door_open", format!("{:?}", r));
        (r, vec!["^ebih__waterfall__ctx__west_door_open"])
    }
}
pub fn explain_ebih__waterfall__west_door_right__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_door_open
    {
        let r = ctx.ebih__waterfall__ctx__west_door_open();
        edict.insert("^ebih__waterfall__ctx__west_door_open", format!("{:?}", r));
        (r, vec!["^ebih__waterfall__ctx__west_door_open"])
    }
}
pub fn explain_ebih_alu(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Alu
    {
        let h = ctx.has(Item::Ebih_Alu);
        edict.insert("Ebih_Alu", format!("{}", h));
        (h, vec!["Ebih_Alu"])
    }
}
pub fn explain_ebih_interchange_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Block
    {
        let h = ctx.has(Item::Ebih_Interchange_Block);
        edict.insert("Ebih_Interchange_Block", format!("{}", h));
        (h, vec!["Ebih_Interchange_Block"])
    }
}
pub fn explain_ebih_interchange_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate
    {
        let h = ctx.has(Item::Ebih_Interchange_Gate);
        edict.insert("Ebih_Interchange_Gate", format!("{}", h));
        (h, vec!["Ebih_Interchange_Gate"])
    }
}
pub fn explain_ebih_interchange_gate_and_ebih_interchange_block_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $grab
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_interchange_gate_and_ebih_interchange_block_and_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $hook
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_interchange_gate_and_not_ebih_interchange_block_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $grab
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (!h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_interchange_gate_and_not_ebih_interchange_block_and_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $hook
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (!h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_wasteland_door(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Wasteland_Door
    {
        let h = ctx.has(Item::Ebih_Wasteland_Door);
        edict.insert("Ebih_Wasteland_Door", format!("{}", h));
        (h, vec!["Ebih_Wasteland_Door"])
    }
}
pub fn explain_ebih_waterfall_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Waterfall_Wall
    {
        let h = ctx.has(Item::Ebih_Waterfall_Wall);
        edict.insert("Ebih_Waterfall_Wall", format!("{}", h));
        (h, vec!["Ebih_Waterfall_Wall"])
    }
}
pub fn explain_ebih_west_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_West_Block
    {
        let h = ctx.has(Item::Ebih_West_Block);
        edict.insert("Ebih_West_Block", format!("{}", h));
        (h, vec!["Ebih_West_Block"])
    }
}
pub fn explain_fast_travel(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Fast_Travel
    {
        let h = ctx.has(Item::Fast_Travel);
        edict.insert("Fast_Travel", format!("{}", h));
        (h, vec!["Fast_Travel"])
    }
}
pub fn explain_ft_main_and___map_spot_within_menu_gt_kiengir_map(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $ft_main and (^map_spot WITHIN `Menu > Kiengir Map`)
    {
        let mut left = {
            let (res, mut refs) = hexplain__ft_main!(ctx, world, edict);
            edict.insert("$ft_main", format!("{:?}", res));
            refs.push("$ft_main");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let r = data::map_spot(ctx.position());
                edict.insert("^map_spot", format!("{:?}", r));
                (get_area(r) == AreaId::Menu__Kiengir_Map, vec!["^map_spot"])
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__door__ex__switch_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__carnelian__ctx__door_opened();
        edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__door_opened"])
    }
}
pub fn explain_giguna__carnelian__door__ex__vault_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__carnelian__ctx__door_opened();
        edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__door_opened"])
    }
}
pub fn explain_giguna__carnelian__lower_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar
    {
        let val = {
            let r = ctx.giguna__carnelian__ctx__lower_susar();
            edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__lower_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__carnelian__lower_susar__ex__rock_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar
    {
        let r = ctx.giguna__carnelian__ctx__lower_susar();
        edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__lower_susar"])
    }
}
pub fn explain_giguna__carnelian__lower_susar__ex__west_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar and $grab
    {
        let mut left = {
            let r = ctx.giguna__carnelian__ctx__lower_susar();
            edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__lower_susar"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__lower_susar__ex__west_ledge_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar and $hook
    {
        let mut left = {
            let r = ctx.giguna__carnelian__ctx__lower_susar();
            edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__lower_susar"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__lower_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__carnelian__ctx__lower_susar();
                edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
                (r, vec!["^giguna__carnelian__ctx__lower_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__carnelian__ctx__door_opened();
        edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__door_opened"])
    }
}
pub fn explain_giguna__carnelian__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and not ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
            edict.insert("$unlock3", format!("{:?}", res));
            refs.push("$unlock3");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.giguna__carnelian__ctx__door_opened();
                    edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
                    (r, vec!["^giguna__carnelian__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__upper_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar
    {
        let val = {
            let r = ctx.giguna__carnelian__ctx__upper_susar();
            edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__upper_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__carnelian__upper_susar__ex__east_cliff_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__carnelian__ctx__upper_susar();
        edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__upper_susar"])
    }
}
pub fn explain_giguna__carnelian__upper_susar__ex__middle_platforms_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__carnelian__ctx__upper_susar();
        edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__upper_susar"])
    }
}
pub fn explain_giguna__carnelian__upper_susar__ex__upper_path_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__carnelian__ctx__upper_susar();
        edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__upper_susar"])
    }
}
pub fn explain_giguna__carnelian__upper_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__carnelian__ctx__upper_susar();
                edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
                (r, vec!["^giguna__carnelian__ctx__upper_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__vault__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__carnelian__ctx__door_opened();
        edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__door_opened"])
    }
}
pub fn explain_giguna__clouds__platform_start__hack_and_get_off_early__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform_and_portal and $activate
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__clouds__ctx__platform_and_portal();
                edict.insert(
                    "^giguna__clouds__ctx__platform_and_portal",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__clouds__ctx__platform_and_portal"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                edict.insert("$activate", format!("{:?}", res));
                refs.push("$activate");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__clouds__platform_start__hack_and_ride_to_portal__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform_and_portal and $activate and $attract and Breach_Sight and Remote_Drone
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let val = {
                            let r = ctx.giguna__clouds__ctx__platform_and_portal();
                            edict.insert(
                                "^giguna__clouds__ctx__platform_and_portal",
                                format!("{:?}", r),
                            );
                            (r, vec!["^giguna__clouds__ctx__platform_and_portal"])
                        };
                        (!val.0, val.1)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                            edict.insert("$activate", format!("{:?}", res));
                            refs.push("$activate");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                        edict.insert("$attract", format!("{:?}", res));
                        refs.push("$attract");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Breach_Sight);
                    edict.insert("Breach_Sight", format!("{}", h));
                    (h, vec!["Breach_Sight"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Remote_Drone);
                edict.insert("Remote_Drone", format!("{}", h));
                (h, vec!["Remote_Drone"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__clouds__platform_start__hack_deploy_ride_to_portal__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform_and_portal and $activate and $can_deploy and $attract and Breach_Sight
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let val = {
                            let r = ctx.giguna__clouds__ctx__platform_and_portal();
                            edict.insert(
                                "^giguna__clouds__ctx__platform_and_portal",
                                format!("{:?}", r),
                            );
                            (r, vec!["^giguna__clouds__ctx__platform_and_portal"])
                        };
                        (!val.0, val.1)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                            edict.insert("$activate", format!("{:?}", res));
                            refs.push("$activate");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                        edict.insert("$can_deploy", format!("{:?}", res));
                        refs.push("$can_deploy");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                    edict.insert("$attract", format!("{:?}", res));
                    refs.push("$attract");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Breach_Sight);
                edict.insert("Breach_Sight", format!("{}", h));
                (h, vec!["Breach_Sight"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__clouds__platform_stop__ex__flipside_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_platform_and_portal and ^mode == 'drone'
    {
        let mut left = {
            let r = ctx.giguna__clouds__ctx__platform_and_portal();
            edict.insert(
                "^giguna__clouds__ctx__platform_and_portal",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__clouds__ctx__platform_and_portal"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__arc_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Mist_Upgrade);
                    edict.insert("Mist_Upgrade", format!("{}", h));
                    (h, vec!["Mist_Upgrade"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__arc_passage__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and ^_combo_entered
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__arc_passage__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_combo_entered
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__lower_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__lower_susar();
            edict.insert(
                "^giguna__east_caverns__ctx__lower_susar",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__east_caverns__lower_susar__ex__east_grass_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar
    {
        let r = ctx.giguna__east_caverns__ctx__lower_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__lower_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
    }
}
pub fn explain_giguna__east_caverns__lower_susar__ex__under_lower_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar
    {
        let r = ctx.giguna__east_caverns__ctx__lower_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__lower_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
    }
}
pub fn explain_giguna__east_caverns__lower_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__lower_susar();
                edict.insert(
                    "^giguna__east_caverns__ctx__lower_susar",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__mid_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_mid_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__mid_susar();
            edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
            (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__east_caverns__mid_susar__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and ^_mid_susar
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__mid_susar();
                edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
                (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__mid_susar__ex__middle_ledge_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_mid_susar
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__mid_susar();
                edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
                (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__mid_susar__ex__middle_rock_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_mid_susar
    {
        let r = ctx.giguna__east_caverns__ctx__mid_susar();
        edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
        (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
    }
}
pub fn explain_giguna__east_caverns__mid_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_mid_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__mid_susar();
                edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
                (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__middle_rock__ex__hidden_passage_east_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and ^_combo_entered
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__midwest_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__midwest_ledge__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Mist_Upgrade);
                    edict.insert("Mist_Upgrade", format!("{}", h));
                    (h, vec!["Mist_Upgrade"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__statues_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__statues_ledge__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Mist_Upgrade);
                    edict.insert("Mist_Upgrade", format!("{}", h));
                    (h, vec!["Mist_Upgrade"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__statues_ledge__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened and $unlock2 and $range1
    {
        let mut left = {
            let mut left = {
                let val = {
                    let r = ctx.giguna__east_caverns__ctx__door_opened();
                    edict.insert(
                        "^giguna__east_caverns__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__east_caverns__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__unlock2!(ctx, world, edict);
                    edict.insert("$unlock2", format!("{:?}", res));
                    refs.push("$unlock2");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range1!(ctx, world, edict);
                edict.insert("$range1", format!("{:?}", res));
                refs.push("$range1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__east_caverns__ctx__door_opened();
        edict.insert(
            "^giguna__east_caverns__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__door_opened"])
    }
}
pub fn explain_giguna__east_caverns__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened and $unlock2
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__door_opened();
                edict.insert(
                    "^giguna__east_caverns__ctx__door_opened",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__door_opened"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__unlock2!(ctx, world, edict);
                edict.insert("$unlock2", format!("{:?}", res));
                refs.push("$unlock2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__upper_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__upper_susar();
            edict.insert(
                "^giguna__east_caverns__ctx__upper_susar",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__east_caverns__upper_susar__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar__ex__top_past_susar_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar__ex__upper_floor_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar__ex__upper_platforms_right_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar_jump_from_east__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__upper_susar();
            edict.insert(
                "^giguna__east_caverns__ctx__upper_susar",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__east_caverns__upper_susar_jump_from_east__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar_jump_from_east__ex__midwest_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar_jump_from_east__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__upper_susar();
                edict.insert(
                    "^giguna__east_caverns__ctx__upper_susar",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__upper_susar_mid_jump__ex__top_past_susar_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__east_caverns__upper_susar_mid_jump__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__upper_susar();
                edict.insert(
                    "^giguna__east_caverns__ctx__upper_susar",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__west_14__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo_entered
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__combo_entered();
            edict.insert(
                "^giguna__east_caverns__ctx__combo_entered",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__east_caverns__west_16__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__east_caverns__ctx__door_opened();
        edict.insert(
            "^giguna__east_caverns__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__door_opened"])
    }
}
pub fn explain_giguna__east_caverns__west_16__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened and $open and $range2
    {
        let mut left = {
            let mut left = {
                let val = {
                    let r = ctx.giguna__east_caverns__ctx__door_opened();
                    edict.insert(
                        "^giguna__east_caverns__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__east_caverns__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__open!(ctx, world, edict);
                    edict.insert("$open", format!("{:?}", res));
                    refs.push("$open");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                edict.insert("$range2", format!("{:?}", res));
                refs.push("$range2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__gateway__door__ex__block_left_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__gateway__ctx__door_opened();
        edict.insert("^giguna__gateway__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__gateway__ctx__door_opened"])
    }
}
pub fn explain_giguna__gateway__door__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__gateway__ctx__door_opened();
        edict.insert("^giguna__gateway__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__gateway__ctx__door_opened"])
    }
}
pub fn explain_giguna__gateway__door__ex__passage_entry_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__gateway__ctx__door_opened();
        edict.insert("^giguna__gateway__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__gateway__ctx__door_opened"])
    }
}
pub fn explain_giguna__gateway__passage_entry__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__gateway__ctx__door_opened();
        edict.insert("^giguna__gateway__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__gateway__ctx__door_opened"])
    }
}
pub fn explain_giguna__giguna_base__below_gate__ex__kari_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $grab and $climb
    {
        let mut left = {
            let mut left = {
                let r = ctx.giguna__giguna_base__ctx__door_open();
                edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
                (r, vec!["^giguna__giguna_base__ctx__door_open"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_base__below_gate__ex__kari_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $hook
    {
        let mut left = {
            let r = ctx.giguna__giguna_base__ctx__door_open();
            edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
            (r, vec!["^giguna__giguna_base__ctx__door_open"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_base__below_gate__ex__middle_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $grab and $climb
    {
        let mut left = {
            let mut left = {
                let r = ctx.giguna__giguna_base__ctx__door_open();
                edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
                (r, vec!["^giguna__giguna_base__ctx__door_open"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_base__below_gate__ex__middle_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $hook
    {
        let mut left = {
            let r = ctx.giguna__giguna_base__ctx__door_open();
            edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
            (r, vec!["^giguna__giguna_base__ctx__door_open"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_base__kari__ex__below_gate_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.giguna__giguna_base__ctx__door_open();
        edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
        (r, vec!["^giguna__giguna_base__ctx__door_open"])
    }
}
pub fn explain_giguna__giguna_base__middle_platform__ex__below_gate_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.giguna__giguna_base__ctx__door_open();
        edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
        (r, vec!["^giguna__giguna_base__ctx__door_open"])
    }
}
pub fn explain_giguna__giguna_northeast__right_column__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__giguna_northeast__ctx__door_opened();
        edict.insert(
            "^giguna__giguna_northeast__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
    }
}
pub fn explain_giguna__giguna_northeast__right_column__open_door_from_afar__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and Infection_Range_3 and not ^_door_opened
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
                edict.insert("$unlock3", format!("{:?}", res));
                refs.push("$unlock3");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Infection_Range_3);
                    edict.insert("Infection_Range_3", format!("{}", h));
                    (h, vec!["Infection_Range_3"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.giguna__giguna_northeast__ctx__door_opened();
                    edict.insert(
                        "^giguna__giguna_northeast__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_northeast__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened and ($grab or $hook)
    {
        let mut left = {
            let r = ctx.giguna__giguna_northeast__ctx__door_opened();
            edict.insert(
                "^giguna__giguna_northeast__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                        edict.insert("$hook", format!("{:?}", res));
                        refs.push("$hook");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_northeast__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and not ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
            edict.insert("$unlock3", format!("{:?}", res));
            refs.push("$unlock3");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.giguna__giguna_northeast__ctx__door_opened();
                    edict.insert(
                        "^giguna__giguna_northeast__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_northeast__vault__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__giguna_northeast__ctx__door_opened();
        edict.insert(
            "^giguna__giguna_northeast__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
    }
}
pub fn explain_giguna__giguna_northeast__vault__ex__door_2__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened and $hook
    {
        let mut left = {
            let r = ctx.giguna__giguna_northeast__ctx__door_opened();
            edict.insert(
                "^giguna__giguna_northeast__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__ruins_top__east_7__ex__east_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__east_door__ex__east_7_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__east_door__ex__portal_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__entryway__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__portal__ex__east_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__west_7__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__west_door__ex__entryway_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_top__west_door__ex__west_7_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__ruins_west__lower_ledge__destroy_kishib__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_kishib_handled and $shockwave
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__ruins_west__ctx__kishib_handled();
                edict.insert(
                    "^giguna__ruins_west__ctx__kishib_handled",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__ruins_west__ctx__kishib_handled"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__ruins_west__lower_ledge__ex__upper_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and ^_kishib_handled
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__ruins_west__ctx__kishib_handled();
                edict.insert(
                    "^giguna__ruins_west__ctx__kishib_handled",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__ruins_west__ctx__kishib_handled"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__ruins_west__lower_ledge__hack_kishib__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_kishib_handled and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__ruins_west__ctx__kishib_handled();
                edict.insert(
                    "^giguna__ruins_west__ctx__kishib_handled",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__ruins_west__ctx__kishib_handled"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__west_caverns__east_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_east_susar
    {
        let val = {
            let r = ctx.giguna__west_caverns__ctx__east_susar();
            edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
            (r, vec!["^giguna__west_caverns__ctx__east_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna__west_caverns__east_susar__ex__east_12_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_susar
    {
        let r = ctx.giguna__west_caverns__ctx__east_susar();
        edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
        (r, vec!["^giguna__west_caverns__ctx__east_susar"])
    }
}
pub fn explain_giguna__west_caverns__east_susar__ex__tunnel_fork_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_susar
    {
        let r = ctx.giguna__west_caverns__ctx__east_susar();
        edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
        (r, vec!["^giguna__west_caverns__ctx__east_susar"])
    }
}
pub fn explain_giguna__west_caverns__east_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_east_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__west_caverns__ctx__east_susar();
                edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
                (r, vec!["^giguna__west_caverns__ctx__east_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_boulder(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Boulder
    {
        let h = ctx.has(Item::Giguna_Boulder);
        edict.insert("Giguna_Boulder", format!("{}", h));
        (h, vec!["Giguna_Boulder"])
    }
}
pub fn explain_giguna_breach__sw_save__side_door__ex__west_11_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna_breach__sw_save__ctx__door_opened();
        edict.insert(
            "^giguna_breach__sw_save__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna_breach__sw_save__ctx__door_opened"])
    }
}
pub fn explain_giguna_breach__sw_save__west_11__ex__side_door_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna_breach__sw_save__ctx__door_opened();
        edict.insert(
            "^giguna_breach__sw_save__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna_breach__sw_save__ctx__door_opened"])
    }
}
pub fn explain_giguna_breach__sw_save__west_11__open_door__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened
    {
        let val = {
            let r = ctx.giguna_breach__sw_save__ctx__door_opened();
            edict.insert(
                "^giguna_breach__sw_save__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna_breach__sw_save__ctx__door_opened"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_giguna_dual_path_switch(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch
    {
        let h = ctx.has(Item::Giguna_Dual_Path_Switch);
        edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
        (h, vec!["Giguna_Dual_Path_Switch"])
    }
}
pub fn explain_giguna_dual_path_switch_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch and ($grab or $climb)
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Dual_Path_Switch);
            edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
            (h, vec!["Giguna_Dual_Path_Switch"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_dual_path_switch_and_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch and $climb
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Dual_Path_Switch);
            edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
            (h, vec!["Giguna_Dual_Path_Switch"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_dual_path_switch_and_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Dual_Path_Switch);
            edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
            (h, vec!["Giguna_Dual_Path_Switch"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_gateway_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gateway_Block
    {
        let h = ctx.has(Item::Giguna_Gateway_Block);
        edict.insert("Giguna_Gateway_Block", format!("{}", h));
        (h, vec!["Giguna_Gateway_Block"])
    }
}
pub fn explain_giguna_gateway_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gateway_Gate
    {
        let h = ctx.has(Item::Giguna_Gateway_Gate);
        edict.insert("Giguna_Gateway_Gate", format!("{}", h));
        (h, vec!["Giguna_Gateway_Gate"])
    }
}
pub fn explain_giguna_gubi(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gubi
    {
        let h = ctx.has(Item::Giguna_Gubi);
        edict.insert("Giguna_Gubi", format!("{}", h));
        (h, vec!["Giguna_Gubi"])
    }
}
pub fn explain_giguna_northeast_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Northeast_Gate
    {
        let h = ctx.has(Item::Giguna_Northeast_Gate);
        edict.insert("Giguna_Northeast_Gate", format!("{}", h));
        (h, vec!["Giguna_Northeast_Gate"])
    }
}
pub fn explain_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab
    {
        let (res, mut refs) = hexplain__grab!(ctx, world, edict);
        edict.insert("$grab", format!("{:?}", res));
        refs.push("$grab");
        (res, refs)
    }
}
pub fn explain_grab_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_and_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_and_can_deploy(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and $can_deploy
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_and_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and $climb
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_and_giguna_gateway_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Giguna_Gateway_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Gateway_Block);
                edict.insert("Giguna_Gateway_Block", format!("{}", h));
                (h, vec!["Giguna_Gateway_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_and_switch_40_12(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Switch_40_12
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Switch_40_12);
                edict.insert("Switch_40_12", format!("{}", h));
                (h, vec!["Switch_40_12"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_and_water_movement(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Water_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Water_Movement);
                edict.insert("Water_Movement", format!("{}", h));
                (h, vec!["Water_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_or_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $climb
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_or_climb_or_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $climb or $hook
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                    edict.insert("$climb", format!("{:?}", res));
                    refs.push("$climb");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_or_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_grab_or_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_health_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade
    {
        let h = ctx.has(Item::Health_Upgrade);
        edict.insert("Health_Upgrade", format!("{}", h));
        (h, vec!["Health_Upgrade"])
    }
}
pub fn explain_health_upgrade_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade_2
    {
        let h = ctx.has(Item::Health_Upgrade_2);
        edict.insert("Health_Upgrade_2", format!("{}", h));
        (h, vec!["Health_Upgrade_2"])
    }
}
pub fn explain_health_upgrade_3(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade_3
    {
        let h = ctx.has(Item::Health_Upgrade_3);
        edict.insert("Health_Upgrade_3", format!("{}", h));
        (h, vec!["Health_Upgrade_3"])
    }
}
pub fn explain_health_upgrade_4(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade_4
    {
        let h = ctx.has(Item::Health_Upgrade_4);
        edict.insert("Health_Upgrade_4", format!("{}", h));
        (h, vec!["Health_Upgrade_4"])
    }
}
pub fn explain_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook
    {
        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
        edict.insert("$hook", format!("{:?}", res));
        refs.push("$hook");
        (res, refs)
    }
}
pub fn explain_hook_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_giguna_gateway_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Giguna_Gateway_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Gateway_Block);
                edict.insert("Giguna_Gateway_Block", format!("{}", h));
                (h, vec!["Giguna_Gateway_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_hover_and_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and Underwater_Movement
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not Ebih_Waterfall_Block_Left
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Left);
                edict.insert("Ebih_Waterfall_Block_Left", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Left"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not Ebih_Waterfall_Block_Right
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Right);
                edict.insert("Ebih_Waterfall_Block_Right", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Right"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_and_water_movement(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Water_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Water_Movement);
                edict.insert("Water_Movement", format!("{}", h));
                (h, vec!["Water_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hook_or_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or $hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover
    {
        let (res, mut refs) = hexplain__hover!(ctx, world, edict);
        edict.insert("$hover", format!("{:?}", res));
        refs.push("$hover");
        (res, refs)
    }
}
pub fn explain_hover_and_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hover_and_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hover_and_hook_and_mist2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook and $mist2
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__mist2!(ctx, world, edict);
                edict.insert("$mist2", format!("{:?}", res));
                refs.push("$mist2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hover_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Mist_Upgrade
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Mist_Upgrade);
                edict.insert("Mist_Upgrade", format!("{}", h));
                (h, vec!["Mist_Upgrade"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hover_or_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover or $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_hover_or_mist2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover or $mist2
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__mist2!(ctx, world, edict);
                edict.insert("$mist2", format!("{:?}", res));
                refs.push("$mist2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect
    {
        let h = ctx.has(Item::Infect);
        edict.insert("Infect", format!("{}", h));
        (h, vec!["Infect"])
    }
}
pub fn explain_infect_and_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and Anuman
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_not_anuman(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not Anuman
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (!h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_l1(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect_L1
    {
        let h = ctx.has(Item::Infect_L1);
        edict.insert("Infect_L1", format!("{}", h));
        (h, vec!["Infect_L1"])
    }
}
pub fn explain_infect_l2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect_L2
    {
        let h = ctx.has(Item::Infect_L2);
        edict.insert("Infect_L2", format!("{}", h));
        (h, vec!["Infect_L2"])
    }
}
pub fn explain_infection_range(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infection_Range
    {
        let h = ctx.has(Item::Infection_Range);
        edict.insert("Infection_Range", format!("{}", h));
        (h, vec!["Infection_Range"])
    }
}
pub fn explain_infection_range_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infection_Range_2
    {
        let h = ctx.has(Item::Infection_Range_2);
        edict.insert("Infection_Range_2", format!("{}", h));
        (h, vec!["Infection_Range_2"])
    }
}
pub fn explain_infection_speed(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infection_Speed
    {
        let h = ctx.has(Item::Infection_Speed);
        edict.insert("Infection_Speed", format!("{}", h));
        (h, vec!["Infection_Speed"])
    }
}
pub fn explain_infinite_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
            edict.insert("$infinite_climb", format!("{:?}", res));
            refs.push("$infinite_climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infinite_climb_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and not Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
            edict.insert("$infinite_climb", format!("{:?}", res));
            refs.push("$infinite_climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (!h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infinite_climb_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and Slingshot_Hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
            edict.insert("$infinite_climb", format!("{:?}", res));
            refs.push("$infinite_climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infinite_climb_and_slingshot_hook_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and Slingshot_Hook and not Annuna_East_Bridge_Gate
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
                edict.insert("$infinite_climb", format!("{:?}", res));
                refs.push("$infinite_climb");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (!h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_irikar__basement_portal__ledge__ex__moving_platform_start_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform_moved
    {
        let val = {
            let r = ctx.irikar__basement_portal__ctx__platform_moved();
            edict.insert(
                "^irikar__basement_portal__ctx__platform_moved",
                format!("{:?}", r),
            );
            (r, vec!["^irikar__basement_portal__ctx__platform_moved"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_irikar__basement_portal__middle_platform__ex__moving_platform_end_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_platform_moved and $hook
    {
        let mut left = {
            let r = ctx.irikar__basement_portal__ctx__platform_moved();
            edict.insert(
                "^irikar__basement_portal__ctx__platform_moved",
                format!("{:?}", r),
            );
            (r, vec!["^irikar__basement_portal__ctx__platform_moved"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_irikar__basement_portal__portal_stand__ex__moving_platform_start_1__req(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform_moved
    {
        let val = {
            let r = ctx.irikar__basement_portal__ctx__platform_moved();
            edict.insert(
                "^irikar__basement_portal__ctx__platform_moved",
                format!("{:?}", r),
            );
            (r, vec!["^irikar__basement_portal__ctx__platform_moved"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_irikar_gudam(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Gudam
    {
        let h = ctx.has(Item::Irikar_Gudam);
        edict.insert("Irikar_Gudam", format!("{}", h));
        (h, vec!["Irikar_Gudam"])
    }
}
pub fn explain_irikar_royal_storage_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Royal_Storage_Wall
    {
        let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
        edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
        (h, vec!["Irikar_Royal_Storage_Wall"])
    }
}
pub fn explain_map__amagi__main_area__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi__main_area__save
    {
        let r = ctx.map__amagi__main_area__save();
        edict.insert("^map__amagi__main_area__save", format!("{:?}", r));
        (r, vec!["^map__amagi__main_area__save"])
    }
}
pub fn explain_map__annuna__center_save__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__center_save__save
    {
        let r = ctx.map__annuna__center_save__save();
        edict.insert("^map__annuna__center_save__save", format!("{:?}", r));
        (r, vec!["^map__annuna__center_save__save"])
    }
}
pub fn explain_map__annuna__factory_entrance__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__factory_entrance__save
    {
        let r = ctx.map__annuna__factory_entrance__save();
        edict.insert("^map__annuna__factory_entrance__save", format!("{:?}", r));
        (r, vec!["^map__annuna__factory_entrance__save"])
    }
}
pub fn explain_map__annuna__mirror_match__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__mirror_match__save
    {
        let r = ctx.map__annuna__mirror_match__save();
        edict.insert("^map__annuna__mirror_match__save", format!("{:?}", r));
        (r, vec!["^map__annuna__mirror_match__save"])
    }
}
pub fn explain_map__ebih__base_camp__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__base_camp__save
    {
        let r = ctx.map__ebih__base_camp__save();
        edict.insert("^map__ebih__base_camp__save", format!("{:?}", r));
        (r, vec!["^map__ebih__base_camp__save"])
    }
}
pub fn explain_map__ebih__ebih_west__lower_save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__ebih_west__lower_save
    {
        let r = ctx.map__ebih__ebih_west__lower_save();
        edict.insert("^map__ebih__ebih_west__lower_save", format!("{:?}", r));
        (r, vec!["^map__ebih__ebih_west__lower_save"])
    }
}
pub fn explain_map__ebih__ebih_west__mid_save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__ebih_west__mid_save
    {
        let r = ctx.map__ebih__ebih_west__mid_save();
        edict.insert("^map__ebih__ebih_west__mid_save", format!("{:?}", r));
        (r, vec!["^map__ebih__ebih_west__mid_save"])
    }
}
pub fn explain_map__ebih__ebih_west__upper_save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__ebih_west__upper_save
    {
        let r = ctx.map__ebih__ebih_west__upper_save();
        edict.insert("^map__ebih__ebih_west__upper_save", format!("{:?}", r));
        (r, vec!["^map__ebih__ebih_west__upper_save"])
    }
}
pub fn explain_map__giguna__giguna_base__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__giguna_base__save
    {
        let r = ctx.map__giguna__giguna_base__save();
        edict.insert("^map__giguna__giguna_base__save", format!("{:?}", r));
        (r, vec!["^map__giguna__giguna_base__save"])
    }
}
pub fn explain_map__giguna__giguna_northeast__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__giguna_northeast__save
    {
        let r = ctx.map__giguna__giguna_northeast__save();
        edict.insert("^map__giguna__giguna_northeast__save", format!("{:?}", r));
        (r, vec!["^map__giguna__giguna_northeast__save"])
    }
}
pub fn explain_map__giguna__ruins_top__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__ruins_top__save
    {
        let r = ctx.map__giguna__ruins_top__save();
        edict.insert("^map__giguna__ruins_top__save", format!("{:?}", r));
        (r, vec!["^map__giguna__ruins_top__save"])
    }
}
pub fn explain_map__giguna__ruins_west__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__ruins_west__save
    {
        let r = ctx.map__giguna__ruins_west__save();
        edict.insert("^map__giguna__ruins_west__save", format!("{:?}", r));
        (r, vec!["^map__giguna__ruins_west__save"])
    }
}
pub fn explain_map__giguna_breach__peak__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__peak__save
    {
        let r = ctx.map__giguna_breach__peak__save();
        edict.insert("^map__giguna_breach__peak__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__peak__save"])
    }
}
pub fn explain_map__giguna_breach__sw_save__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__sw_save__save
    {
        let r = ctx.map__giguna_breach__sw_save__save();
        edict.insert("^map__giguna_breach__sw_save__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__sw_save__save"])
    }
}
pub fn explain_map__glacier__revival__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier__revival__save
    {
        let r = ctx.map__glacier__revival__save();
        edict.insert("^map__glacier__revival__save", format!("{:?}", r));
        (r, vec!["^map__glacier__revival__save"])
    }
}
pub fn explain_map__irikar__hub__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar__hub__save
    {
        let r = ctx.map__irikar__hub__save();
        edict.insert("^map__irikar__hub__save", format!("{:?}", r));
        (r, vec!["^map__irikar__hub__save"])
    }
}
pub fn explain_map__irikar_breach__gauntlet__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar_breach__gauntlet__save
    {
        let r = ctx.map__irikar_breach__gauntlet__save();
        edict.insert("^map__irikar_breach__gauntlet__save", format!("{:?}", r));
        (r, vec!["^map__irikar_breach__gauntlet__save"])
    }
}
pub fn explain_map__irikar_breach__save_room__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar_breach__save_room__save
    {
        let r = ctx.map__irikar_breach__save_room__save();
        edict.insert("^map__irikar_breach__save_room__save", format!("{:?}", r));
        (r, vec!["^map__irikar_breach__save_room__save"])
    }
}
pub fn explain_map__uhrum__annuna_corridor__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__annuna_corridor__save
    {
        let r = ctx.map__uhrum__annuna_corridor__save();
        edict.insert("^map__uhrum__annuna_corridor__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__annuna_corridor__save"])
    }
}
pub fn explain_map__uhrum__save_room__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__save_room__save
    {
        let r = ctx.map__uhrum__save_room__save();
        edict.insert("^map__uhrum__save_room__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__save_room__save"])
    }
}
pub fn explain_map__uhrum__west_entrance__save(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__west_entrance__save
    {
        let r = ctx.map__uhrum__west_entrance__save();
        edict.insert("^map__uhrum__west_entrance__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__west_entrance__save"])
    }
}
pub fn explain_melee_damage(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Damage
    {
        let h = ctx.has(Item::Melee_Damage);
        edict.insert("Melee_Damage", format!("{}", h));
        (h, vec!["Melee_Damage"])
    }
}
pub fn explain_melee_damage_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Damage_2
    {
        let h = ctx.has(Item::Melee_Damage_2);
        edict.insert("Melee_Damage_2", format!("{}", h));
        (h, vec!["Melee_Damage_2"])
    }
}
pub fn explain_melee_speed(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Speed
    {
        let h = ctx.has(Item::Melee_Speed);
        edict.insert("Melee_Speed", format!("{}", h));
        (h, vec!["Melee_Speed"])
    }
}
pub fn explain_melee_speed_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Speed_2
    {
        let h = ctx.has(Item::Melee_Speed_2);
        edict.insert("Melee_Speed_2", format!("{}", h));
        (h, vec!["Melee_Speed_2"])
    }
}
pub fn explain_mist2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $mist2
    {
        let (res, mut refs) = hexplain__mist2!(ctx, world, edict);
        edict.insert("$mist2", format!("{:?}", res));
        refs.push("$mist2");
        (res, refs)
    }
}
pub fn explain_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Mist_Upgrade
    {
        let h = ctx.has(Item::Mist_Upgrade);
        edict.insert("Mist_Upgrade", format!("{}", h));
        (h, vec!["Mist_Upgrade"])
    }
}
pub fn explain_mode_eq_drone(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone'
    {
        let mut refs = vec!["^mode"];
        let mut left = {
            let r = ctx.mode();
            edict.insert("^mode", format!("{:?}", r));
            (r, vec!["^mode"])
        };
        let right = enums::Mode::Drone;
        edict.insert("^mode", format!("{}", left.0));
        refs.append(&mut left.1);
        (left.0 == right, refs)
    }
}
pub fn explain_mode_eq_drone_and_breach_sight(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Breach_Sight
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Breach_Sight);
                edict.insert("Breach_Sight", format!("{}", h));
                (h, vec!["Breach_Sight"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_ebih_wasteland_passage_h(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Ebih_Wasteland_Passage_H
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Wasteland_Passage_H);
                edict.insert("Ebih_Wasteland_Passage_H", format!("{}", h));
                (h, vec!["Ebih_Wasteland_Passage_H"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Left
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Left);
                edict.insert("Ebih_Waterfall_Block_Left", format!("{}", h));
                (h, vec!["Ebih_Waterfall_Block_Left"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Right
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Right);
                edict.insert("Ebih_Waterfall_Block_Right", format!("{}", h));
                (h, vec!["Ebih_Waterfall_Block_Right"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_giguna_dual_path_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Giguna_Dual_Path_Wall
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Dual_Path_Wall);
                edict.insert("Giguna_Dual_Path_Wall", format!("{}", h));
                (h, vec!["Giguna_Dual_Path_Wall"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_mist2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and $mist2
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__mist2!(ctx, world, edict);
                edict.insert("$mist2", format!("{:?}", res));
                refs.push("$mist2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Mist_Upgrade
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Mist_Upgrade);
                edict.insert("Mist_Upgrade", format!("{}", h));
                (h, vec!["Mist_Upgrade"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_sniper_valley_rock_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Sniper_Valley_Rock_2
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Sniper_Valley_Rock_2);
                edict.insert("Sniper_Valley_Rock_2", format!("{}", h));
                (h, vec!["Sniper_Valley_Rock_2"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_ne_drone(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode != 'drone'
    {
        let mut refs = vec!["^mode"];
        let mut left = {
            let r = ctx.mode();
            edict.insert("^mode", format!("{:?}", r));
            (r, vec!["^mode"])
        };
        let right = enums::Mode::Drone;
        edict.insert("^mode", format!("{}", left.0));
        refs.append(&mut left.1);
        (left.0 != right, refs)
    }
}
pub fn explain_more_refills(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $more_refills
    {
        let (res, mut refs) = hexplain__more_refills!(ctx, world, edict);
        edict.insert("$more_refills", format!("{:?}", res));
        refs.push("$more_refills");
        (res, refs)
    }
}
pub fn explain_nanite_mist(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nanite_Mist
    {
        let h = ctx.has(Item::Nanite_Mist);
        edict.insert("Nanite_Mist", format!("{}", h));
        (h, vec!["Nanite_Mist"])
    }
}
pub fn explain_nanite_mist_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nanite_Mist and Mist_Upgrade
    {
        let mut left = {
            let h = ctx.has(Item::Nanite_Mist);
            edict.insert("Nanite_Mist", format!("{}", h));
            (h, vec!["Nanite_Mist"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Mist_Upgrade);
                edict.insert("Mist_Upgrade", format!("{}", h));
                (h, vec!["Mist_Upgrade"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_nano_points(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nano_Points
    {
        let h = ctx.has(Item::Nano_Points);
        edict.insert("Nano_Points", format!("{}", h));
        (h, vec!["Nano_Points"])
    }
}
pub fn explain_nano_points_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nano_Points_2
    {
        let h = ctx.has(Item::Nano_Points_2);
        edict.insert("Nano_Points_2", format!("{}", h));
        (h, vec!["Nano_Points_2"])
    }
}
pub fn explain_not_amashilama(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT Amashilama
    {
        let h = ctx.has(Item::Amashilama);
        edict.insert("Amashilama", format!("{}", h));
        (!h, vec!["Amashilama"])
    }
}
pub fn explain_not_ebih_interchange_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Ebih_Interchange_Block
    {
        let h = ctx.has(Item::Ebih_Interchange_Block);
        edict.insert("Ebih_Interchange_Block", format!("{}", h));
        (!h, vec!["Ebih_Interchange_Block"])
    }
}
pub fn explain_not_ebih_waterfall_wall_and_nanite_mist_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Ebih_Waterfall_Wall and Nanite_Mist and Mist_Upgrade
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Waterfall_Wall);
                edict.insert("Ebih_Waterfall_Wall", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Wall"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Nanite_Mist);
                    edict.insert("Nanite_Mist", format!("{}", h));
                    (h, vec!["Nanite_Mist"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Mist_Upgrade);
                edict.insert("Mist_Upgrade", format!("{}", h));
                (h, vec!["Mist_Upgrade"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar_royal_storage_wall_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Irikar_Royal_Storage_Wall and Mist_Upgrade
    {
        let mut left = {
            let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
            edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
            (!h, vec!["Irikar_Royal_Storage_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Mist_Upgrade);
                edict.insert("Mist_Upgrade", format!("{}", h));
                (h, vec!["Mist_Upgrade"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar_royal_storage_wall_and_shockwave(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Irikar_Royal_Storage_Wall and $shockwave
    {
        let mut left = {
            let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
            edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
            (!h, vec!["Irikar_Royal_Storage_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_separation_or_defeat_indra(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT Separation or Defeat_Indra
    {
        let mut left = {
            let h = ctx.has(Item::Separation);
            edict.insert("Separation", format!("{}", h));
            (!h, vec!["Separation"])
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Defeat_Indra);
                edict.insert("Defeat_Indra", format!("{}", h));
                (h, vec!["Defeat_Indra"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Slingshot_Hook
    {
        let h = ctx.has(Item::Slingshot_Hook);
        edict.insert("Slingshot_Hook", format!("{}", h));
        (!h, vec!["Slingshot_Hook"])
    }
}
pub fn explain_not_within_menu_and_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and Anuman and ^mode != 'drone'
    {
        let mut left = {
            let mut left = {
                let r = ctx.position();
                edict.insert("^position", format!("{:?}", r));
                (
                    match get_region(r) {
                        RegionId::Menu => false,
                        _ => true,
                    },
                    vec!["^position"],
                )
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_can_deploy(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and $can_deploy
    {
        let mut left = {
            let r = ctx.position();
            edict.insert("^position", format!("{:?}", r));
            (
                match get_region(r) {
                    RegionId::Menu => false,
                    _ => true,
                },
                vec!["^position"],
            )
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_flasks_gt_0(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and ^flasks > 0
    {
        let mut left = {
            let r = ctx.position();
            edict.insert("^position", format!("{:?}", r));
            (
                match get_region(r) {
                    RegionId::Menu => false,
                    _ => true,
                },
                vec!["^position"],
            )
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^flasks", "0"];
                let mut left = {
                    let r = ctx.flasks();
                    edict.insert("^flasks", format!("{:?}", r));
                    (r, vec!["^flasks"])
                };
                let mut right = (0, vec![]);
                edict.insert("^flasks", format!("{:?}", left.0));
                edict.insert("0", format!("{:?}", right.0));
                refs.append(&mut left.1);
                refs.append(&mut right.1);
                (Into::<i32>::into(left.0) > right.0.into(), refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_ft_main_and_can_recall_and___map_spot_not_within_default(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and $ft_main and $can_recall and (^map_spot NOT WITHIN $default)
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let r = ctx.position();
                    edict.insert("^position", format!("{:?}", r));
                    (
                        match get_region(r) {
                            RegionId::Menu => false,
                            _ => true,
                        },
                        vec!["^position"],
                    )
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__ft_main!(ctx, world, edict);
                        edict.insert("$ft_main", format!("{:?}", res));
                        refs.push("$ft_main");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__can_recall!(ctx, world, edict);
                    edict.insert("$can_recall", format!("{:?}", res));
                    refs.push("$can_recall");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut refs = vec!["^map_spot"];
                let r = data::map_spot(ctx.position());
                let mut f = (Default::default(), vec![]);
                edict.insert("$default", format!("{}", f.0));
                refs.append(&mut f.1);
                edict.insert("^map_spot", format!("{:?}", r));
                (r != f.0, refs)
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_realm_ne_breach_and_anuman_and_mode_eq_drone(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and ^realm != 'breach' and Anuman and ^mode == 'drone'
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let r = ctx.position();
                    edict.insert("^position", format!("{:?}", r));
                    (
                        match get_region(r) {
                            RegionId::Menu => false,
                            _ => true,
                        },
                        vec!["^position"],
                    )
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let mut refs = vec!["^realm"];
                        let mut left = {
                            let r = data::realm(ctx.position());
                            edict.insert("^realm", format!("{:?}", r));
                            (r, vec!["^realm"])
                        };
                        let right = enums::Realm::Breach;
                        edict.insert("^realm", format!("{}", left.0));
                        refs.append(&mut left.1);
                        (left.0 != right, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_realm_ne_breach_and_can_recall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and ^realm != 'breach' and $can_recall
    {
        let mut left = {
            let mut left = {
                let r = ctx.position();
                edict.insert("^position", format!("{:?}", r));
                (
                    match get_region(r) {
                        RegionId::Menu => false,
                        _ => true,
                    },
                    vec!["^position"],
                )
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^realm"];
                    let mut left = {
                        let r = data::realm(ctx.position());
                        edict.insert("^realm", format!("{:?}", r));
                        (r, vec!["^realm"])
                    };
                    let right = enums::Realm::Breach;
                    edict.insert("^realm", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 != right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_recall!(ctx, world, edict);
                edict.insert("$can_recall", format!("{:?}", res));
                refs.push("$can_recall");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_offset(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $offset
    {
        let (res, mut refs) = hexplain__offset!(ctx, world, edict);
        edict.insert("$offset", format!("{:?}", res));
        refs.push("$offset");
        (res, refs)
    }
}
pub fn explain_open(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open
    {
        let (res, mut refs) = hexplain__open!(ctx, world, edict);
        edict.insert("$open", format!("{:?}", res));
        refs.push("$open");
        (res, refs)
    }
}
pub fn explain_open_and_range1(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range1
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range1!(ctx, world, edict);
                edict.insert("$range1", format!("{:?}", res));
                refs.push("$range1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_open_and_range2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range2
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                edict.insert("$range2", format!("{:?}", res));
                refs.push("$range2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_open_and_range3(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range3
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range3!(ctx, world, edict);
                edict.insert("$range3", format!("{:?}", res));
                refs.push("$range3");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_overheat(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $overheat
    {
        let (res, mut refs) = hexplain__overheat!(ctx, world, edict);
        edict.insert("$overheat", format!("{:?}", res));
        refs.push("$overheat");
        (res, refs)
    }
}
pub fn explain_overheat_and_can_damage(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $overheat and $can_damage
    {
        let mut left = {
            let (res, mut refs) = hexplain__overheat!(ctx, world, edict);
            edict.insert("$overheat", format!("{:?}", res));
            refs.push("$overheat");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_damage!(ctx, world, edict);
                edict.insert("$can_damage", format!("{:?}", res));
                refs.push("$can_damage");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_platform_and_hook_and_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $platform and $hook and $hover
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__platform!(ctx, world, edict);
                edict.insert("$platform", format!("{:?}", res));
                refs.push("$platform");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ranged_damage(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Damage
    {
        let h = ctx.has(Item::Ranged_Damage);
        edict.insert("Ranged_Damage", format!("{}", h));
        (h, vec!["Ranged_Damage"])
    }
}
pub fn explain_ranged_damage_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Damage_2
    {
        let h = ctx.has(Item::Ranged_Damage_2);
        edict.insert("Ranged_Damage_2", format!("{}", h));
        (h, vec!["Ranged_Damage_2"])
    }
}
pub fn explain_ranged_speed(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Speed
    {
        let h = ctx.has(Item::Ranged_Speed);
        edict.insert("Ranged_Speed", format!("{}", h));
        (h, vec!["Ranged_Speed"])
    }
}
pub fn explain_ranged_speed_2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Speed_2
    {
        let h = ctx.has(Item::Ranged_Speed_2);
        edict.insert("Ranged_Speed_2", format!("{}", h));
        (h, vec!["Ranged_Speed_2"])
    }
}
pub fn explain_realm_eq_breach(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^realm == 'breach'
    {
        let mut refs = vec!["^realm"];
        let mut left = {
            let r = data::realm(ctx.position());
            edict.insert("^realm", format!("{:?}", r));
            (r, vec!["^realm"])
        };
        let right = enums::Realm::Breach;
        edict.insert("^realm", format!("{}", left.0));
        refs.append(&mut left.1);
        (left.0 == right, refs)
    }
}
pub fn explain_realm_eq_breach_and_exit_breach_and___flipside_not_within_default(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^realm == 'breach' and Exit_Breach and (^flipside NOT WITHIN $default)
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^realm"];
                let mut left = {
                    let r = data::realm(ctx.position());
                    edict.insert("^realm", format!("{:?}", r));
                    (r, vec!["^realm"])
                };
                let right = enums::Realm::Breach;
                edict.insert("^realm", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Exit_Breach);
                    edict.insert("Exit_Breach", format!("{}", h));
                    (h, vec!["Exit_Breach"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut refs = vec!["^flipside"];
                let r = data::flipside(ctx.position());
                let mut f = (Default::default(), vec![]);
                edict.insert("$default", format!("{}", f.0));
                refs.append(&mut f.1);
                edict.insert("^flipside", format!("{:?}", r));
                (r != f.0, refs)
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_realm_in___main_interior_emergence_and_amashilama(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^realm IN ['main', 'interior', 'emergence'] and Amashilama
    {
        let mut left = {
            let r = data::realm(ctx.position());
            edict.insert("^realm", format!("{:?}", r));
            (
                matches!(
                    r,
                    enums::Realm::Main | enums::Realm::Interior | enums::Realm::Emergence
                ),
                vec!["^realm"],
            )
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Amashilama);
                edict.insert("Amashilama", format!("{}", h));
                (h, vec!["Amashilama"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_remote_drone(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Remote_Drone
    {
        let h = ctx.has(Item::Remote_Drone);
        edict.insert("Remote_Drone", format!("{}", h));
        (h, vec!["Remote_Drone"])
    }
}
pub fn explain_separation(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Separation
    {
        let h = ctx.has(Item::Separation);
        edict.insert("Separation", format!("{}", h));
        (h, vec!["Separation"])
    }
}
pub fn explain_separation_and_not_defeat_indra_and_mist2(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Separation and NOT Defeat_Indra and $mist2
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Separation);
                edict.insert("Separation", format!("{}", h));
                (h, vec!["Separation"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Defeat_Indra);
                    edict.insert("Defeat_Indra", format!("{}", h));
                    (!h, vec!["Defeat_Indra"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__mist2!(ctx, world, edict);
                edict.insert("$mist2", format!("{:?}", res));
                refs.push("$mist2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_shockwave(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave
    {
        let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
        edict.insert("$shockwave", format!("{:?}", res));
        refs.push("$shockwave");
        (res, refs)
    }
}
pub fn explain_shockwave_and_not_defeat_mus_a_m20(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave and not Defeat_MUS_A_M20
    {
        let mut left = {
            let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
            edict.insert("$shockwave", format!("{:?}", res));
            refs.push("$shockwave");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Defeat_MUS_A_M20);
                edict.insert("Defeat_MUS_A_M20", format!("{}", h));
                (!h, vec!["Defeat_MUS_A_M20"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_sniper_valley_rock_1(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Sniper_Valley_Rock_1
    {
        let h = ctx.has(Item::Sniper_Valley_Rock_1);
        edict.insert("Sniper_Valley_Rock_1", format!("{}", h));
        (h, vec!["Sniper_Valley_Rock_1"])
    }
}
pub fn explain_spin(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $spin
    {
        let (res, mut refs) = hexplain__spin!(ctx, world, edict);
        edict.insert("$spin", format!("{:?}", res));
        refs.push("$spin");
        (res, refs)
    }
}
pub fn explain_station_power(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Station_Power
    {
        let h = ctx.has(Item::Station_Power);
        edict.insert("Station_Power", format!("{}", h));
        (h, vec!["Station_Power"])
    }
}
pub fn explain_switch_36_11(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Switch_36_11
    {
        let h = ctx.has(Item::Switch_36_11);
        edict.insert("Switch_36_11", format!("{}", h));
        (h, vec!["Switch_36_11"])
    }
}
pub fn explain_switch_40_12(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Switch_40_12
    {
        let h = ctx.has(Item::Switch_40_12);
        edict.insert("Switch_40_12", format!("{}", h));
        (h, vec!["Switch_40_12"])
    }
}
pub fn explain_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Annuna_Corridor_Block
    {
        let h = ctx.has(Item::Uhrum_Annuna_Corridor_Block);
        edict.insert("Uhrum_Annuna_Corridor_Block", format!("{}", h));
        (h, vec!["Uhrum_Annuna_Corridor_Block"])
    }
}
pub fn explain_uhrum_waterfall_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfall_Wall
    {
        let h = ctx.has(Item::Uhrum_Waterfall_Wall);
        edict.insert("Uhrum_Waterfall_Wall", format!("{}", h));
        (h, vec!["Uhrum_Waterfall_Wall"])
    }
}
pub fn explain_uhrum_waterfalls_block(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfalls_Block
    {
        let h = ctx.has(Item::Uhrum_Waterfalls_Block);
        edict.insert("Uhrum_Waterfalls_Block", format!("{}", h));
        (h, vec!["Uhrum_Waterfalls_Block"])
    }
}
pub fn explain_uhrum_waterfalls_block_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfalls_Block and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Waterfalls_Block);
            edict.insert("Uhrum_Waterfalls_Block", format!("{}", h));
            (h, vec!["Uhrum_Waterfalls_Block"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_waterfalls_block_and_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfalls_Block and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Waterfalls_Block);
            edict.insert("Uhrum_Waterfalls_Block", format!("{}", h));
            (h, vec!["Uhrum_Waterfalls_Block"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_west_entrance_gate(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Gate
    {
        let h = ctx.has(Item::Uhrum_West_Entrance_Gate);
        edict.insert("Uhrum_West_Entrance_Gate", format!("{}", h));
        (h, vec!["Uhrum_West_Entrance_Gate"])
    }
}
pub fn explain_uhrum_west_entrance_gate_and_hover(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Gate and $hover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_West_Entrance_Gate);
            edict.insert("Uhrum_West_Entrance_Gate", format!("{}", h));
            (h, vec!["Uhrum_West_Entrance_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_west_entrance_lower_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Lower_Wall
    {
        let h = ctx.has(Item::Uhrum_West_Entrance_Lower_Wall);
        edict.insert("Uhrum_West_Entrance_Lower_Wall", format!("{}", h));
        (h, vec!["Uhrum_West_Entrance_Lower_Wall"])
    }
}
pub fn explain_uhrum_west_entrance_upper_wall(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Upper_Wall
    {
        let h = ctx.has(Item::Uhrum_West_Entrance_Upper_Wall);
        edict.insert("Uhrum_West_Entrance_Upper_Wall", format!("{}", h));
        (h, vec!["Uhrum_West_Entrance_Upper_Wall"])
    }
}
pub fn explain_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement
    {
        let h = ctx.has(Item::Underwater_Movement);
        edict.insert("Underwater_Movement", format!("{}", h));
        (h, vec!["Underwater_Movement"])
    }
}
pub fn explain_underwater_movement_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and ($grab or $climb)
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_grab(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_hook(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_within_antarctica(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // WITHIN `Antarctica`
    {
        let r = ctx.position();
        edict.insert("^position", format!("{:?}", r));
        (
            match get_region(r) {
                RegionId::Antarctica => true,
                _ => false,
            },
            vec!["^position"],
        )
    }
}
pub fn explain_within_menu_gt_upgrade_menu(
    ctx: &Context,
    world: &graph::World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // WITHIN `Menu > Upgrade Menu`
    {
        let r = ctx.position();
        edict.insert("^position", format!("{:?}", r));
        (
            match get_area(r) {
                AreaId::Menu__Upgrade_Menu => true,
                _ => false,
            },
            vec!["^position"],
        )
    }
}
pub fn observe_access___all_urns_all_weapons_other_items_all_notes_all_health_all_flasks(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [$all_urns, $all_weapons, $other_items, $all_notes, $all_health, $all_flasks]
    hobserve__all_urns!(ctx, world, full_obs)
        && hobserve__all_weapons!(ctx, world, full_obs)
        && hobserve__other_items!(ctx, world, full_obs)
        && hobserve__all_notes!(ctx, world, full_obs)
        && hobserve__all_health!(ctx, world, full_obs)
        && hobserve__all_flasks!(ctx, world, full_obs)
}
pub fn observe_access___escape_objective(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Escape, $objective]
    ({
        full_obs.observe_escape();
        ctx.has(Item::Escape)
    }) && robserve__objective!(ctx, world, full_obs)
}
pub fn observe_access___objective(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [$objective]
    robserve__objective!(ctx, world, full_obs)
}
pub fn observe_access___remote_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Remote_Drone]
    ({
        full_obs.observe_remote_drone();
        ctx.has(Item::Remote_Drone)
    })
}
pub fn observe_access___remote_drone_flask__6(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Remote_Drone, Flask{6}]
    ({
        full_obs.observe_remote_drone();
        ctx.has(Item::Remote_Drone)
    }) && ({
        full_obs.observe_flask(IntegerObservation::Ge(6));
        ctx.count(Item::Flask) >= 6
    })
}
pub fn observe_access_activate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $activate
    hobserve__activate!(ctx, world, full_obs)
}
pub fn observe_access_amagi__main_area__carving__ex__secret_outcropping_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and ($grab or $climb)
    ({
        full_obs.observe_amagi__main_area__ctx__combo();
        ctx.amagi__main_area__ctx__combo()
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_amagi__main_area__carving__ex__secret_outcropping_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and $hook
    ({
        full_obs.observe_amagi__main_area__ctx__combo();
        ctx.amagi__main_area__ctx__combo()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_amagi__main_area__carving__key_combo__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo
    !({
        full_obs.observe_amagi__main_area__ctx__combo();
        ctx.amagi__main_area__ctx__combo()
    })
}
pub fn observe_access_amagi_dragon_eye_passage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Dragon_Eye_Passage
    {
        full_obs.observe_amagi_dragon_eye_passage();
        ctx.has(Item::Amagi_Dragon_Eye_Passage)
    }
}
pub fn observe_access_amagi_stronghold_boulder_1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_1
    {
        full_obs.observe_amagi_stronghold_boulder_1();
        ctx.has(Item::Amagi_Stronghold_Boulder_1)
    }
}
pub fn observe_access_amagi_stronghold_boulder_1_and_underwater_movement_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_1 and Underwater_Movement and ($grab or $climb)
    (({
        full_obs.observe_amagi_stronghold_boulder_1();
        ctx.has(Item::Amagi_Stronghold_Boulder_1)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })) && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_amagi_stronghold_boulder_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_2
    {
        full_obs.observe_amagi_stronghold_boulder_2();
        ctx.has(Item::Amagi_Stronghold_Boulder_2)
    }
}
pub fn observe_access_amagi_stronghold_boulder_2_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_2 and $grab
    ({
        full_obs.observe_amagi_stronghold_boulder_2();
        ctx.has(Item::Amagi_Stronghold_Boulder_2)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_amagi_stronghold_wall_1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Wall_1
    {
        full_obs.observe_amagi_stronghold_wall_1();
        ctx.has(Item::Amagi_Stronghold_Wall_1)
    }
}
pub fn observe_access_amagi_stronghold_wall_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Wall_2
    {
        full_obs.observe_amagi_stronghold_wall_2();
        ctx.has(Item::Amagi_Stronghold_Wall_2)
    }
}
pub fn observe_access_amagi_west_lake_surface_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_West_Lake_Surface_Wall
    {
        full_obs.observe_amagi_west_lake_surface_wall();
        ctx.has(Item::Amagi_West_Lake_Surface_Wall)
    }
}
pub fn observe_access_annuna__east_bridge__tower_east_ledge__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo
    !({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    })
}
pub fn observe_access_annuna__east_bridge__tower_east_ledge__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__tower_mid_air_west__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__tower_secret__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo
    !({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    })
}
pub fn observe_access_annuna__east_bridge__tower_secret__ex__tower_east_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__tower_secret__ex__tower_mid_air_east_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__tower_secret__ex__tower_mid_air_west_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__tower_secret__ex__tower_peak_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and $grab
    ({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__east_bridge__tower_secret__ex__tower_peak_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and $hook
    ({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__east_bridge__tower_secret__ex__tower_west_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__tower_west_ledge__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo
    !({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    })
}
pub fn observe_access_annuna__east_bridge__tower_west_ledge__ex__tower_secret_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__west_climb__cache__ex__switch_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_annuna__west_climb__ctx__door_opened();
        ctx.annuna__west_climb__ctx__door_opened()
    }
}
pub fn observe_access_annuna__west_climb__switch_ledge__ex__cache_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_annuna__west_climb__ctx__door_opened();
        ctx.annuna__west_climb__ctx__door_opened()
    }
}
pub fn observe_access_annuna__west_climb__switch_ledge__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and not ^_door_opened
    (hobserve__unlock4!(ctx, world, full_obs)
        && (!({
            full_obs.observe_annuna__west_climb__ctx__door_opened();
            ctx.annuna__west_climb__ctx__door_opened()
        })))
}
pub fn observe_access_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_East_Bridge_Gate
    {
        full_obs.observe_annuna_east_bridge_gate();
        ctx.has(Item::Annuna_East_Bridge_Gate)
    }
}
pub fn observe_access_annuna_mirror_match_switch(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Mirror_Match_Switch
    {
        full_obs.observe_annuna_mirror_match_switch();
        ctx.has(Item::Annuna_Mirror_Match_Switch)
    }
}
pub fn observe_access_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman
    {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }
}
pub fn observe_access_anuman_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and $grab
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_anunna_vertical_room_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anunna_Vertical_Room_Gate
    {
        full_obs.observe_anunna_vertical_room_gate();
        ctx.has(Item::Anunna_Vertical_Room_Gate)
    }
}
pub fn observe_access_apocalypse_bomb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Apocalypse_Bomb
    {
        full_obs.observe_apocalypse_bomb();
        ctx.has(Item::Apocalypse_Bomb)
    }
}
pub fn observe_access_block_clip_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Left
    (hobserve__block_clip!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_left();
            !ctx.has(Item::Ebih_Waterfall_Block_Left)
        }))
}
pub fn observe_access_block_clip_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Right
    (hobserve__block_clip!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_right();
            !ctx.has(Item::Ebih_Waterfall_Block_Right)
        }))
}
pub fn observe_access_block_clip_escape_and_not_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip_escape and not Uhrum_Annuna_Corridor_Block
    (hobserve__block_clip_escape!(ctx, world, full_obs)
        && ({
            full_obs.observe_uhrum_annuna_corridor_block();
            !ctx.has(Item::Uhrum_Annuna_Corridor_Block)
        }))
}
pub fn observe_access_boomerang(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $boomerang
    hobserve__boomerang!(ctx, world, full_obs)
}
pub fn observe_access_boomerang1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Boomerang
    {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    }
}
pub fn observe_access_boomerang2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Boomerang
    {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    }
}
pub fn observe_access_boomerang3(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Boomerang
    {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    }
}
pub fn observe_access_boomerang4(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Boomerang
    {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    }
}
pub fn observe_access_boomerang5(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Boomerang
    {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    }
}
pub fn observe_access_bs(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $bs
    hobserve__bs!(ctx, world, full_obs)
}
pub fn observe_access_can_damage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_damage
    hobserve__can_damage!(ctx, world, full_obs)
}
pub fn observe_access_can_deploy(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy
    hobserve__can_deploy!(ctx, world, full_obs)
}
pub fn observe_access_can_deploy_and_drone_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Drone_Hover
    (hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
}
pub fn observe_access_can_deploy_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Slingshot_Hook
    (hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_can_deploy_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Slingshot_Hook and Drone_Hover
    ((hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
}
pub fn observe_access_charge(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $charge
    hobserve__charge!(ctx, world, full_obs)
}
pub fn observe_access_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb
    hobserve__climb!(ctx, world, full_obs)
}
pub fn observe_access_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and Annuna_East_Bridge_Gate
    (hobserve__climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_climb_and_can_deploy_and_hover_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and $can_deploy and Hover and Slingshot_Hook
    (((hobserve__climb!(ctx, world, full_obs) && (hobserve__can_deploy!(ctx, world, full_obs)))
        && ({
            full_obs.observe_hover();
            ctx.has(Item::Hover)
        }))
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_climb_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and $grab
    (hobserve__climb!(ctx, world, full_obs) && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_climb_and_grab_and_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and $grab and Anuman
    ((hobserve__climb!(ctx, world, full_obs) && (hobserve__grab!(ctx, world, full_obs)))
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
}
pub fn observe_access_climb_or_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb or $hook
    (hobserve__climb!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_defeat_mus_a_m20(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Defeat_MUS_A_M20
    {
        full_obs.observe_defeat_mus_a_m20();
        ctx.has(Item::Defeat_MUS_A_M20)
    }
}
pub fn observe_access_drone_melee_damage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Damage
    {
        full_obs.observe_drone_melee_damage();
        ctx.has(Item::Drone_Melee_Damage)
    }
}
pub fn observe_access_drone_melee_damage_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Damage_2
    {
        full_obs.observe_drone_melee_damage_2();
        ctx.has(Item::Drone_Melee_Damage_2)
    }
}
pub fn observe_access_drone_melee_speed(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Speed
    {
        full_obs.observe_drone_melee_speed();
        ctx.has(Item::Drone_Melee_Speed)
    }
}
pub fn observe_access_drone_melee_speed_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Speed_2
    {
        full_obs.observe_drone_melee_speed_2();
        ctx.has(Item::Drone_Melee_Speed_2)
    }
}
pub fn observe_access_ebih__base_camp__left_platform__move_left_platform__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $activate and not ^_left_platform_moved
    (hobserve__activate!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_ebih__base_camp__left_platform_moved__reset_left_platform__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $activate and ^_left_platform_moved
    (hobserve__activate!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        }))
}
pub fn observe_access_ebih__base_camp__top_platform__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and not ^_left_platform_moved
    (hobserve__hover!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_ebih__base_camp__top_platform__ex__left_platform_moved_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_left_platform_moved
    {
        full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
        ctx.ebih__base_camp__ctx__left_platform_moved()
    }
}
pub fn observe_access_ebih__base_camp__west_11__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $platform and $hook and not ^_left_platform_moved
    ((hobserve__platform!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_ebih__base_camp__west_11__ex__left_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and not ^_left_platform_moved
    (hobserve__hover!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_ebih__drone_room__pit_left__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and ^_platform_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_ebih__drone_room__ctx__platform_moved();
        ctx.ebih__drone_room__ctx__platform_moved()
    }))
}
pub fn observe_access_ebih__drone_room__pit_left__activate_lift_but_get_off_early__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and ^_platform_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_ebih__drone_room__ctx__platform_moved();
        ctx.ebih__drone_room__ctx__platform_moved()
    }))
}
pub fn observe_access_ebih__drone_room__portal_exit__activate_platform__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not ^_platform_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (!({
        full_obs.observe_ebih__drone_room__ctx__platform_moved();
        ctx.ebih__drone_room__ctx__platform_moved()
    })))
}
pub fn observe_access_ebih__drone_room__portal_exit__ex__moving_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not ^_platform_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (!({
        full_obs.observe_ebih__drone_room__ctx__platform_moved();
        ctx.ebih__drone_room__ctx__platform_moved()
    })))
}
pub fn observe_access_ebih__drone_room__portal_exit__ex__moving_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not ^_platform_moved
    (hobserve__hook!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__drone_room__ctx__platform_moved();
            ctx.ebih__drone_room__ctx__platform_moved()
        })))
}
pub fn observe_access_ebih__ebih_east__dispenser__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and ^_platform2_moved and ($grab or $hook)
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
        ctx.ebih__ebih_east__ctx__platform2_moved()
    })) && (hobserve__grab!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_ebih__ebih_east__dispenser__ex__lower_moving_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and not ^_platform2_moved
    (hobserve__grab!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
            ctx.ebih__ebih_east__ctx__platform2_moved()
        })))
}
pub fn observe_access_ebih__ebih_east__dispenser__ex__lower_moving_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not ^_platform2_moved
    (hobserve__hook!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
            ctx.ebih__ebih_east__ctx__platform2_moved()
        })))
}
pub fn observe_access_ebih__ebih_east__lower_moving_platform__activate_lift__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and $grab and not ^_platform2_moved
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
            ctx.ebih__ebih_east__ctx__platform2_moved()
        })))
}
pub fn observe_access_ebih__ebih_east__lower_moving_platform__activate_ride__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not ^_platform2_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (!({
        full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
        ctx.ebih__ebih_east__ctx__platform2_moved()
    })))
}
pub fn observe_access_ebih__ebih_east__moving_platform__activate_ride__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and $grab and not ^_platform1_moved
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_ebih__ebih_east__ctx__platform1_moved();
            ctx.ebih__ebih_east__ctx__platform1_moved()
        })))
}
pub fn observe_access_ebih__ebih_west__above_door__ex__below_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__ebih_west__ctx__door_open();
        ctx.ebih__ebih_west__ctx__door_open()
    }
}
pub fn observe_access_ebih__ebih_west__above_door__ex__refill_station_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_open or $grab
    (!({
        full_obs.observe_ebih__ebih_west__ctx__door_open();
        ctx.ebih__ebih_west__ctx__door_open()
    }) || hobserve__grab!(ctx, world, full_obs))
}
pub fn observe_access_ebih__ebih_west__above_door__ex__small_gap_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_open
    !({
        full_obs.observe_ebih__ebih_west__ctx__door_open();
        ctx.ebih__ebih_west__ctx__door_open()
    })
}
pub fn observe_access_ebih__ebih_west__below_door__ex__above_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and ^_door_open
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih__ebih_west__ctx__door_open();
            ctx.ebih__ebih_west__ctx__door_open()
        }))
}
pub fn observe_access_ebih__ebih_west__below_door__ex__refill_station_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_door_open
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih__ebih_west__ctx__door_open();
            ctx.ebih__ebih_west__ctx__door_open()
        }))
}
pub fn observe_access_ebih__grid_25_10_12__door__ex__door_left_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__grid_25_10_12__ctx__door_open();
        ctx.ebih__grid_25_10_12__ctx__door_open()
    }
}
pub fn observe_access_ebih__grid_25_10_12__door__ex__east_11_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__grid_25_10_12__ctx__door_open();
        ctx.ebih__grid_25_10_12__ctx__door_open()
    }
}
pub fn observe_access_ebih__grid_25_10_12__door_left__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__grid_25_10_12__ctx__door_open();
        ctx.ebih__grid_25_10_12__ctx__door_open()
    }
}
pub fn observe_access_ebih__grid_25_10_12__east_11__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__grid_25_10_12__ctx__door_open();
        ctx.ebih__grid_25_10_12__ctx__door_open()
    }
}
pub fn observe_access_ebih__vertical_interchange__door__ex__door_east_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__vertical_interchange__ctx__door_open();
        ctx.ebih__vertical_interchange__ctx__door_open()
    }
}
pub fn observe_access_ebih__vertical_interchange__door__ex__door_west_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__vertical_interchange__ctx__door_open();
        ctx.ebih__vertical_interchange__ctx__door_open()
    }
}
pub fn observe_access_ebih__vertical_interchange__door_east__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__vertical_interchange__ctx__door_open();
        ctx.ebih__vertical_interchange__ctx__door_open()
    }
}
pub fn observe_access_ebih__vertical_interchange__door_west__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__vertical_interchange__ctx__door_open();
        ctx.ebih__vertical_interchange__ctx__door_open()
    }
}
pub fn observe_access_ebih__vertical_interchange__west_13__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and not ^_door_open
    (hobserve__open!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__vertical_interchange__ctx__door_open();
            ctx.ebih__vertical_interchange__ctx__door_open()
        })))
}
pub fn observe_access_ebih__waterfall__west_door__ex__west_door_left_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_door_open
    {
        full_obs.observe_ebih__waterfall__ctx__west_door_open();
        ctx.ebih__waterfall__ctx__west_door_open()
    }
}
pub fn observe_access_ebih__waterfall__west_door__ex__west_door_right_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_door_open
    {
        full_obs.observe_ebih__waterfall__ctx__west_door_open();
        ctx.ebih__waterfall__ctx__west_door_open()
    }
}
pub fn observe_access_ebih__waterfall__west_door_left__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_door_open
    {
        full_obs.observe_ebih__waterfall__ctx__west_door_open();
        ctx.ebih__waterfall__ctx__west_door_open()
    }
}
pub fn observe_access_ebih__waterfall__west_door_right__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_door_open
    {
        full_obs.observe_ebih__waterfall__ctx__west_door_open();
        ctx.ebih__waterfall__ctx__west_door_open()
    }
}
pub fn observe_access_ebih_alu(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Alu
    {
        full_obs.observe_ebih_alu();
        ctx.has(Item::Ebih_Alu)
    }
}
pub fn observe_access_ebih_interchange_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Block
    {
        full_obs.observe_ebih_interchange_block();
        ctx.has(Item::Ebih_Interchange_Block)
    }
}
pub fn observe_access_ebih_interchange_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate
    {
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    }
}
pub fn observe_access_ebih_interchange_gate_and_ebih_interchange_block_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $grab
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_interchange_gate_and_ebih_interchange_block_and_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $hook
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_interchange_gate_and_not_ebih_interchange_block_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $grab
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        !ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_interchange_gate_and_not_ebih_interchange_block_and_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $hook
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        !ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_wasteland_door(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Wasteland_Door
    {
        full_obs.observe_ebih_wasteland_door();
        ctx.has(Item::Ebih_Wasteland_Door)
    }
}
pub fn observe_access_ebih_waterfall_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Waterfall_Wall
    {
        full_obs.observe_ebih_waterfall_wall();
        ctx.has(Item::Ebih_Waterfall_Wall)
    }
}
pub fn observe_access_ebih_west_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_West_Block
    {
        full_obs.observe_ebih_west_block();
        ctx.has(Item::Ebih_West_Block)
    }
}
pub fn observe_access_fast_travel(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Fast_Travel
    {
        full_obs.observe_fast_travel();
        ctx.has(Item::Fast_Travel)
    }
}
pub fn observe_access_ft_main_and___map_spot_within_menu_gt_kiengir_map(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $ft_main and (^map_spot WITHIN `Menu > Kiengir Map`)
    (hobserve__ft_main!(ctx, world, full_obs)
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Kiengir_Map))
}
pub fn observe_access_giguna__carnelian__door__ex__switch_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__carnelian__ctx__door_opened();
        ctx.giguna__carnelian__ctx__door_opened()
    }
}
pub fn observe_access_giguna__carnelian__door__ex__vault_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__carnelian__ctx__door_opened();
        ctx.giguna__carnelian__ctx__door_opened()
    }
}
pub fn observe_access_giguna__carnelian__lower_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar
    !({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    })
}
pub fn observe_access_giguna__carnelian__lower_susar__ex__rock_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar
    {
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    }
}
pub fn observe_access_giguna__carnelian__lower_susar__ex__west_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar and $grab
    ({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__lower_susar__ex__west_ledge_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar and $hook
    ({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__lower_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__carnelian__ctx__door_opened();
        ctx.giguna__carnelian__ctx__door_opened()
    }
}
pub fn observe_access_giguna__carnelian__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and not ^_door_opened
    (hobserve__unlock3!(ctx, world, full_obs)
        && (!({
            full_obs.observe_giguna__carnelian__ctx__door_opened();
            ctx.giguna__carnelian__ctx__door_opened()
        })))
}
pub fn observe_access_giguna__carnelian__upper_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar
    !({
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    })
}
pub fn observe_access_giguna__carnelian__upper_susar__ex__east_cliff_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__carnelian__upper_susar__ex__middle_platforms_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__carnelian__upper_susar__ex__upper_path_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__carnelian__upper_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!({
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__vault__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__carnelian__ctx__door_opened();
        ctx.giguna__carnelian__ctx__door_opened()
    }
}
pub fn observe_access_giguna__clouds__platform_start__hack_and_get_off_early__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform_and_portal and $activate
    (!({
        full_obs.observe_giguna__clouds__ctx__platform_and_portal();
        ctx.giguna__clouds__ctx__platform_and_portal()
    }) && (hobserve__activate!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__clouds__platform_start__hack_and_ride_to_portal__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform_and_portal and $activate and $attract and Breach_Sight and Remote_Drone
    ((((!({
        full_obs.observe_giguna__clouds__ctx__platform_and_portal();
        ctx.giguna__clouds__ctx__platform_and_portal()
    }) && (hobserve__activate!(ctx, world, full_obs)))
        && (hobserve__attract!(ctx, world, full_obs)))
        && ({
            full_obs.observe_breach_sight();
            ctx.has(Item::Breach_Sight)
        }))
        && ({
            full_obs.observe_remote_drone();
            ctx.has(Item::Remote_Drone)
        }))
}
pub fn observe_access_giguna__clouds__platform_start__hack_deploy_ride_to_portal__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform_and_portal and $activate and $can_deploy and $attract and Breach_Sight
    ((((!({
        full_obs.observe_giguna__clouds__ctx__platform_and_portal();
        ctx.giguna__clouds__ctx__platform_and_portal()
    }) && (hobserve__activate!(ctx, world, full_obs)))
        && (hobserve__can_deploy!(ctx, world, full_obs)))
        && (hobserve__attract!(ctx, world, full_obs)))
        && ({
            full_obs.observe_breach_sight();
            ctx.has(Item::Breach_Sight)
        }))
}
pub fn observe_access_giguna__clouds__platform_stop__ex__flipside_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_platform_and_portal and ^mode == 'drone'
    ({
        full_obs.observe_giguna__clouds__ctx__platform_and_portal();
        ctx.giguna__clouds__ctx__platform_and_portal()
    } && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    }))
}
pub fn observe_access_giguna__east_caverns__arc_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    (({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    })) && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_giguna__east_caverns__arc_passage__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and ^_combo_entered
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_giguna__east_caverns__arc_passage__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_combo_entered
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__east_caverns__ctx__combo_entered();
            ctx.giguna__east_caverns__ctx__combo_entered()
        }))
}
pub fn observe_access_giguna__east_caverns__lower_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    })
}
pub fn observe_access_giguna__east_caverns__lower_susar__ex__east_grass_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    }
}
pub fn observe_access_giguna__east_caverns__lower_susar__ex__under_lower_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    }
}
pub fn observe_access_giguna__east_caverns__lower_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__east_caverns__mid_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_mid_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__mid_susar();
        ctx.giguna__east_caverns__ctx__mid_susar()
    })
}
pub fn observe_access_giguna__east_caverns__mid_susar__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and ^_mid_susar
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__east_caverns__ctx__mid_susar();
            ctx.giguna__east_caverns__ctx__mid_susar()
        }))
}
pub fn observe_access_giguna__east_caverns__mid_susar__ex__middle_ledge_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_mid_susar
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__east_caverns__ctx__mid_susar();
            ctx.giguna__east_caverns__ctx__mid_susar()
        }))
}
pub fn observe_access_giguna__east_caverns__mid_susar__ex__middle_rock_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_mid_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__mid_susar();
        ctx.giguna__east_caverns__ctx__mid_susar()
    }
}
pub fn observe_access_giguna__east_caverns__mid_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_mid_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__mid_susar();
        ctx.giguna__east_caverns__ctx__mid_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__east_caverns__middle_rock__ex__hidden_passage_east_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and ^_combo_entered
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_giguna__east_caverns__midwest_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook and ^_combo_entered
    ((hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && ({
            full_obs.observe_giguna__east_caverns__ctx__combo_entered();
            ctx.giguna__east_caverns__ctx__combo_entered()
        }))
}
pub fn observe_access_giguna__east_caverns__midwest_ledge__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    (({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    })) && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_giguna__east_caverns__statues_ledge__ex__hidden_passage_west_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook and ^_combo_entered
    ((hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && ({
            full_obs.observe_giguna__east_caverns__ctx__combo_entered();
            ctx.giguna__east_caverns__ctx__combo_entered()
        }))
}
pub fn observe_access_giguna__east_caverns__statues_ledge__ex__hidden_passage_west_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    (({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    })) && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_giguna__east_caverns__statues_ledge__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened and $unlock2 and $range1
    ((!({
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }) && (hobserve__unlock2!(ctx, world, full_obs)))
        && (hobserve__range1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__east_caverns__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }
}
pub fn observe_access_giguna__east_caverns__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened and $unlock2
    (!({
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }) && (hobserve__unlock2!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__east_caverns__upper_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    })
}
pub fn observe_access_giguna__east_caverns__upper_susar__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar__ex__top_past_susar_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar__ex__upper_floor_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar__ex__upper_platforms_right_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar_jump_from_east__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    })
}
pub fn observe_access_giguna__east_caverns__upper_susar_jump_from_east__ex__middle_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar_jump_from_east__ex__midwest_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar_jump_from_east__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__east_caverns__upper_susar_mid_jump__ex__top_past_susar_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__east_caverns__upper_susar_mid_jump__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__east_caverns__west_14__enter_combo__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo_entered
    !({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    })
}
pub fn observe_access_giguna__east_caverns__west_16__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }
}
pub fn observe_access_giguna__east_caverns__west_16__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened and $open and $range2
    ((!({
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }) && (hobserve__open!(ctx, world, full_obs)))
        && (hobserve__range2!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__gateway__door__ex__block_left_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__gateway__ctx__door_opened();
        ctx.giguna__gateway__ctx__door_opened()
    }
}
pub fn observe_access_giguna__gateway__door__ex__left_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__gateway__ctx__door_opened();
        ctx.giguna__gateway__ctx__door_opened()
    }
}
pub fn observe_access_giguna__gateway__door__ex__passage_entry_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__gateway__ctx__door_opened();
        ctx.giguna__gateway__ctx__door_opened()
    }
}
pub fn observe_access_giguna__gateway__passage_entry__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__gateway__ctx__door_opened();
        ctx.giguna__gateway__ctx__door_opened()
    }
}
pub fn observe_access_giguna__giguna_base__below_gate__ex__kari_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $grab and $climb
    (({
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_base__below_gate__ex__kari_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $hook
    ({
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_base__below_gate__ex__middle_platform_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $grab and $climb
    (({
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_base__below_gate__ex__middle_platform_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $hook
    ({
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_base__kari__ex__below_gate_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    }
}
pub fn observe_access_giguna__giguna_base__middle_platform__ex__below_gate_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    }
}
pub fn observe_access_giguna__giguna_northeast__right_column__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    }
}
pub fn observe_access_giguna__giguna_northeast__right_column__open_door_from_afar__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and Infection_Range_3 and not ^_door_opened
    ((hobserve__unlock3!(ctx, world, full_obs)
        && ({
            full_obs.observe_infection_range_3();
            ctx.has(Item::Infection_Range_3)
        }))
        && (!({
            full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
            ctx.giguna__giguna_northeast__ctx__door_opened()
        })))
}
pub fn observe_access_giguna__giguna_northeast__switch__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened and ($grab or $hook)
    ({
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_northeast__switch__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and not ^_door_opened
    (hobserve__unlock3!(ctx, world, full_obs)
        && (!({
            full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
            ctx.giguna__giguna_northeast__ctx__door_opened()
        })))
}
pub fn observe_access_giguna__giguna_northeast__vault__ex__door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    }
}
pub fn observe_access_giguna__giguna_northeast__vault__ex__door_2__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened and $hook
    ({
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__ruins_top__east_7__ex__east_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__east_door__ex__east_7_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__east_door__ex__portal_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__entryway__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__portal__ex__east_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__west_7__ex__west_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__west_door__ex__entryway_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_top__west_door__ex__west_7_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__ruins_west__lower_ledge__destroy_kishib__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_kishib_handled and $shockwave
    (!({
        full_obs.observe_giguna__ruins_west__ctx__kishib_handled();
        ctx.giguna__ruins_west__ctx__kishib_handled()
    }) && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__ruins_west__lower_ledge__ex__upper_ledge_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and ^_kishib_handled
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__ruins_west__ctx__kishib_handled();
            ctx.giguna__ruins_west__ctx__kishib_handled()
        }))
}
pub fn observe_access_giguna__ruins_west__lower_ledge__hack_kishib__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_kishib_handled and $allegiance1
    (!({
        full_obs.observe_giguna__ruins_west__ctx__kishib_handled();
        ctx.giguna__ruins_west__ctx__kishib_handled()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__west_caverns__east_susar__caught__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_east_susar
    !({
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    })
}
pub fn observe_access_giguna__west_caverns__east_susar__ex__east_12_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_susar
    {
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    }
}
pub fn observe_access_giguna__west_caverns__east_susar__ex__tunnel_fork_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_susar
    {
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    }
}
pub fn observe_access_giguna__west_caverns__east_susar__hack__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_east_susar and $allegiance1
    (!({
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_boulder(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Boulder
    {
        full_obs.observe_giguna_boulder();
        ctx.has(Item::Giguna_Boulder)
    }
}
pub fn observe_access_giguna_breach__sw_save__side_door__ex__west_11_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna_breach__sw_save__ctx__door_opened();
        ctx.giguna_breach__sw_save__ctx__door_opened()
    }
}
pub fn observe_access_giguna_breach__sw_save__west_11__ex__side_door_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna_breach__sw_save__ctx__door_opened();
        ctx.giguna_breach__sw_save__ctx__door_opened()
    }
}
pub fn observe_access_giguna_breach__sw_save__west_11__open_door__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened
    !({
        full_obs.observe_giguna_breach__sw_save__ctx__door_opened();
        ctx.giguna_breach__sw_save__ctx__door_opened()
    })
}
pub fn observe_access_giguna_dual_path_switch(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch
    {
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    }
}
pub fn observe_access_giguna_dual_path_switch_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch and ($grab or $climb)
    ({
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_dual_path_switch_and_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch and $climb
    ({
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    } && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_dual_path_switch_and_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch and $hook
    ({
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_gateway_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gateway_Block
    {
        full_obs.observe_giguna_gateway_block();
        ctx.has(Item::Giguna_Gateway_Block)
    }
}
pub fn observe_access_giguna_gateway_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gateway_Gate
    {
        full_obs.observe_giguna_gateway_gate();
        ctx.has(Item::Giguna_Gateway_Gate)
    }
}
pub fn observe_access_giguna_gubi(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gubi
    {
        full_obs.observe_giguna_gubi();
        ctx.has(Item::Giguna_Gubi)
    }
}
pub fn observe_access_giguna_northeast_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Northeast_Gate
    {
        full_obs.observe_giguna_northeast_gate();
        ctx.has(Item::Giguna_Northeast_Gate)
    }
}
pub fn observe_access_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab
    hobserve__grab!(ctx, world, full_obs)
}
pub fn observe_access_grab_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Annuna_East_Bridge_Gate
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_grab_and_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Anuman
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
}
pub fn observe_access_grab_and_can_deploy(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and $can_deploy
    (hobserve__grab!(ctx, world, full_obs) && (hobserve__can_deploy!(ctx, world, full_obs)))
}
pub fn observe_access_grab_and_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and $climb
    (hobserve__grab!(ctx, world, full_obs) && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_grab_and_giguna_gateway_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Giguna_Gateway_Block
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna_gateway_block();
            ctx.has(Item::Giguna_Gateway_Block)
        }))
}
pub fn observe_access_grab_and_switch_40_12(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Switch_40_12
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_switch_40_12();
            ctx.has(Item::Switch_40_12)
        }))
}
pub fn observe_access_grab_and_water_movement(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Water_Movement
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_water_movement();
            ctx.has(Item::Water_Movement)
        }))
}
pub fn observe_access_grab_or_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or Anuman
    (hobserve__grab!(ctx, world, full_obs) || {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })
}
pub fn observe_access_grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $climb
    (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))
}
pub fn observe_access_grab_or_climb_or_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $climb or $hook
    ((hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))
        || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_grab_or_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $hook
    (hobserve__grab!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_grab_or_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or Underwater_Movement
    (hobserve__grab!(ctx, world, full_obs) || {
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })
}
pub fn observe_access_health_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade
    {
        full_obs.observe_health_upgrade();
        ctx.has(Item::Health_Upgrade)
    }
}
pub fn observe_access_health_upgrade_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade_2
    {
        full_obs.observe_health_upgrade_2();
        ctx.has(Item::Health_Upgrade_2)
    }
}
pub fn observe_access_health_upgrade_3(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade_3
    {
        full_obs.observe_health_upgrade_3();
        ctx.has(Item::Health_Upgrade_3)
    }
}
pub fn observe_access_health_upgrade_4(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade_4
    {
        full_obs.observe_health_upgrade_4();
        ctx.has(Item::Health_Upgrade_4)
    }
}
pub fn observe_access_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook
    hobserve__hook!(ctx, world, full_obs)
}
pub fn observe_access_hook_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Annuna_East_Bridge_Gate
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_hook_and_giguna_gateway_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Giguna_Gateway_Block
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna_gateway_block();
            ctx.has(Item::Giguna_Gateway_Block)
        }))
}
pub fn observe_access_hook_and_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover
    (hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_hook_and_hover_and_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and Underwater_Movement
    ((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_hook_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not Ebih_Waterfall_Block_Left
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_left();
            !ctx.has(Item::Ebih_Waterfall_Block_Left)
        }))
}
pub fn observe_access_hook_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not Ebih_Waterfall_Block_Right
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_right();
            !ctx.has(Item::Ebih_Waterfall_Block_Right)
        }))
}
pub fn observe_access_hook_and_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Underwater_Movement
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_hook_and_water_movement(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Water_Movement
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_water_movement();
            ctx.has(Item::Water_Movement)
        }))
}
pub fn observe_access_hook_or_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or $hover
    (hobserve__hook!(ctx, world, full_obs) || hobserve__hover!(ctx, world, full_obs))
}
pub fn observe_access_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover
    hobserve__hover!(ctx, world, full_obs)
}
pub fn observe_access_hover_and_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Anuman
    (hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
}
pub fn observe_access_hover_and_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook
    (hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_hover_and_hook_and_mist2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook and $mist2
    ((hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && (hobserve__mist2!(ctx, world, full_obs)))
}
pub fn observe_access_hover_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Mist_Upgrade
    (hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_mist_upgrade();
            ctx.has(Item::Mist_Upgrade)
        }))
}
pub fn observe_access_hover_or_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover or $hook
    (hobserve__hover!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_hover_or_mist2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover or $mist2
    (hobserve__hover!(ctx, world, full_obs) || hobserve__mist2!(ctx, world, full_obs))
}
pub fn observe_access_infect(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect
    {
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    }
}
pub fn observe_access_infect_and_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and Anuman
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }))
}
pub fn observe_access_infect_and_not_anuman(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not Anuman
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_anuman();
        !ctx.has(Item::Anuman)
    }))
}
pub fn observe_access_infect_l1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect_L1
    {
        full_obs.observe_infect_l1();
        ctx.has(Item::Infect_L1)
    }
}
pub fn observe_access_infect_l2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect_L2
    {
        full_obs.observe_infect_l2();
        ctx.has(Item::Infect_L2)
    }
}
pub fn observe_access_infection_range(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infection_Range
    {
        full_obs.observe_infection_range();
        ctx.has(Item::Infection_Range)
    }
}
pub fn observe_access_infection_range_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infection_Range_2
    {
        full_obs.observe_infection_range_2();
        ctx.has(Item::Infection_Range_2)
    }
}
pub fn observe_access_infection_speed(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infection_Speed
    {
        full_obs.observe_infection_speed();
        ctx.has(Item::Infection_Speed)
    }
}
pub fn observe_access_infinite_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and Annuna_East_Bridge_Gate
    (hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_infinite_climb_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and not Annuna_East_Bridge_Gate
    (hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            !ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_infinite_climb_and_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and Slingshot_Hook
    (hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_infinite_climb_and_slingshot_hook_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and Slingshot_Hook and not Annuna_East_Bridge_Gate
    ((hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            !ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_irikar__basement_portal__ledge__ex__moving_platform_start_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform_moved
    !({
        full_obs.observe_irikar__basement_portal__ctx__platform_moved();
        ctx.irikar__basement_portal__ctx__platform_moved()
    })
}
pub fn observe_access_irikar__basement_portal__middle_platform__ex__moving_platform_end_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_platform_moved and $hook
    ({
        full_obs.observe_irikar__basement_portal__ctx__platform_moved();
        ctx.irikar__basement_portal__ctx__platform_moved()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_irikar__basement_portal__portal_stand__ex__moving_platform_start_1__req(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform_moved
    !({
        full_obs.observe_irikar__basement_portal__ctx__platform_moved();
        ctx.irikar__basement_portal__ctx__platform_moved()
    })
}
pub fn observe_access_irikar_gudam(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Gudam
    {
        full_obs.observe_irikar_gudam();
        ctx.has(Item::Irikar_Gudam)
    }
}
pub fn observe_access_irikar_royal_storage_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Royal_Storage_Wall
    {
        full_obs.observe_irikar_royal_storage_wall();
        ctx.has(Item::Irikar_Royal_Storage_Wall)
    }
}
pub fn observe_access_map__amagi__main_area__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi__main_area__save
    {
        full_obs.observe_map__amagi__main_area__save();
        ctx.map__amagi__main_area__save()
    }
}
pub fn observe_access_map__annuna__center_save__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__center_save__save
    {
        full_obs.observe_map__annuna__center_save__save();
        ctx.map__annuna__center_save__save()
    }
}
pub fn observe_access_map__annuna__factory_entrance__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__factory_entrance__save
    {
        full_obs.observe_map__annuna__factory_entrance__save();
        ctx.map__annuna__factory_entrance__save()
    }
}
pub fn observe_access_map__annuna__mirror_match__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__mirror_match__save
    {
        full_obs.observe_map__annuna__mirror_match__save();
        ctx.map__annuna__mirror_match__save()
    }
}
pub fn observe_access_map__ebih__base_camp__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__base_camp__save
    {
        full_obs.observe_map__ebih__base_camp__save();
        ctx.map__ebih__base_camp__save()
    }
}
pub fn observe_access_map__ebih__ebih_west__lower_save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__ebih_west__lower_save
    {
        full_obs.observe_map__ebih__ebih_west__lower_save();
        ctx.map__ebih__ebih_west__lower_save()
    }
}
pub fn observe_access_map__ebih__ebih_west__mid_save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__ebih_west__mid_save
    {
        full_obs.observe_map__ebih__ebih_west__mid_save();
        ctx.map__ebih__ebih_west__mid_save()
    }
}
pub fn observe_access_map__ebih__ebih_west__upper_save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__ebih_west__upper_save
    {
        full_obs.observe_map__ebih__ebih_west__upper_save();
        ctx.map__ebih__ebih_west__upper_save()
    }
}
pub fn observe_access_map__giguna__giguna_base__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__giguna_base__save
    {
        full_obs.observe_map__giguna__giguna_base__save();
        ctx.map__giguna__giguna_base__save()
    }
}
pub fn observe_access_map__giguna__giguna_northeast__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__giguna_northeast__save
    {
        full_obs.observe_map__giguna__giguna_northeast__save();
        ctx.map__giguna__giguna_northeast__save()
    }
}
pub fn observe_access_map__giguna__ruins_top__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__ruins_top__save
    {
        full_obs.observe_map__giguna__ruins_top__save();
        ctx.map__giguna__ruins_top__save()
    }
}
pub fn observe_access_map__giguna__ruins_west__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__ruins_west__save
    {
        full_obs.observe_map__giguna__ruins_west__save();
        ctx.map__giguna__ruins_west__save()
    }
}
pub fn observe_access_map__giguna_breach__peak__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__peak__save
    {
        full_obs.observe_map__giguna_breach__peak__save();
        ctx.map__giguna_breach__peak__save()
    }
}
pub fn observe_access_map__giguna_breach__sw_save__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__sw_save__save
    {
        full_obs.observe_map__giguna_breach__sw_save__save();
        ctx.map__giguna_breach__sw_save__save()
    }
}
pub fn observe_access_map__glacier__revival__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier__revival__save
    {
        full_obs.observe_map__glacier__revival__save();
        ctx.map__glacier__revival__save()
    }
}
pub fn observe_access_map__irikar__hub__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar__hub__save
    {
        full_obs.observe_map__irikar__hub__save();
        ctx.map__irikar__hub__save()
    }
}
pub fn observe_access_map__irikar_breach__gauntlet__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar_breach__gauntlet__save
    {
        full_obs.observe_map__irikar_breach__gauntlet__save();
        ctx.map__irikar_breach__gauntlet__save()
    }
}
pub fn observe_access_map__irikar_breach__save_room__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar_breach__save_room__save
    {
        full_obs.observe_map__irikar_breach__save_room__save();
        ctx.map__irikar_breach__save_room__save()
    }
}
pub fn observe_access_map__uhrum__annuna_corridor__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__annuna_corridor__save
    {
        full_obs.observe_map__uhrum__annuna_corridor__save();
        ctx.map__uhrum__annuna_corridor__save()
    }
}
pub fn observe_access_map__uhrum__save_room__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__save_room__save
    {
        full_obs.observe_map__uhrum__save_room__save();
        ctx.map__uhrum__save_room__save()
    }
}
pub fn observe_access_map__uhrum__west_entrance__save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__west_entrance__save
    {
        full_obs.observe_map__uhrum__west_entrance__save();
        ctx.map__uhrum__west_entrance__save()
    }
}
pub fn observe_access_melee_damage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Damage
    {
        full_obs.observe_melee_damage();
        ctx.has(Item::Melee_Damage)
    }
}
pub fn observe_access_melee_damage_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Damage_2
    {
        full_obs.observe_melee_damage_2();
        ctx.has(Item::Melee_Damage_2)
    }
}
pub fn observe_access_melee_speed(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Speed
    {
        full_obs.observe_melee_speed();
        ctx.has(Item::Melee_Speed)
    }
}
pub fn observe_access_melee_speed_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Speed_2
    {
        full_obs.observe_melee_speed_2();
        ctx.has(Item::Melee_Speed_2)
    }
}
pub fn observe_access_mist2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $mist2
    hobserve__mist2!(ctx, world, full_obs)
}
pub fn observe_access_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Mist_Upgrade
    {
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    }
}
pub fn observe_access_mode_eq_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone'
    {
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    }
}
pub fn observe_access_mode_eq_drone_and_breach_sight(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Breach_Sight
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_breach_sight();
        ctx.has(Item::Breach_Sight)
    }))
}
pub fn observe_access_mode_eq_drone_and_ebih_wasteland_passage_h(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Ebih_Wasteland_Passage_H
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_ebih_wasteland_passage_h();
        ctx.has(Item::Ebih_Wasteland_Passage_H)
    }))
}
pub fn observe_access_mode_eq_drone_and_ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Left
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_ebih_waterfall_block_left();
        ctx.has(Item::Ebih_Waterfall_Block_Left)
    }))
}
pub fn observe_access_mode_eq_drone_and_ebih_waterfall_block_right(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Right
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_ebih_waterfall_block_right();
        ctx.has(Item::Ebih_Waterfall_Block_Right)
    }))
}
pub fn observe_access_mode_eq_drone_and_giguna_dual_path_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Giguna_Dual_Path_Wall
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_giguna_dual_path_wall();
        ctx.has(Item::Giguna_Dual_Path_Wall)
    }))
}
pub fn observe_access_mode_eq_drone_and_mist2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and $mist2
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && (hobserve__mist2!(ctx, world, full_obs)))
}
pub fn observe_access_mode_eq_drone_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    }))
}
pub fn observe_access_mode_eq_drone_and_sniper_valley_rock_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Sniper_Valley_Rock_2
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_sniper_valley_rock_2();
        ctx.has(Item::Sniper_Valley_Rock_2)
    }))
}
pub fn observe_access_mode_ne_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode != 'drone'
    {
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    }
}
pub fn observe_access_more_refills(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $more_refills
    hobserve__more_refills!(ctx, world, full_obs)
}
pub fn observe_access_nanite_mist(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nanite_Mist
    {
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }
}
pub fn observe_access_nanite_mist_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nanite_Mist and Mist_Upgrade
    ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    }))
}
pub fn observe_access_nano_points(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nano_Points
    {
        full_obs.observe_nano_points();
        ctx.has(Item::Nano_Points)
    }
}
pub fn observe_access_nano_points_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nano_Points_2
    {
        full_obs.observe_nano_points_2();
        ctx.has(Item::Nano_Points_2)
    }
}
pub fn observe_access_not_amashilama(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT Amashilama
    {
        full_obs.observe_amashilama();
        !ctx.has(Item::Amashilama)
    }
}
pub fn observe_access_not_ebih_interchange_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Ebih_Interchange_Block
    {
        full_obs.observe_ebih_interchange_block();
        !ctx.has(Item::Ebih_Interchange_Block)
    }
}
pub fn observe_access_not_ebih_waterfall_wall_and_nanite_mist_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Ebih_Waterfall_Wall and Nanite_Mist and Mist_Upgrade
    (({
        full_obs.observe_ebih_waterfall_wall();
        !ctx.has(Item::Ebih_Waterfall_Wall)
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    })) && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    }))
}
pub fn observe_access_not_irikar_royal_storage_wall_and_mist_upgrade(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Irikar_Royal_Storage_Wall and Mist_Upgrade
    ({
        full_obs.observe_irikar_royal_storage_wall();
        !ctx.has(Item::Irikar_Royal_Storage_Wall)
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    }))
}
pub fn observe_access_not_irikar_royal_storage_wall_and_shockwave(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Irikar_Royal_Storage_Wall and $shockwave
    ({
        full_obs.observe_irikar_royal_storage_wall();
        !ctx.has(Item::Irikar_Royal_Storage_Wall)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_not_separation_or_defeat_indra(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT Separation or Defeat_Indra
    ({
        full_obs.observe_separation();
        !ctx.has(Item::Separation)
    } || {
        full_obs.observe_defeat_indra();
        ctx.has(Item::Defeat_Indra)
    })
}
pub fn observe_access_not_slingshot_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Slingshot_Hook
    {
        full_obs.observe_slingshot_hook();
        !ctx.has(Item::Slingshot_Hook)
    }
}
pub fn observe_access_not_within_menu_and_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and Anuman and ^mode != 'drone'
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })) && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    }))
}
pub fn observe_access_not_within_menu_and_can_deploy(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and $can_deploy
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && (hobserve__can_deploy!(ctx, world, full_obs)))
}
pub fn observe_access_not_within_menu_and_flasks_gt_0(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and ^flasks > 0
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        let n: i32 = 0.into();
        full_obs.observe_flasks(IntegerObservation::Le(n as i8));
        i32::from(ctx.flasks()) > n
    }))
}
pub fn observe_access_not_within_menu_and_ft_main_and_can_recall_and___map_spot_not_within_default(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and $ft_main and $can_recall and (^map_spot NOT WITHIN $default)
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && (hobserve__ft_main!(ctx, world, full_obs)))
        && (hobserve__can_recall!(ctx, world, full_obs)))
        && (data::map_spot(ctx.position()) != Default::default()))
}
pub fn observe_access_not_within_menu_and_realm_ne_breach_and_anuman_and_mode_eq_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and Anuman and ^mode == 'drone'
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        let v = data::realm(ctx.position());
        v != enums::Realm::Breach
    })) && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })) && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    }))
}
pub fn observe_access_not_within_menu_and_realm_ne_breach_and_can_recall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and $can_recall
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        let v = data::realm(ctx.position());
        v != enums::Realm::Breach
    })) && (hobserve__can_recall!(ctx, world, full_obs)))
}
pub fn observe_access_offset(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $offset
    hobserve__offset!(ctx, world, full_obs)
}
pub fn observe_access_open(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open
    hobserve__open!(ctx, world, full_obs)
}
pub fn observe_access_open_and_range1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range1
    (hobserve__open!(ctx, world, full_obs) && (hobserve__range1!(ctx, world, full_obs)))
}
pub fn observe_access_open_and_range2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range2
    (hobserve__open!(ctx, world, full_obs) && (hobserve__range2!(ctx, world, full_obs)))
}
pub fn observe_access_open_and_range3(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range3
    (hobserve__open!(ctx, world, full_obs) && (hobserve__range3!(ctx, world, full_obs)))
}
pub fn observe_access_overheat(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $overheat
    hobserve__overheat!(ctx, world, full_obs)
}
pub fn observe_access_overheat_and_can_damage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $overheat and $can_damage
    (hobserve__overheat!(ctx, world, full_obs) && (hobserve__can_damage!(ctx, world, full_obs)))
}
pub fn observe_access_platform_and_hook_and_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $platform and $hook and $hover
    ((hobserve__platform!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_ranged_damage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Damage
    {
        full_obs.observe_ranged_damage();
        ctx.has(Item::Ranged_Damage)
    }
}
pub fn observe_access_ranged_damage_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Damage_2
    {
        full_obs.observe_ranged_damage_2();
        ctx.has(Item::Ranged_Damage_2)
    }
}
pub fn observe_access_ranged_speed(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Speed
    {
        full_obs.observe_ranged_speed();
        ctx.has(Item::Ranged_Speed)
    }
}
pub fn observe_access_ranged_speed_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Speed_2
    {
        full_obs.observe_ranged_speed_2();
        ctx.has(Item::Ranged_Speed_2)
    }
}
pub fn observe_access_realm_eq_breach(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^realm == 'breach'
    {
        let v = data::realm(ctx.position());
        v == enums::Realm::Breach
    }
}
pub fn observe_access_realm_eq_breach_and_exit_breach_and___flipside_not_within_default(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^realm == 'breach' and Exit_Breach and (^flipside NOT WITHIN $default)
    (({
        let v = data::realm(ctx.position());
        v == enums::Realm::Breach
    } && ({
        full_obs.observe_exit_breach();
        ctx.has(Item::Exit_Breach)
    })) && (data::flipside(ctx.position()) != Default::default()))
}
pub fn observe_access_realm_in___main_interior_emergence_and_amashilama(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^realm IN ['main', 'interior', 'emergence'] and Amashilama
    (matches!(
        data::realm(ctx.position()),
        enums::Realm::Main | enums::Realm::Interior | enums::Realm::Emergence
    ) && ({
        full_obs.observe_amashilama();
        ctx.has(Item::Amashilama)
    }))
}
pub fn observe_access_remote_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Remote_Drone
    {
        full_obs.observe_remote_drone();
        ctx.has(Item::Remote_Drone)
    }
}
pub fn observe_access_separation(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Separation
    {
        full_obs.observe_separation();
        ctx.has(Item::Separation)
    }
}
pub fn observe_access_separation_and_not_defeat_indra_and_mist2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Separation and NOT Defeat_Indra and $mist2
    (({
        full_obs.observe_separation();
        ctx.has(Item::Separation)
    } && ({
        full_obs.observe_defeat_indra();
        !ctx.has(Item::Defeat_Indra)
    })) && (hobserve__mist2!(ctx, world, full_obs)))
}
pub fn observe_access_shockwave(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave
    hobserve__shockwave!(ctx, world, full_obs)
}
pub fn observe_access_shockwave_and_not_defeat_mus_a_m20(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave and not Defeat_MUS_A_M20
    (hobserve__shockwave!(ctx, world, full_obs)
        && ({
            full_obs.observe_defeat_mus_a_m20();
            !ctx.has(Item::Defeat_MUS_A_M20)
        }))
}
pub fn observe_access_sniper_valley_rock_1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Sniper_Valley_Rock_1
    {
        full_obs.observe_sniper_valley_rock_1();
        ctx.has(Item::Sniper_Valley_Rock_1)
    }
}
pub fn observe_access_spin(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // $spin
    hobserve__spin!(ctx, world, full_obs)
}
pub fn observe_access_station_power(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Station_Power
    {
        full_obs.observe_station_power();
        ctx.has(Item::Station_Power)
    }
}
pub fn observe_access_switch_36_11(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Switch_36_11
    {
        full_obs.observe_switch_36_11();
        ctx.has(Item::Switch_36_11)
    }
}
pub fn observe_access_switch_40_12(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Switch_40_12
    {
        full_obs.observe_switch_40_12();
        ctx.has(Item::Switch_40_12)
    }
}
pub fn observe_access_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Annuna_Corridor_Block
    {
        full_obs.observe_uhrum_annuna_corridor_block();
        ctx.has(Item::Uhrum_Annuna_Corridor_Block)
    }
}
pub fn observe_access_uhrum_waterfall_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfall_Wall
    {
        full_obs.observe_uhrum_waterfall_wall();
        ctx.has(Item::Uhrum_Waterfall_Wall)
    }
}
pub fn observe_access_uhrum_waterfalls_block(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfalls_Block
    {
        full_obs.observe_uhrum_waterfalls_block();
        ctx.has(Item::Uhrum_Waterfalls_Block)
    }
}
pub fn observe_access_uhrum_waterfalls_block_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfalls_Block and $grab
    ({
        full_obs.observe_uhrum_waterfalls_block();
        ctx.has(Item::Uhrum_Waterfalls_Block)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_waterfalls_block_and_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfalls_Block and $hook
    ({
        full_obs.observe_uhrum_waterfalls_block();
        ctx.has(Item::Uhrum_Waterfalls_Block)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_west_entrance_gate(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Gate
    {
        full_obs.observe_uhrum_west_entrance_gate();
        ctx.has(Item::Uhrum_West_Entrance_Gate)
    }
}
pub fn observe_access_uhrum_west_entrance_gate_and_hover(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Gate and $hover
    ({
        full_obs.observe_uhrum_west_entrance_gate();
        ctx.has(Item::Uhrum_West_Entrance_Gate)
    } && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_west_entrance_lower_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Lower_Wall
    {
        full_obs.observe_uhrum_west_entrance_lower_wall();
        ctx.has(Item::Uhrum_West_Entrance_Lower_Wall)
    }
}
pub fn observe_access_uhrum_west_entrance_upper_wall(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Upper_Wall
    {
        full_obs.observe_uhrum_west_entrance_upper_wall();
        ctx.has(Item::Uhrum_West_Entrance_Upper_Wall)
    }
}
pub fn observe_access_underwater_movement(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement
    {
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }
}
pub fn observe_access_underwater_movement_and___grab_or_climb(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and ($grab or $climb)
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_grab(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $grab
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_hook(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $hook
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_within_antarctica(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // WITHIN `Antarctica`
    (match get_region(ctx.position()) {
        RegionId::Antarctica => true,
        _ => false,
    })
}
pub fn observe_access_within_menu_gt_upgrade_menu(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) -> bool {
    // WITHIN `Menu > Upgrade Menu`
    (match get_area(ctx.position()) {
        AreaId::Menu__Upgrade_Menu => true,
        _ => false,
    })
}
pub fn observe_action_amagi__main_area__carving__key_combo__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_combo = true
}
pub fn observe_action_annuna__east_bridge__tower_east_ledge__enter_combo__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_combo = true
}
pub fn observe_action_annuna__east_bridge__tower_secret__enter_combo__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_combo = true
}
pub fn observe_action_annuna__east_bridge__tower_west_ledge__enter_combo__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_combo = true
}
pub fn observe_action_annuna__west_climb__switch_ledge__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_breach_portal_save_update(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $breach_portal_save_update
    hobserve__breach_portal_save_update!(ctx, world, full_obs);
}
pub fn observe_action_clear_breach_save(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $clear_breach_save
    hobserve__clear_breach_save!(ctx, world, full_obs);
}
pub fn observe_action_collect__irikar_royal_storage_wall_collect__flask_visit__irikar_gt_hub_gt_royal_storage_in_wall_gt_item(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $collect(Irikar_Royal_Storage_Wall); $collect(Flask); $visit(`Irikar > Hub > Royal Storage in Wall > Item`);
    rules::observe_action_flasks_incr_1(ctx, world, full_obs);
}
pub fn observe_action_deploy_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone
    hobserve__deploy_drone!(ctx, world, full_obs);
}
pub fn observe_action_deploy_drone_and_move__annuna_gt_east_bridge_gt_center_corridor(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Center Corridor`)
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Annuna__East_Bridge__Center_Corridor,
        full_obs
    );
}
pub fn observe_action_deploy_drone_and_move__annuna_gt_east_bridge_gt_tower_base_east(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Tower Base East`)
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Annuna__East_Bridge__Tower_Base_East,
        full_obs
    );
}
pub fn observe_action_deploy_drone_and_move__ebih_gt_drone_room_gt_tree(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Ebih > Drone Room > Tree`)
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Drone_Room__Tree, full_obs);
}
pub fn observe_action_deploy_drone_and_move__ebih_gt_ebih_west_gt_alcove_entrance(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Ebih > Ebih West > Alcove Entrance`)
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Ebih__Ebih_West__Alcove_Entrance,
        full_obs
    );
}
pub fn observe_action_deploy_drone_and_move__giguna_gt_giguna_base_gt_kari(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Giguna > Giguna Base > Kari`)
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Giguna_Base__Kari, full_obs);
}
pub fn observe_action_deploy_drone_and_move__giguna_gt_ruins_top_gt_west_7(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Giguna > Ruins Top > West 7`)
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Ruins_Top__West_7, full_obs);
}
pub fn observe_action_deploy_drone_and_move__giguna_gt_wasteland_gt_middle_path(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Giguna > Wasteland > Middle Path`)
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Wasteland__Middle_Path, full_obs);
}
pub fn observe_action_ebih__base_camp__left_platform__move_left_platform__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_left_platform_moved = true
}
pub fn observe_action_ebih__base_camp__left_platform_moved__reset_left_platform__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_left_platform_moved = false
}
pub fn observe_action_ebih__drone_room__pit_left__activate_lift__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = false
}
pub fn observe_action_ebih__drone_room__pit_left__activate_lift_but_get_off_early__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = false
}
pub fn observe_action_ebih__drone_room__portal_exit__activate_platform__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = true
}
pub fn observe_action_ebih__ebih_east__dispenser__activate_lift__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform2_moved = false
}
pub fn observe_action_ebih__ebih_east__lower_moving_platform__activate_lift__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform2_moved = true
}
pub fn observe_action_ebih__ebih_east__lower_moving_platform__activate_ride__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform2_moved = true
}
pub fn observe_action_ebih__ebih_east__moving_platform__activate_ride__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform1_moved = true
}
pub fn observe_action_ebih__ebih_west__below_door__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true; IF (^indra WITHIN `Ebih > Ebih West > Above Door`) { ^indra = `Ebih > Ebih West > Below Door`; }
    {
        full_obs.observe_indra();
        ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door
    };
    if ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door {}
}
pub fn observe_action_ebih__ebih_west__left_of_switch__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true; IF (^indra WITHIN `Ebih > Ebih West > Above Door`) { ^indra = `Ebih > Ebih West > Below Door`; }
    {
        full_obs.observe_indra();
        ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door
    };
    if ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door {}
}
pub fn observe_action_ebih__grid_25_10_12__door_left__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_ebih__grid_25_10_12__east_11__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_ebih__vertical_interchange__west_13__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_ebih__waterfall__below_left_switch__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_west_door_open = true
}
pub fn observe_action_ebih__waterfall__west_8__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_west_door_open = true
}
pub fn observe_action_flasks_incr_1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^flasks += 1
}
pub fn observe_action_flasks_incr_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^flasks += 2
}
pub fn observe_action_giguna__carnelian__lower_susar__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_susar = true
}
pub fn observe_action_giguna__carnelian__lower_susar__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_susar = true
}
pub fn observe_action_giguna__carnelian__switch__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__carnelian__upper_susar__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__carnelian__upper_susar__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__clouds__platform_start__hack_and_get_off_early__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_and_portal = true
}
pub fn observe_action_giguna__clouds__platform_start__hack_and_ride_to_portal__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_and_portal = true; if (^indra WITHIN ^position) { ^indra = `Giguna > Clouds > Platform Stop` }
    {
        full_obs.observe_indra();
        full_obs.observe_position();
        ctx.indra() == ctx.position()
    };
    if ctx.indra() == ctx.position() {}
}
pub fn observe_action_giguna__clouds__platform_start__hack_deploy_ride_to_portal__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_and_portal = true; $deploy_drone_and_move(`Giguna > Clouds > Platform Stop`)
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Clouds__Platform_Stop, full_obs);
}
pub fn observe_action_giguna__east_caverns__lower_susar__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_susar = true
}
pub fn observe_action_giguna__east_caverns__lower_susar__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_susar = true
}
pub fn observe_action_giguna__east_caverns__mid_susar__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_mid_susar = true
}
pub fn observe_action_giguna__east_caverns__mid_susar__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_mid_susar = true
}
pub fn observe_action_giguna__east_caverns__statues_ledge__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__east_caverns__switch__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__east_caverns__upper_susar__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__east_caverns__upper_susar_jump_from_east__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__east_caverns__upper_susar_jump_from_east__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__east_caverns__upper_susar_mid_jump__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__east_caverns__west_14__enter_combo__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_combo_entered = true
}
pub fn observe_action_giguna__east_caverns__west_16__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__gateway__flask_ledge__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__gateway__one_jump__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__giguna_base__switch_distance_1__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_giguna__giguna_base__switch_distance_2__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_giguna__giguna_base__switch_distance_3__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_giguna__giguna_base__switch_distance_4__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_giguna__giguna_northeast__right_column__open_door_from_afar__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__giguna_northeast__switch__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__ruins_top__switch__open_doors__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_doors_open = true
}
pub fn observe_action_giguna__ruins_west__lower_ledge__destroy_kishib__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_kishib_handled = true
}
pub fn observe_action_giguna__ruins_west__lower_ledge__hack_kishib__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_kishib_handled = true
}
pub fn observe_action_giguna__west_caverns__east_susar__caught__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_east_susar = true
}
pub fn observe_action_giguna__west_caverns__east_susar__hack__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_east_susar = true
}
pub fn observe_action_giguna_breach__sw_save__west_11__open_door__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_indra_set_default(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^indra = $default
}
pub fn observe_action_indra_set_default_refill_energy(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^indra = $default; $refill_energy
    hobserve__refill_energy!(ctx, world, full_obs);
}
pub fn observe_action_irikar__basement_portal__moving_platform_start__activate_platform__do(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = true
}
pub fn observe_action_last_set_default(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^last = $default
}
pub fn observe_action_last_set_position(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^last = ^position
}
pub fn observe_action_main_portal_save_update(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $main_portal_save_update
    hobserve__main_portal_save_update!(ctx, world, full_obs);
}
pub fn observe_action_mode_set_drone(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^mode = 'drone'
}
pub fn observe_action_mode_set_drone_indra_set_position(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^mode = 'drone'; ^indra = ^position
}
pub fn observe_action_mode_set_indra(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^mode = 'Indra'
}
pub fn observe_action_mode_set_indra_last_set_indra(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^mode = 'Indra'; ^last = ^indra
}
pub fn observe_action_pass(ctx: &Context, world: &graph::World, full_obs: &mut FullObservation) {
    // $pass
    ();
}
pub fn observe_action_refill_energy(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $refill_energy
    hobserve__refill_energy!(ctx, world, full_obs);
}
pub fn observe_action_refills_incr_1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^refills += 1
}
pub fn observe_action_reset_old_area__newpos(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $reset_old_area(^newpos)
}
pub fn observe_action_save(ctx: &Context, world: &graph::World, full_obs: &mut FullObservation) {
    // $save
    hobserve__save!(ctx, world, full_obs);
}
pub fn observe_action_save_last(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $save_last
    hobserve__save_last!(ctx, world, full_obs);
}
pub fn observe_action_save_set_glacier_gt_revival_gt_save_point(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // ^save = `Glacier > Revival > Save Point`
}
pub fn observe_action_skip__amagi_gt_west_lake_gt_cavern_refill_station_gt_break_wall_add_item__amagi_dragon_eye_passage(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $skip(`Amagi > West Lake > Cavern Refill Station > Break Wall`); $add_item(Amagi_Dragon_Eye_Passage);
}
pub fn observe_action_skip__amagi_gt_west_lake_gt_stronghold_ceiling_left_gt_knock_down_left_boulder_add_item__amagi_stronghold_wall_1_add_item__amagi_stronghold_boulder_1(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $skip(`Amagi > West Lake > Stronghold Ceiling Left > Knock Down Left Boulder`); $add_item(Amagi_Stronghold_Wall_1); $add_item(Amagi_Stronghold_Boulder_1);
}
pub fn observe_action_skip__amagi_gt_west_lake_gt_stronghold_ceiling_right_gt_knock_down_right_boulder_add_item__amagi_stronghold_wall_2_add_item__amagi_stronghold_boulder_2(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $skip(`Amagi > West Lake > Stronghold Ceiling Right > Knock Down Right Boulder`); $add_item(Amagi_Stronghold_Wall_2); $add_item(Amagi_Stronghold_Boulder_2);
}
pub fn observe_action_skip__ebih_gt_waterfall_gt_alcove_gt_block_left_skip__ebih_gt_waterfall_gt_alcove_gt_block_right_skip__ebih_gt_waterfall_gt_alcove_left_gt_block_left_skip__ebih_gt_waterfall_gt_alcove_right_gt_block_right_add_item__ebih_waterfall_block_right_add_item__ebih_waterfall_block_left(
    ctx: &Context,
    world: &graph::World,
    full_obs: &mut FullObservation,
) {
    // $skip(`Ebih > Waterfall > Alcove > Block Left`); $skip(`Ebih > Waterfall > Alcove > Block Right`); $skip(`Ebih > Waterfall > Alcove Left > Block Left`); $skip(`Ebih > Waterfall > Alcove Right > Block Right`); $add_item(Ebih_Waterfall_Block_Right); $add_item(Ebih_Waterfall_Block_Left);
}
