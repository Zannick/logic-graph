//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::*;
use crate::graph::*;
use crate::items::Item;
use crate::observe::*;
use crate::prices::Currency;
use crate::*;
use analyzer::context::Ctx;
use analyzer::matchertrie::IntegerObservation;
use analyzer::world::World as _;
use rustc_hash::FxHashMap;

pub fn access_default(_ctx: &Context, _world: &World) -> bool {
    true
}

pub fn access___bridge_hover_or_slingshot_charge_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // (bridge_hover or Slingshot_Charge) and $hookhover
    ((world.bridge_hover || ctx.has(Item::Slingshot_Charge)) && helper__hookhover!(ctx, world))
}
pub fn access___escape_apocalypse_bomb_invoke_objective(ctx: &Context, world: &World) -> bool {
    // [Escape, Apocalypse_Bomb, $objective]
    ctx.has(Item::Escape) && ctx.has(Item::Apocalypse_Bomb) && rule__objective!(ctx, world)
}
pub fn access___infect_nanite_mist(ctx: &Context, world: &World) -> bool {
    // [Infect, Nanite_Mist]
    ctx.has(Item::Infect) && ctx.has(Item::Nanite_Mist)
}
pub fn access___invoke_all_urns(ctx: &Context, world: &World) -> bool {
    // [$all_urns]
    helper__all_urns!(ctx, world)
}
pub fn access___invoke_all_urns_invoke_all_weapons_invoke_other_items_invoke_all_notes_invoke_all_health_invoke_all_flasks(
    ctx: &Context,
    world: &World,
) -> bool {
    // [$all_urns, $all_weapons, $other_items, $all_notes, $all_health, $all_flasks]
    helper__all_urns!(ctx, world)
        && helper__all_weapons!(ctx, world)
        && helper__other_items!(ctx, world)
        && helper__all_notes!(ctx, world)
        && helper__all_health!(ctx, world)
        && helper__all_flasks!(ctx, world)
}
pub fn access___invoke_grab_and_anuman_or_invoke_climb(ctx: &Context, world: &World) -> bool {
    // ($grab and Anuman) or $climb
    ((helper__grab!(ctx, world) && ctx.has(Item::Anuman)) || helper__climb!(ctx, world))
}
pub fn access___invoke_grab_or_invoke_climb_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // ($grab or $climb) and Underwater_Movement
    ((helper__grab!(ctx, world) || helper__climb!(ctx, world))
        && ctx.has(Item::Underwater_Movement))
}
pub fn access___invoke_grab_or_invoke_climb_or_invoke_hook_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // ($grab or $climb or $hook) and Underwater_Movement
    (((helper__grab!(ctx, world) || helper__climb!(ctx, world)) || helper__hook!(ctx, world))
        && ctx.has(Item::Underwater_Movement))
}
pub fn access___invoke_hook_or_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // ($hook or $hover) and Underwater_Movement
    ((helper__hook!(ctx, world) || helper__hover!(ctx, world))
        && ctx.has(Item::Underwater_Movement))
}
pub fn access___invoke_objective(ctx: &Context, world: &World) -> bool {
    // [$objective]
    rule__objective!(ctx, world)
}
pub fn access___remote_drone_flask__6(ctx: &Context, world: &World) -> bool {
    // [Remote_Drone, Flask{6}]
    ctx.has(Item::Remote_Drone) && ctx.count(Item::Flask) >= 6
}
pub fn access_allow_warps_and_invoke_ft_breach_and___map_spot_within_menu_gt_breach_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
) -> bool {
    // allow_warps and $ft_breach and (^map_spot WITHIN `Menu > Breach Map`) and not Apocalypse_Bomb
    (((world.allow_warps && helper__ft_breach!(ctx, world))
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Breach_Map))
        && !ctx.has(Item::Apocalypse_Bomb))
}
pub fn access_allow_warps_and_invoke_ft_main_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
) -> bool {
    // allow_warps and $ft_main and (^map_spot WITHIN `Menu > Kiengir Map`) and not Apocalypse_Bomb
    (((world.allow_warps && helper__ft_main!(ctx, world))
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Kiengir_Map))
        && !ctx.has(Item::Apocalypse_Bomb))
}
pub fn access_allow_warps_and_not_within_menu_and_invoke_ft_main_and_invoke_can_recall_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
) -> bool {
    // allow_warps and NOT WITHIN `Menu` and $ft_main and $can_recall and (^map_spot WITHIN `Menu > Kiengir Map`) and not Apocalypse_Bomb
    (((((world.allow_warps
        && (match get_region(ctx.position()) {
            RegionId::Menu => false,
            _ => true,
        }))
        && helper__ft_main!(ctx, world))
        && helper__can_recall!(ctx, world))
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Kiengir_Map))
        && !ctx.has(Item::Apocalypse_Bomb))
}
pub fn access_allow_warps_and_realm_eq_breach_and_breach_save_ne_invoke_default_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
) -> bool {
    // allow_warps and ^realm == 'breach' and ^breach_save != $default and not Apocalypse_Bomb
    (((world.allow_warps && data::realm(ctx.position()) == enums::Realm::Breach)
        && ctx.breach_save() != Default::default())
        && !ctx.has(Item::Apocalypse_Bomb))
}
pub fn access_allow_warps_and_realm_in___main_interior_emergence_and_amashilama_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
) -> bool {
    // allow_warps and ^realm IN ['main', 'interior', 'emergence'] and Amashilama and not Apocalypse_Bomb
    (((world.allow_warps
        && matches!(
            data::realm(ctx.position()),
            enums::Realm::Main | enums::Realm::Interior | enums::Realm::Emergence
        ))
        && ctx.has(Item::Amashilama))
        && !ctx.has(Item::Apocalypse_Bomb))
}
pub fn access_allow_warps_and_within_antarctica(ctx: &Context, world: &World) -> bool {
    // allow_warps and WITHIN `Antarctica`
    (world.allow_warps
        && (match get_region(ctx.position()) {
            RegionId::Antarctica => true,
            _ => false,
        }))
}
pub fn access_amagi__main_area__ctx__combo_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_combo and ($grab or $climb)
    (ctx.amagi__main_area__ctx__combo()
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_amagi__main_area__ctx__combo_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // ^_combo and $hook
    (ctx.amagi__main_area__ctx__combo() && helper__hook!(ctx, world))
}
pub fn access_amagi__secret_chamber__ctx__east_dur_esla_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_east_dur_esla and Nanite_Mist
    (ctx.amagi__secret_chamber__ctx__east_dur_esla() && ctx.has(Item::Nanite_Mist))
}
pub fn access_amagi__secret_chamber__ctx__east_dur_esla_and_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_east_dur_esla and Underwater_Movement and $hookhover
    ((ctx.amagi__secret_chamber__ctx__east_dur_esla() && ctx.has(Item::Underwater_Movement))
        && helper__hookhover!(ctx, world))
}
pub fn access_amagi__secret_chamber__ctx__west_dur_esla_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_west_dur_esla and Nanite_Mist
    (ctx.amagi__secret_chamber__ctx__west_dur_esla() && ctx.has(Item::Nanite_Mist))
}
pub fn access_amagi__secret_chamber__ctx__west_dur_esla_and_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_west_dur_esla and Underwater_Movement and $hookhover
    ((ctx.amagi__secret_chamber__ctx__west_dur_esla() && ctx.has(Item::Underwater_Movement))
        && helper__hookhover!(ctx, world))
}
pub fn access_amagi_breach_lower_hallway_gate(ctx: &Context, world: &World) -> bool {
    // Amagi_Breach_Lower_Hallway_Gate
    ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate)
}
pub fn access_amagi_breach_lower_hallway_gate_and_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Amagi_Breach_Lower_Hallway_Gate and Underwater_Movement and Slingshot_Hook and Drone_Hover
    (((ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate) && ctx.has(Item::Underwater_Movement))
        && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_amagi_breach_split_gate(ctx: &Context, world: &World) -> bool {
    // Amagi_Breach_Split_Gate
    ctx.has(Item::Amagi_Breach_Split_Gate)
}
pub fn access_amagi_breach_west_ruins_gate(ctx: &Context, world: &World) -> bool {
    // Amagi_Breach_West_Ruins_Gate
    ctx.has(Item::Amagi_Breach_West_Ruins_Gate)
}
pub fn access_amagi_breach_west_ruins_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // Amagi_Breach_West_Ruins_Gate and Underwater_Movement
    (ctx.has(Item::Amagi_Breach_West_Ruins_Gate) && ctx.has(Item::Underwater_Movement))
}
pub fn access_amagi_breach_west_ruins_gate_and_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Amagi_Breach_West_Ruins_Gate and Underwater_Movement and Slingshot_Hook and Drone_Hover
    (((ctx.has(Item::Amagi_Breach_West_Ruins_Gate) && ctx.has(Item::Underwater_Movement))
        && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_amagi_dragon_eye_passage(ctx: &Context, world: &World) -> bool {
    // Amagi_Dragon_Eye_Passage
    ctx.has(Item::Amagi_Dragon_Eye_Passage)
}
pub fn access_amagi_gated_community_gate(ctx: &Context, world: &World) -> bool {
    // Amagi_Gated_Community_Gate
    ctx.has(Item::Amagi_Gated_Community_Gate)
}
pub fn access_amagi_gated_community_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // Amagi_Gated_Community_Gate and Underwater_Movement
    (ctx.has(Item::Amagi_Gated_Community_Gate) && ctx.has(Item::Underwater_Movement))
}
pub fn access_amagi_stronghold_boulder_1(ctx: &Context, world: &World) -> bool {
    // Amagi_Stronghold_Boulder_1
    ctx.has(Item::Amagi_Stronghold_Boulder_1)
}
pub fn access_amagi_stronghold_boulder_1_and_underwater_movement_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // Amagi_Stronghold_Boulder_1 and Underwater_Movement and ($grab or $climb)
    ((ctx.has(Item::Amagi_Stronghold_Boulder_1) && ctx.has(Item::Underwater_Movement))
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_amagi_stronghold_boulder_2(ctx: &Context, world: &World) -> bool {
    // Amagi_Stronghold_Boulder_2
    ctx.has(Item::Amagi_Stronghold_Boulder_2)
}
pub fn access_amagi_stronghold_boulder_2_and_invoke_grab(ctx: &Context, world: &World) -> bool {
    // Amagi_Stronghold_Boulder_2 and $grab
    (ctx.has(Item::Amagi_Stronghold_Boulder_2) && helper__grab!(ctx, world))
}
pub fn access_amagi_stronghold_left_wall(ctx: &Context, world: &World) -> bool {
    // Amagi_Stronghold_Left_Wall
    ctx.has(Item::Amagi_Stronghold_Left_Wall)
}
pub fn access_amagi_stronghold_left_wall_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // Amagi_Stronghold_Left_Wall and Underwater_Movement
    (ctx.has(Item::Amagi_Stronghold_Left_Wall) && ctx.has(Item::Underwater_Movement))
}
pub fn access_amagi_stronghold_wall_1(ctx: &Context, world: &World) -> bool {
    // Amagi_Stronghold_Wall_1
    ctx.has(Item::Amagi_Stronghold_Wall_1)
}
pub fn access_amagi_stronghold_wall_2(ctx: &Context, world: &World) -> bool {
    // Amagi_Stronghold_Wall_2
    ctx.has(Item::Amagi_Stronghold_Wall_2)
}
pub fn access_amagi_west_lake_gate(ctx: &Context, world: &World) -> bool {
    // Amagi_West_Lake_Gate
    ctx.has(Item::Amagi_West_Lake_Gate)
}
pub fn access_amagi_west_lake_gate_and_underwater_movement(ctx: &Context, world: &World) -> bool {
    // Amagi_West_Lake_Gate and Underwater_Movement
    (ctx.has(Item::Amagi_West_Lake_Gate) && ctx.has(Item::Underwater_Movement))
}
pub fn access_amagi_west_lake_surface_wall(ctx: &Context, world: &World) -> bool {
    // Amagi_West_Lake_Surface_Wall
    ctx.has(Item::Amagi_West_Lake_Surface_Wall)
}
pub fn access_amagi_wiggly_room_gate(ctx: &Context, world: &World) -> bool {
    // Amagi_Wiggly_Room_Gate
    ctx.has(Item::Amagi_Wiggly_Room_Gate)
}
pub fn access_annuna__boss_gate__ctx__door(ctx: &Context, world: &World) -> bool {
    // ^_door
    ctx.annuna__boss_gate__ctx__door()
}
pub fn access_annuna__east_bridge__ctx__combo(ctx: &Context, world: &World) -> bool {
    // ^_combo
    ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_annuna__east_bridge__ctx__combo_and_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_combo and $grab
    (ctx.annuna__east_bridge__ctx__combo() && helper__grab!(ctx, world))
}
pub fn access_annuna__east_bridge__ctx__combo_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_combo and $hook
    (ctx.annuna__east_bridge__ctx__combo() && helper__hook!(ctx, world))
}
pub fn access_annuna__invisible_enemies__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.annuna__invisible_enemies__ctx__door_opened()
}
pub fn access_annuna__invisible_enemies__ctx__door_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_opened and $hookhover
    (ctx.annuna__invisible_enemies__ctx__door_opened() && helper__hookhover!(ctx, world))
}
pub fn access_annuna__invisible_enemies__ctx__nw_utu(ctx: &Context, world: &World) -> bool {
    // ^_nw_utu
    ctx.annuna__invisible_enemies__ctx__nw_utu()
}
pub fn access_annuna__invisible_enemies__ctx__nw_utu_and_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_nw_utu and $melee_cskip
    (ctx.annuna__invisible_enemies__ctx__nw_utu() && helper__melee_cskip!(ctx, world))
}
pub fn access_annuna__invisible_enemies__ctx__nw_utu_and_invoke_melee_cskip_and_fast_travel(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_nw_utu and $melee_cskip and Fast_Travel
    ((ctx.annuna__invisible_enemies__ctx__nw_utu() && helper__melee_cskip!(ctx, world))
        && ctx.has(Item::Fast_Travel))
}
pub fn access_annuna__udug_gate__ctx__door(ctx: &Context, world: &World) -> bool {
    // ^_door
    ctx.annuna__udug_gate__ctx__door()
}
pub fn access_annuna__vertical_room__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.annuna__vertical_room__ctx__door_opened()
}
pub fn access_annuna__west_bridge__ctx__doors_opened(ctx: &Context, world: &World) -> bool {
    // ^_doors_opened
    ctx.annuna__west_bridge__ctx__doors_opened()
}
pub fn access_annuna__west_bridge__ctx__doors_opened_and_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_doors_opened and $grab
    (ctx.annuna__west_bridge__ctx__doors_opened() && helper__grab!(ctx, world))
}
pub fn access_annuna__west_bridge__ctx__doors_opened_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_doors_opened and $hook
    (ctx.annuna__west_bridge__ctx__doors_opened() && helper__hook!(ctx, world))
}
pub fn access_annuna__west_bridge__ctx__doors_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_doors_opened and $hookhover
    (ctx.annuna__west_bridge__ctx__doors_opened() && helper__hookhover!(ctx, world))
}
pub fn access_annuna__west_climb__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.annuna__west_climb__ctx__door_opened()
}
pub fn access_annuna_breach_factory_gate(ctx: &Context, world: &World) -> bool {
    // Annuna_Breach_Factory_Gate
    ctx.has(Item::Annuna_Breach_Factory_Gate)
}
pub fn access_annuna_breach_upper_gate(ctx: &Context, world: &World) -> bool {
    // Annuna_Breach_Upper_Gate
    ctx.has(Item::Annuna_Breach_Upper_Gate)
}
pub fn access_annuna_breach_upper_gate_and_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // Annuna_Breach_Upper_Gate and Slingshot_Hook
    (ctx.has(Item::Annuna_Breach_Upper_Gate) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_annuna_double_trouble_bosses_and_invoke_can_damage(
    ctx: &Context,
    world: &World,
) -> bool {
    // Annuna_Double_Trouble_Bosses and $can_damage
    (ctx.has(Item::Annuna_Double_Trouble_Bosses) && helper__can_damage!(ctx, world))
}
pub fn access_annuna_double_trouble_bosses_and_invoke_shockwave_and___boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
) -> bool {
    // Annuna_Double_Trouble_Bosses and $shockwave and (Boomerang or Boomerang_Upgrade)
    ((ctx.has(Item::Annuna_Double_Trouble_Bosses) && helper__shockwave!(ctx, world))
        && (ctx.has(Item::Boomerang) || ctx.has(Item::Boomerang_Upgrade)))
}
pub fn access_annuna_double_trouble_bosses_and_invoke_shockwave_and___invoke_weapon_or_anuman_or_boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
) -> bool {
    // Annuna_Double_Trouble_Bosses and $shockwave and ($weapon or Anuman or Boomerang or Boomerang_Upgrade)
    ((ctx.has(Item::Annuna_Double_Trouble_Bosses) && helper__shockwave!(ctx, world))
        && (((helper__weapon!(ctx, world) || ctx.has(Item::Anuman)) || ctx.has(Item::Boomerang))
            || ctx.has(Item::Boomerang_Upgrade)))
}
pub fn access_annuna_east_bridge_gate(ctx: &Context, world: &World) -> bool {
    // Annuna_East_Bridge_Gate
    ctx.has(Item::Annuna_East_Bridge_Gate)
}
pub fn access_annuna_east_bridge_gate_and_invoke_hookhover(ctx: &Context, world: &World) -> bool {
    // Annuna_East_Bridge_Gate and $hookhover
    (ctx.has(Item::Annuna_East_Bridge_Gate) && helper__hookhover!(ctx, world))
}
pub fn access_annuna_lower_gate(ctx: &Context, world: &World) -> bool {
    // Annuna_Lower_Gate
    ctx.has(Item::Annuna_Lower_Gate)
}
pub fn access_annuna_lower_gate_and_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // Annuna_Lower_Gate and Slingshot_Hook
    (ctx.has(Item::Annuna_Lower_Gate) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_annuna_mirror_match_switch(ctx: &Context, world: &World) -> bool {
    // Annuna_Mirror_Match_Switch
    ctx.has(Item::Annuna_Mirror_Match_Switch)
}
pub fn access_annuna_remote_training_gate(ctx: &Context, world: &World) -> bool {
    // Annuna_Remote_Training_Gate
    ctx.has(Item::Annuna_Remote_Training_Gate)
}
pub fn access_annuna_remote_training_gate_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Annuna_Remote_Training_Gate and $hookhover
    (ctx.has(Item::Annuna_Remote_Training_Gate) && helper__hookhover!(ctx, world))
}
pub fn access_annuna_vertical_room_gate(ctx: &Context, world: &World) -> bool {
    // Annuna_Vertical_Room_Gate
    ctx.has(Item::Annuna_Vertical_Room_Gate)
}
pub fn access_anuman(ctx: &Context, world: &World) -> bool {
    // Anuman
    ctx.has(Item::Anuman)
}
pub fn access_anuman_and_invoke_boomerang(ctx: &Context, world: &World) -> bool {
    // Anuman and $boomerang
    (ctx.has(Item::Anuman) && helper__boomerang!(ctx, world))
}
pub fn access_anuman_and_invoke_climb(ctx: &Context, world: &World) -> bool {
    // Anuman and $climb
    (ctx.has(Item::Anuman) && helper__climb!(ctx, world))
}
pub fn access_anuman_and_invoke_grab(ctx: &Context, world: &World) -> bool {
    // Anuman and $grab
    (ctx.has(Item::Anuman) && helper__grab!(ctx, world))
}
pub fn access_anuman_and_invoke_shockwave(ctx: &Context, world: &World) -> bool {
    // Anuman and $shockwave
    (ctx.has(Item::Anuman) && helper__shockwave!(ctx, world))
}
pub fn access_anuman_and_mode_eq_indra_and___ledge_grab_or_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Anuman and ^mode == 'Indra' and (Ledge_Grab or Slingshot_Hook)
    ((ctx.has(Item::Anuman) && ctx.mode() == enums::Mode::Indra)
        && (ctx.has(Item::Ledge_Grab) || ctx.has(Item::Slingshot_Hook)))
}
pub fn access_anuman_and_mode_ne_drone(ctx: &Context, world: &World) -> bool {
    // Anuman and ^mode != 'drone'
    (ctx.has(Item::Anuman) && ctx.mode() != enums::Mode::Drone)
}
pub fn access_anuman_and_slingshot_hook_and_drone_hover(ctx: &Context, world: &World) -> bool {
    // Anuman and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Anuman) && ctx.has(Item::Slingshot_Hook)) && ctx.has(Item::Drone_Hover))
}
pub fn access_anuman_or___invoke_hook_and___not_slingshot_weapon_or_invoke_visited__annuna_gt_invisible_enemies_gt_corner_cache_gt_flask(
    ctx: &Context,
    world: &World,
) -> bool {
    // Anuman or ($hook and (not Slingshot_Weapon or $visited(`Annuna > Invisible Enemies > Corner Cache > Flask`)))
    (ctx.has(Item::Anuman)
        || (helper__hook!(ctx, world)
            && (!ctx.has(Item::Slingshot_Weapon)
                || ctx.visited(LocationId::Annuna__Invisible_Enemies__Corner_Cache__Flask))))
}
pub fn access_apocalypse_bomb(ctx: &Context, world: &World) -> bool {
    // Apocalypse_Bomb
    ctx.has(Item::Apocalypse_Bomb)
}
pub fn access_apocalypse_bomb_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Apocalypse_Bomb and $hook
    (ctx.has(Item::Apocalypse_Bomb) && helper__hook!(ctx, world))
}
pub fn access_block_fast_travel_and_invoke_shockwave_and_fast_travel(
    ctx: &Context,
    world: &World,
) -> bool {
    // block_fast_travel and $shockwave and Fast_Travel
    ((world.block_fast_travel && helper__shockwave!(ctx, world)) && ctx.has(Item::Fast_Travel))
}
pub fn access_boomerang(ctx: &Context, world: &World) -> bool {
    // Boomerang
    ctx.has(Item::Boomerang)
}
pub fn access_breach_attractor(ctx: &Context, world: &World) -> bool {
    // Breach_Attractor
    ctx.has(Item::Breach_Attractor)
}
pub fn access_breach_attractor_and_anuman(ctx: &Context, world: &World) -> bool {
    // Breach_Attractor and Anuman
    (ctx.has(Item::Breach_Attractor) && ctx.has(Item::Anuman))
}
pub fn access_breach_attractor_and_mode_eq_drone_and_indra_within___glacier_gt_grid_39sub40_7sub9_glacier_gt_revival_glacier_gt_dock_outside_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
) -> bool {
    // Breach_Attractor and ^mode == 'drone' and ^indra WITHIN (`Glacier > Grid 39-40,7-9`, `Glacier > Revival`, `Glacier > Dock Outside`) and ^portal == ^portal_start
    (((ctx.has(Item::Breach_Attractor) && ctx.mode() == enums::Mode::Drone)
        && ctx.indra() != SpotId::None
        && matches!(
            get_area(ctx.indra()),
            AreaId::Glacier__Grid_39_40_7_9
                | AreaId::Glacier__Revival
                | AreaId::Glacier__Dock_Outside
        ))
        && ctx.portal() == data::portal_start(ctx.position()))
}
pub fn access_breach_attractor_and_mode_eq_drone_and_indra_within_annuna_gt_filter_teleporter_gt_shaft_top(
    ctx: &Context,
    world: &World,
) -> bool {
    // Breach_Attractor and ^mode == 'drone' and ^indra WITHIN `Annuna > Filter Teleporter > Shaft Top`
    ((ctx.has(Item::Breach_Attractor) && ctx.mode() == enums::Mode::Drone)
        && ctx.indra() == SpotId::Annuna__Filter_Teleporter__Shaft_Top)
}
pub fn access_defeat_indra(ctx: &Context, world: &World) -> bool {
    // Defeat_Indra
    ctx.has(Item::Defeat_Indra)
}
pub fn access_defeat_mus_a_m20(ctx: &Context, world: &World) -> bool {
    // Defeat_MUS_A_M20
    ctx.has(Item::Defeat_MUS_A_M20)
}
pub fn access_drone_hover(ctx: &Context, world: &World) -> bool {
    // Drone_Hover
    ctx.has(Item::Drone_Hover)
}
pub fn access_drone_hover_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // Drone_Hover and Nanite_Mist
    (ctx.has(Item::Drone_Hover) && ctx.has(Item::Nanite_Mist))
}
pub fn access_drone_melee_damage(ctx: &Context, world: &World) -> bool {
    // Drone_Melee_Damage
    ctx.has(Item::Drone_Melee_Damage)
}
pub fn access_drone_melee_damage_2(ctx: &Context, world: &World) -> bool {
    // Drone_Melee_Damage_2
    ctx.has(Item::Drone_Melee_Damage_2)
}
pub fn access_drone_melee_damage_3(ctx: &Context, world: &World) -> bool {
    // Drone_Melee_Damage_3
    ctx.has(Item::Drone_Melee_Damage_3)
}
pub fn access_drone_melee_speed(ctx: &Context, world: &World) -> bool {
    // Drone_Melee_Speed
    ctx.has(Item::Drone_Melee_Speed)
}
pub fn access_drone_melee_speed_2(ctx: &Context, world: &World) -> bool {
    // Drone_Melee_Speed_2
    ctx.has(Item::Drone_Melee_Speed_2)
}
pub fn access_ebih__base_camp__ctx__left_platform_moved(ctx: &Context, world: &World) -> bool {
    // ^_left_platform_moved
    ctx.ebih__base_camp__ctx__left_platform_moved()
}
pub fn access_ebih__ebih_west__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // ^_door_open
    ctx.ebih__ebih_west__ctx__door_open()
}
pub fn access_ebih__grid_25_10_12__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // ^_door_open
    ctx.ebih__grid_25_10_12__ctx__door_open()
}
pub fn access_ebih__truck_gate__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // ^_door_open
    ctx.ebih__truck_gate__ctx__door_open()
}
pub fn access_ebih__vertical_interchange__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // ^_door_open
    ctx.ebih__vertical_interchange__ctx__door_open()
}
pub fn access_ebih__waterfall__ctx__east_door_open(ctx: &Context, world: &World) -> bool {
    // ^_east_door_open
    ctx.ebih__waterfall__ctx__east_door_open()
}
pub fn access_ebih__waterfall__ctx__east_door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_east_door_open and $hook
    (ctx.ebih__waterfall__ctx__east_door_open() && helper__hook!(ctx, world))
}
pub fn access_ebih__waterfall__ctx__west_door_open(ctx: &Context, world: &World) -> bool {
    // ^_west_door_open
    ctx.ebih__waterfall__ctx__west_door_open()
}
pub fn access_ebih_alu(ctx: &Context, world: &World) -> bool {
    // Ebih_Alu
    ctx.has(Item::Ebih_Alu)
}
pub fn access_ebih_breach_double_gate_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Breach_Double_Gate_Gate
    ctx.has(Item::Ebih_Breach_Double_Gate_Gate)
}
pub fn access_ebih_breach_double_gate_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Breach_Double_Gate_Gate and Slingshot_Hook
    (ctx.has(Item::Ebih_Breach_Double_Gate_Gate) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_ebih_breach_in_n_out_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Breach_In_n_Out_Gate
    ctx.has(Item::Ebih_Breach_In_n_Out_Gate)
}
pub fn access_ebih_breach_lake_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Breach_Lake_Gate
    ctx.has(Item::Ebih_Breach_Lake_Gate)
}
pub fn access_ebih_breach_rock_block_rock(ctx: &Context, world: &World) -> bool {
    // Ebih_Breach_Rock_Block_Rock
    ctx.has(Item::Ebih_Breach_Rock_Block_Rock)
}
pub fn access_ebih_breach_rocky_cages_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Breach_Rocky_Cages_Gate
    ctx.has(Item::Ebih_Breach_Rocky_Cages_Gate)
}
pub fn access_ebih_breach_rocky_cages_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Breach_Rocky_Cages_Gate and Slingshot_Hook
    (ctx.has(Item::Ebih_Breach_Rocky_Cages_Gate) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_ebih_breach_spider_guards_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Breach_Spider_Guards_Gate
    ctx.has(Item::Ebih_Breach_Spider_Guards_Gate)
}
pub fn access_ebih_breach_spider_guards_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Breach_Spider_Guards_Gate and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Ebih_Breach_Spider_Guards_Gate) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_ebih_east_wall(ctx: &Context, world: &World) -> bool {
    // Ebih_East_Wall
    ctx.has(Item::Ebih_East_Wall)
}
pub fn access_ebih_gem_room_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Gem_Room_Gate
    ctx.has(Item::Ebih_Gem_Room_Gate)
}
pub fn access_ebih_hidden_portal_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Hidden_Portal_Gate
    ctx.has(Item::Ebih_Hidden_Portal_Gate)
}
pub fn access_ebih_interchange_block(ctx: &Context, world: &World) -> bool {
    // Ebih_Interchange_Block
    ctx.has(Item::Ebih_Interchange_Block)
}
pub fn access_ebih_interchange_gate(ctx: &Context, world: &World) -> bool {
    // Ebih_Interchange_Gate
    ctx.has(Item::Ebih_Interchange_Gate)
}
pub fn access_ebih_interchange_gate_and_ebih_interchange_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $grab
    ((ctx.has(Item::Ebih_Interchange_Gate) && ctx.has(Item::Ebih_Interchange_Block))
        && helper__grab!(ctx, world))
}
pub fn access_ebih_interchange_gate_and_ebih_interchange_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $hook
    ((ctx.has(Item::Ebih_Interchange_Gate) && ctx.has(Item::Ebih_Interchange_Block))
        && helper__hook!(ctx, world))
}
pub fn access_ebih_interchange_gate_and_not_ebih_interchange_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $grab
    ((ctx.has(Item::Ebih_Interchange_Gate) && !ctx.has(Item::Ebih_Interchange_Block))
        && helper__grab!(ctx, world))
}
pub fn access_ebih_interchange_gate_and_not_ebih_interchange_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $hook
    ((ctx.has(Item::Ebih_Interchange_Gate) && !ctx.has(Item::Ebih_Interchange_Block))
        && helper__hook!(ctx, world))
}
pub fn access_ebih_walled_off_wall(ctx: &Context, world: &World) -> bool {
    // Ebih_Walled_Off_Wall
    ctx.has(Item::Ebih_Walled_Off_Wall)
}
pub fn access_ebih_waterfall_wall(ctx: &Context, world: &World) -> bool {
    // Ebih_Waterfall_Wall
    ctx.has(Item::Ebih_Waterfall_Wall)
}
pub fn access_ebih_west_block(ctx: &Context, world: &World) -> bool {
    // Ebih_West_Block
    ctx.has(Item::Ebih_West_Block)
}
pub fn access_ellag(ctx: &Context, world: &World) -> bool {
    // Ellag
    ctx.has(Item::Ellag)
}
pub fn access_emergence__storage__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // ^_door_open
    ctx.emergence__storage__ctx__door_open()
}
pub fn access_emergence__storage__ctx__door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_open and $hook
    (ctx.emergence__storage__ctx__door_open() && helper__hook!(ctx, world))
}
pub fn access_emergence_dropoff_wall(ctx: &Context, world: &World) -> bool {
    // Emergence_Dropoff_Wall
    ctx.has(Item::Emergence_Dropoff_Wall)
}
pub fn access_emergence_dropoff_wall_and_anuman(ctx: &Context, world: &World) -> bool {
    // Emergence_Dropoff_Wall and Anuman
    (ctx.has(Item::Emergence_Dropoff_Wall) && ctx.has(Item::Anuman))
}
pub fn access_emergence_dropoff_wall_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Emergence_Dropoff_Wall and $hook
    (ctx.has(Item::Emergence_Dropoff_Wall) && helper__hook!(ctx, world))
}
pub fn access_emergence_dropoff_wall_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // Emergence_Dropoff_Wall and Nanite_Mist
    (ctx.has(Item::Emergence_Dropoff_Wall) && ctx.has(Item::Nanite_Mist))
}
pub fn access_emergence_rocks_fall_rock_1(ctx: &Context, world: &World) -> bool {
    // Emergence_Rocks_Fall_Rock_1
    ctx.has(Item::Emergence_Rocks_Fall_Rock_1)
}
pub fn access_emergence_rocks_fall_rock_2(ctx: &Context, world: &World) -> bool {
    // Emergence_Rocks_Fall_Rock_2
    ctx.has(Item::Emergence_Rocks_Fall_Rock_2)
}
pub fn access_emergence_rocks_fall_rock_3(ctx: &Context, world: &World) -> bool {
    // Emergence_Rocks_Fall_Rock_3
    ctx.has(Item::Emergence_Rocks_Fall_Rock_3)
}
pub fn access_emergence_rocks_fall_rock_4(ctx: &Context, world: &World) -> bool {
    // Emergence_Rocks_Fall_Rock_4
    ctx.has(Item::Emergence_Rocks_Fall_Rock_4)
}
pub fn access_emergence_storage_rock(ctx: &Context, world: &World) -> bool {
    // Emergence_Storage_Rock
    ctx.has(Item::Emergence_Storage_Rock)
}
pub fn access_emergence_storage_tunnel(ctx: &Context, world: &World) -> bool {
    // Emergence_Storage_Tunnel
    ctx.has(Item::Emergence_Storage_Tunnel)
}
pub fn access_fast_travel(ctx: &Context, world: &World) -> bool {
    // Fast_Travel
    ctx.has(Item::Fast_Travel)
}
pub fn access_fast_travel_and_invoke_boomerang(ctx: &Context, world: &World) -> bool {
    // Fast_Travel and $boomerang
    (ctx.has(Item::Fast_Travel) && helper__boomerang!(ctx, world))
}
pub fn access_fast_travel_and_invoke_boomerang2(ctx: &Context, world: &World) -> bool {
    // Fast_Travel and $boomerang2
    (ctx.has(Item::Fast_Travel) && helper__boomerang2!(ctx, world))
}
pub fn access_fast_travel_and_invoke_melee_cskip(ctx: &Context, world: &World) -> bool {
    // Fast_Travel and $melee_cskip
    (ctx.has(Item::Fast_Travel) && helper__melee_cskip!(ctx, world))
}
pub fn access_giguna__carnelian__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.giguna__carnelian__ctx__door_opened()
}
pub fn access_giguna__carnelian__ctx__lower_susar(ctx: &Context, world: &World) -> bool {
    // ^_lower_susar
    ctx.giguna__carnelian__ctx__lower_susar()
}
pub fn access_giguna__carnelian__ctx__lower_susar_and_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_lower_susar and $grab
    (ctx.giguna__carnelian__ctx__lower_susar() && helper__grab!(ctx, world))
}
pub fn access_giguna__carnelian__ctx__lower_susar_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_lower_susar and $hook
    (ctx.giguna__carnelian__ctx__lower_susar() && helper__hook!(ctx, world))
}
pub fn access_giguna__carnelian__ctx__upper_susar(ctx: &Context, world: &World) -> bool {
    // ^_upper_susar
    ctx.giguna__carnelian__ctx__upper_susar()
}
pub fn access_giguna__clouds__ctx__platform_and_invoke_attract_and_breach_sight_and_remote_drone(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_platform and $attract and Breach_Sight and Remote_Drone
    (((ctx.giguna__clouds__ctx__platform() && helper__attract!(ctx, world))
        && ctx.has(Item::Breach_Sight))
        && ctx.has(Item::Remote_Drone))
}
pub fn access_giguna__clouds__ctx__platform_and_invoke_attract_and_invoke_can_deploy_and_breach_sight(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_platform and $attract and $can_deploy and Breach_Sight
    (((ctx.giguna__clouds__ctx__platform() && helper__attract!(ctx, world))
        && helper__can_deploy!(ctx, world))
        && ctx.has(Item::Breach_Sight))
}
pub fn access_giguna__east_caverns__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.giguna__east_caverns__ctx__door_opened()
}
pub fn access_giguna__east_caverns__ctx__lower_susar(ctx: &Context, world: &World) -> bool {
    // ^_lower_susar
    ctx.giguna__east_caverns__ctx__lower_susar()
}
pub fn access_giguna__east_caverns__ctx__mid_susar(ctx: &Context, world: &World) -> bool {
    // ^_mid_susar
    ctx.giguna__east_caverns__ctx__mid_susar()
}
pub fn access_giguna__east_caverns__ctx__upper_susar(ctx: &Context, world: &World) -> bool {
    // ^_upper_susar
    ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_giguna__gateway__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.giguna__gateway__ctx__door_opened()
}
pub fn access_giguna__giguna_base__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // ^_door_open
    ctx.giguna__giguna_base__ctx__door_open()
}
pub fn access_giguna__giguna_base__ctx__door_open_and_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_open and $grab and $climb
    ((ctx.giguna__giguna_base__ctx__door_open() && helper__grab!(ctx, world))
        && helper__climb!(ctx, world))
}
pub fn access_giguna__giguna_base__ctx__door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_open and $hook
    (ctx.giguna__giguna_base__ctx__door_open() && helper__hook!(ctx, world))
}
pub fn access_giguna__giguna_northeast__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.giguna__giguna_northeast__ctx__door_opened()
}
pub fn access_giguna__giguna_northeast__ctx__door_opened_and___invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_opened and ($grab or $hook)
    (ctx.giguna__giguna_northeast__ctx__door_opened()
        && (helper__grab!(ctx, world) || helper__hook!(ctx, world)))
}
pub fn access_giguna__giguna_northeast__ctx__door_opened_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_opened and $hook
    (ctx.giguna__giguna_northeast__ctx__door_opened() && helper__hook!(ctx, world))
}
pub fn access_giguna__giguna_northeast__ctx__door_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_door_opened and $hookhover
    (ctx.giguna__giguna_northeast__ctx__door_opened() && helper__hookhover!(ctx, world))
}
pub fn access_giguna__labyrinth__ctx__door(ctx: &Context, world: &World) -> bool {
    // ^_door
    ctx.giguna__labyrinth__ctx__door()
}
pub fn access_giguna__ruins_top__ctx__doors_open(ctx: &Context, world: &World) -> bool {
    // ^_doors_open
    ctx.giguna__ruins_top__ctx__doors_open()
}
pub fn access_giguna__west_caverns__ctx__east_susar(ctx: &Context, world: &World) -> bool {
    // ^_east_susar
    ctx.giguna__west_caverns__ctx__east_susar()
}
pub fn access_giguna_boulder(ctx: &Context, world: &World) -> bool {
    // Giguna_Boulder
    ctx.has(Item::Giguna_Boulder)
}
pub fn access_giguna_breach__sw_save__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // ^_door_opened
    ctx.giguna_breach__sw_save__ctx__door_opened()
}
pub fn access_giguna_breach_crab_rave_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Breach_Crab_Rave_Gate
    ctx.has(Item::Giguna_Breach_Crab_Rave_Gate)
}
pub fn access_giguna_breach_gate_and_wall_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Breach_Gate_and_Wall_Gate
    ctx.has(Item::Giguna_Breach_Gate_and_Wall_Gate)
}
pub fn access_giguna_breach_lower_machinery_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Breach_Lower_Machinery_Gate
    ctx.has(Item::Giguna_Breach_Lower_Machinery_Gate)
}
pub fn access_giguna_breach_pinkness_rock(ctx: &Context, world: &World) -> bool {
    // Giguna_Breach_Pinkness_Rock
    ctx.has(Item::Giguna_Breach_Pinkness_Rock)
}
pub fn access_giguna_dual_path_switch(ctx: &Context, world: &World) -> bool {
    // Giguna_Dual_Path_Switch
    ctx.has(Item::Giguna_Dual_Path_Switch)
}
pub fn access_giguna_dual_path_switch_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // Giguna_Dual_Path_Switch and ($grab or $climb)
    (ctx.has(Item::Giguna_Dual_Path_Switch)
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_giguna_dual_path_switch_and_invoke_climb(ctx: &Context, world: &World) -> bool {
    // Giguna_Dual_Path_Switch and $climb
    (ctx.has(Item::Giguna_Dual_Path_Switch) && helper__climb!(ctx, world))
}
pub fn access_giguna_dual_path_switch_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Giguna_Dual_Path_Switch and $hook
    (ctx.has(Item::Giguna_Dual_Path_Switch) && helper__hook!(ctx, world))
}
pub fn access_giguna_gateway_block(ctx: &Context, world: &World) -> bool {
    // Giguna_Gateway_Block
    ctx.has(Item::Giguna_Gateway_Block)
}
pub fn access_giguna_gateway_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Gateway_Gate
    ctx.has(Item::Giguna_Gateway_Gate)
}
pub fn access_giguna_gubi_and_invoke_boomerang(ctx: &Context, world: &World) -> bool {
    // Giguna_Gubi and $boomerang
    (ctx.has(Item::Giguna_Gubi) && helper__boomerang!(ctx, world))
}
pub fn access_giguna_gubi_and_invoke_hover(ctx: &Context, world: &World) -> bool {
    // Giguna_Gubi and $hover
    (ctx.has(Item::Giguna_Gubi) && helper__hover!(ctx, world))
}
pub fn access_giguna_labyrinth_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Labyrinth_Gate
    ctx.has(Item::Giguna_Labyrinth_Gate)
}
pub fn access_giguna_northeast_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Northeast_Gate
    ctx.has(Item::Giguna_Northeast_Gate)
}
pub fn access_giguna_separator_bricks(ctx: &Context, world: &World) -> bool {
    // Giguna_Separator_Bricks
    ctx.has(Item::Giguna_Separator_Bricks)
}
pub fn access_giguna_separator_bricks_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Giguna_Separator_Bricks and $hook
    (ctx.has(Item::Giguna_Separator_Bricks) && helper__hook!(ctx, world))
}
pub fn access_giguna_vertical_interchange_gate(ctx: &Context, world: &World) -> bool {
    // Giguna_Vertical_Interchange_Gate
    ctx.has(Item::Giguna_Vertical_Interchange_Gate)
}
pub fn access_giguna_vertical_interchange_gate_and___invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
) -> bool {
    // Giguna_Vertical_Interchange_Gate and ($hook or Anuman)
    (ctx.has(Item::Giguna_Vertical_Interchange_Gate)
        && (helper__hook!(ctx, world) || ctx.has(Item::Anuman)))
}
pub fn access_giguna_vertical_interchange_rock(ctx: &Context, world: &World) -> bool {
    // Giguna_Vertical_Interchange_Rock
    ctx.has(Item::Giguna_Vertical_Interchange_Rock)
}
pub fn access_giguna_vertical_interchange_rock_and_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // Giguna_Vertical_Interchange_Rock and $grab
    (ctx.has(Item::Giguna_Vertical_Interchange_Rock) && helper__grab!(ctx, world))
}
pub fn access_giguna_vertical_interchange_rock_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Giguna_Vertical_Interchange_Rock and $hook
    (ctx.has(Item::Giguna_Vertical_Interchange_Rock) && helper__hook!(ctx, world))
}
pub fn access_giguna_vertical_interchange_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Giguna_Vertical_Interchange_Rock and $hookhover
    (ctx.has(Item::Giguna_Vertical_Interchange_Rock) && helper__hookhover!(ctx, world))
}
pub fn access_giguna_wasteland_door(ctx: &Context, world: &World) -> bool {
    // Giguna_Wasteland_Door
    ctx.has(Item::Giguna_Wasteland_Door)
}
pub fn access_glacier__ctx__hammonds_doors(ctx: &Context, world: &World) -> bool {
    // ^_hammonds_doors
    ctx.glacier__ctx__hammonds_doors()
}
pub fn access_glacier__ctx__hammonds_doors_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // ^_hammonds_doors and $hook
    (ctx.glacier__ctx__hammonds_doors() && helper__hook!(ctx, world))
}
pub fn access_glacier__ctx__hammonds_doors_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_hammonds_doors and $hookhover
    (ctx.glacier__ctx__hammonds_doors() && helper__hookhover!(ctx, world))
}
pub fn access_glacier__lonely_bull__ctx__door(ctx: &Context, world: &World) -> bool {
    // ^_door
    ctx.glacier__lonely_bull__ctx__door()
}
pub fn access_glacier__the_big_drop__ctx__bridge_open_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_bridge_open and Nanite_Mist
    (ctx.glacier__the_big_drop__ctx__bridge_open() && ctx.has(Item::Nanite_Mist))
}
pub fn access_glacier__vertical_room__ctx__lower_gatestones(ctx: &Context, world: &World) -> bool {
    // ^_lower_gatestones
    ctx.glacier__vertical_room__ctx__lower_gatestones()
}
pub fn access_glacier__vertical_room__ctx__lower_gatestones_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_lower_gatestones and Underwater_Movement
    (ctx.glacier__vertical_room__ctx__lower_gatestones() && ctx.has(Item::Underwater_Movement))
}
pub fn access_glacier__vertical_room__ctx__upper_gatestone(ctx: &Context, world: &World) -> bool {
    // ^_upper_gatestone
    ctx.glacier__vertical_room__ctx__upper_gatestone()
}
pub fn access_glacier_big_drop_rock(ctx: &Context, world: &World) -> bool {
    // Glacier_Big_Drop_Rock
    ctx.has(Item::Glacier_Big_Drop_Rock)
}
pub fn access_glacier_breach_spidery_connector_gate(ctx: &Context, world: &World) -> bool {
    // Glacier_Breach_Spidery_Connector_Gate
    ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate)
}
pub fn access_glacier_breach_spidery_connector_gate_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Glacier_Breach_Spidery_Connector_Gate and Drone_Hover
    (ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate) && ctx.has(Item::Drone_Hover))
}
pub fn access_glacier_breach_spidery_connector_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Glacier_Breach_Spidery_Connector_Gate and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_glacier_fortress_gate(ctx: &Context, world: &World) -> bool {
    // Glacier_Fortress_Gate
    ctx.has(Item::Glacier_Fortress_Gate)
}
pub fn access_glacier_fortress_gate_and___invoke_grab_or_invoke_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Glacier_Fortress_Gate and ($grab or $hover)
    (ctx.has(Item::Glacier_Fortress_Gate)
        && (helper__grab!(ctx, world) || helper__hover!(ctx, world)))
}
pub fn access_glacier_fortress_gate_and___invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
) -> bool {
    // Glacier_Fortress_Gate and ($hook or Anuman)
    (ctx.has(Item::Glacier_Fortress_Gate) && (helper__hook!(ctx, world) || ctx.has(Item::Anuman)))
}
pub fn access_glacier_gudam(ctx: &Context, world: &World) -> bool {
    // Glacier_Gudam
    ctx.has(Item::Glacier_Gudam)
}
pub fn access_glacier_gudam_and_invoke_shockwave(ctx: &Context, world: &World) -> bool {
    // Glacier_Gudam and $shockwave
    (ctx.has(Item::Glacier_Gudam) && helper__shockwave!(ctx, world))
}
pub fn access_glacier_sea_burial_rock(ctx: &Context, world: &World) -> bool {
    // Glacier_Sea_Burial_Rock
    ctx.has(Item::Glacier_Sea_Burial_Rock)
}
pub fn access_hammond_auth(ctx: &Context, world: &World) -> bool {
    // Hammond_Auth
    ctx.has(Item::Hammond_Auth)
}
pub fn access_health_upgrade(ctx: &Context, world: &World) -> bool {
    // Health_Upgrade
    ctx.has(Item::Health_Upgrade)
}
pub fn access_health_upgrade_2(ctx: &Context, world: &World) -> bool {
    // Health_Upgrade_2
    ctx.has(Item::Health_Upgrade_2)
}
pub fn access_health_upgrade_3(ctx: &Context, world: &World) -> bool {
    // Health_Upgrade_3
    ctx.has(Item::Health_Upgrade_3)
}
pub fn access_health_upgrade_4(ctx: &Context, world: &World) -> bool {
    // Health_Upgrade_4
    ctx.has(Item::Health_Upgrade_4)
}
pub fn access_if___mode_eq_drone____drone_melee_damage_3_and_drone_hover__else____invoke_weapon_and_melee_damage_3_and___boomerang_or_boomerang_upgrade_(
    ctx: &Context,
    world: &World,
) -> bool {
    // IF (^mode == 'drone') { Drone_Melee_Damage_3 and Drone_Hover } ELSE { $weapon and Melee_Damage_3 and (Boomerang or Boomerang_Upgrade) }
    if ctx.mode() == enums::Mode::Drone {
        (ctx.has(Item::Drone_Melee_Damage_3) && ctx.has(Item::Drone_Hover))
    } else {
        ((helper__weapon!(ctx, world) && ctx.has(Item::Melee_Damage_3))
            && (ctx.has(Item::Boomerang) || ctx.has(Item::Boomerang_Upgrade)))
    }
}
pub fn access_infect(ctx: &Context, world: &World) -> bool {
    // Infect
    ctx.has(Item::Infect)
}
pub fn access_infect_and_anuman_and_invoke_objective(ctx: &Context, world: &World) -> bool {
    // Infect and Anuman and $objective
    ((ctx.has(Item::Infect) && ctx.has(Item::Anuman)) && rule__objective!(ctx, world))
}
pub fn access_infect_and_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // Infect and ^_platform_moved
    (ctx.has(Item::Infect) && ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_infect_and_ebih__ebih_east__ctx__platform2_moved_and___invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Infect and ^_platform2_moved and ($grab or $hook)
    ((ctx.has(Item::Infect) && ctx.ebih__ebih_east__ctx__platform2_moved())
        && (helper__grab!(ctx, world) || helper__hook!(ctx, world)))
}
pub fn access_infect_and_invoke_grab_and_not_ebih__ebih_east__ctx__platform1_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // Infect and $grab and not ^_platform1_moved
    ((ctx.has(Item::Infect) && helper__grab!(ctx, world))
        && !ctx.ebih__ebih_east__ctx__platform1_moved())
}
pub fn access_infect_and_invoke_grab_and_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // Infect and $grab and not ^_platform2_moved
    ((ctx.has(Item::Infect) && helper__grab!(ctx, world))
        && !ctx.ebih__ebih_east__ctx__platform2_moved())
}
pub fn access_infect_and_not_anuman_and_invoke_objective(ctx: &Context, world: &World) -> bool {
    // Infect and not Anuman and $objective
    ((ctx.has(Item::Infect) && !ctx.has(Item::Anuman)) && rule__objective!(ctx, world))
}
pub fn access_infect_and_not_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // Infect and not ^_platform_moved
    (ctx.has(Item::Infect) && !ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_infect_and_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // Infect and not ^_platform2_moved
    (ctx.has(Item::Infect) && !ctx.ebih__ebih_east__ctx__platform2_moved())
}
pub fn access_infect_l1(ctx: &Context, world: &World) -> bool {
    // Infect_L1
    ctx.has(Item::Infect_L1)
}
pub fn access_infect_l2(ctx: &Context, world: &World) -> bool {
    // Infect_L2
    ctx.has(Item::Infect_L2)
}
pub fn access_infection_range(ctx: &Context, world: &World) -> bool {
    // Infection_Range
    ctx.has(Item::Infection_Range)
}
pub fn access_infection_range_2(ctx: &Context, world: &World) -> bool {
    // Infection_Range_2
    ctx.has(Item::Infection_Range_2)
}
pub fn access_infection_speed(ctx: &Context, world: &World) -> bool {
    // Infection_Speed
    ctx.has(Item::Infection_Speed)
}
pub fn access_invoke_activate(ctx: &Context, world: &World) -> bool {
    // $activate
    helper__activate!(ctx, world)
}
pub fn access_invoke_activate_and_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // $activate and ^_left_platform_moved
    (helper__activate!(ctx, world) && ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_invoke_activate_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // $activate and not ^_left_platform_moved
    (helper__activate!(ctx, world) && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_invoke_allegiance4(ctx: &Context, world: &World) -> bool {
    // $allegiance4
    helper__allegiance4!(ctx, world)
}
pub fn access_invoke_block_clip_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Left
    (helper__block_clip!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Left))
}
pub fn access_invoke_block_clip_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Right
    (helper__block_clip!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Right))
}
pub fn access_invoke_block_clip_and_slingshot_hook_and_not_uhrum_east_lake_block(
    ctx: &Context,
    world: &World,
) -> bool {
    // $block_clip and Slingshot_Hook and not Uhrum_East_Lake_Block
    ((helper__block_clip!(ctx, world) && ctx.has(Item::Slingshot_Hook))
        && !ctx.has(Item::Uhrum_East_Lake_Block))
}
pub fn access_invoke_block_clip_escape_and_not_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &World,
) -> bool {
    // $block_clip_escape and not Uhrum_Annuna_Corridor_Block
    (helper__block_clip_escape!(ctx, world) && !ctx.has(Item::Uhrum_Annuna_Corridor_Block))
}
pub fn access_invoke_bomberang_and_anuman_and_not_invoke_visited__glacier_gt_fortress_gt_inner_center_gt_shockwave_block(
    ctx: &Context,
    world: &World,
) -> bool {
    // $bomberang and Anuman and not $visited(`Glacier > Fortress > Inner Center > Shockwave Block`)
    ((helper__bomberang!(ctx, world) && ctx.has(Item::Anuman))
        && !ctx.visited(LocationId::Glacier__Fortress__Inner_Center__Shockwave_Block))
}
pub fn access_invoke_boomerang(ctx: &Context, world: &World) -> bool {
    // $boomerang
    helper__boomerang!(ctx, world)
}
pub fn access_invoke_boomerang2(ctx: &Context, world: &World) -> bool {
    // $boomerang2
    helper__boomerang2!(ctx, world)
}
pub fn access_invoke_boomerang2_and_ranged_damage_3_and_invoke_weapon_and_melee_damage_3_and_melee_speed_3(
    ctx: &Context,
    world: &World,
) -> bool {
    // $boomerang2 and Ranged_Damage_3 and $weapon and Melee_Damage_3 and Melee_Speed_3
    ((((helper__boomerang2!(ctx, world) && ctx.has(Item::Ranged_Damage_3))
        && helper__weapon!(ctx, world))
        && ctx.has(Item::Melee_Damage_3))
        && ctx.has(Item::Melee_Speed_3))
}
pub fn access_invoke_boomerang_and_fast_travel(ctx: &Context, world: &World) -> bool {
    // $boomerang and Fast_Travel
    (helper__boomerang!(ctx, world) && ctx.has(Item::Fast_Travel))
}
pub fn access_invoke_bs(ctx: &Context, world: &World) -> bool {
    // $bs
    helper__bs!(ctx, world)
}
pub fn access_invoke_can_damage(ctx: &Context, world: &World) -> bool {
    // $can_damage
    helper__can_damage!(ctx, world)
}
pub fn access_invoke_can_deploy(ctx: &Context, world: &World) -> bool {
    // $can_deploy
    helper__can_deploy!(ctx, world)
}
pub fn access_invoke_can_deploy_and___drone_hover_or_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // $can_deploy and (Drone_Hover or Slingshot_Hook)
    (helper__can_deploy!(ctx, world)
        && (ctx.has(Item::Drone_Hover) || ctx.has(Item::Slingshot_Hook)))
}
pub fn access_invoke_can_deploy_and_drone_hover(ctx: &Context, world: &World) -> bool {
    // $can_deploy and Drone_Hover
    (helper__can_deploy!(ctx, world) && ctx.has(Item::Drone_Hover))
}
pub fn access_invoke_can_deploy_and_drone_hover_and_ebih_walled_off_wall(
    ctx: &Context,
    world: &World,
) -> bool {
    // $can_deploy and Drone_Hover and Ebih_Walled_Off_Wall
    ((helper__can_deploy!(ctx, world) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Ebih_Walled_Off_Wall))
}
pub fn access_invoke_can_deploy_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // $can_deploy and Drone_Hover and Slingshot_Hook
    ((helper__can_deploy!(ctx, world) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Slingshot_Hook))
}
pub fn access_invoke_can_deploy_and_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // $can_deploy and Slingshot_Hook
    (helper__can_deploy!(ctx, world) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_invoke_can_deploy_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // $can_deploy and Slingshot_Hook and Drone_Hover
    ((helper__can_deploy!(ctx, world) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_invoke_charge(ctx: &Context, world: &World) -> bool {
    // $charge
    helper__charge!(ctx, world)
}
pub fn access_invoke_chargehover(ctx: &Context, world: &World) -> bool {
    // $chargehover
    helper__chargehover!(ctx, world)
}
pub fn access_invoke_climb(ctx: &Context, world: &World) -> bool {
    // $climb
    helper__climb!(ctx, world)
}
pub fn access_invoke_climb_and_annuna_east_bridge_gate(ctx: &Context, world: &World) -> bool {
    // $climb and Annuna_East_Bridge_Gate
    (helper__climb!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_climb_and_invoke_can_deploy_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // $climb and $can_deploy and Drone_Hover and Slingshot_Hook
    (((helper__climb!(ctx, world) && helper__can_deploy!(ctx, world))
        && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Slingshot_Hook))
}
pub fn access_invoke_climb_and_invoke_grab(ctx: &Context, world: &World) -> bool {
    // $climb and $grab
    (helper__climb!(ctx, world) && helper__grab!(ctx, world))
}
pub fn access_invoke_climb_and_invoke_grab_and_anuman(ctx: &Context, world: &World) -> bool {
    // $climb and $grab and Anuman
    ((helper__climb!(ctx, world) && helper__grab!(ctx, world)) && ctx.has(Item::Anuman))
}
pub fn access_invoke_climb_and_underwater_movement(ctx: &Context, world: &World) -> bool {
    // $climb and Underwater_Movement
    (helper__climb!(ctx, world) && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_climb_or___invoke_grab_and_anuman(ctx: &Context, world: &World) -> bool {
    // $climb or ($grab and Anuman)
    (helper__climb!(ctx, world) || (helper__grab!(ctx, world) && ctx.has(Item::Anuman)))
}
pub fn access_invoke_climb_or_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $climb or $hook
    (helper__climb!(ctx, world) || helper__hook!(ctx, world))
}
pub fn access_invoke_grab(ctx: &Context, world: &World) -> bool {
    // $grab
    helper__grab!(ctx, world)
}
pub fn access_invoke_grab_and_annuna_east_bridge_gate(ctx: &Context, world: &World) -> bool {
    // $grab and Annuna_East_Bridge_Gate
    (helper__grab!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_grab_and_anuman(ctx: &Context, world: &World) -> bool {
    // $grab and Anuman
    (helper__grab!(ctx, world) && ctx.has(Item::Anuman))
}
pub fn access_invoke_grab_and_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
) -> bool {
    // $grab and ^_door_open
    (helper__grab!(ctx, world) && ctx.ebih__ebih_west__ctx__door_open())
}
pub fn access_invoke_grab_and_ebih_hidden_portal_gate(ctx: &Context, world: &World) -> bool {
    // $grab and Ebih_Hidden_Portal_Gate
    (helper__grab!(ctx, world) && ctx.has(Item::Ebih_Hidden_Portal_Gate))
}
pub fn access_invoke_grab_and_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
) -> bool {
    // $grab and ^_mid_susar
    (helper__grab!(ctx, world) && ctx.giguna__east_caverns__ctx__mid_susar())
}
pub fn access_invoke_grab_and_giguna__ruins_west__ctx__kishib_handled(
    ctx: &Context,
    world: &World,
) -> bool {
    // $grab and ^_kishib_handled
    (helper__grab!(ctx, world) && ctx.giguna__ruins_west__ctx__kishib_handled())
}
pub fn access_invoke_grab_and_giguna_gateway_block(ctx: &Context, world: &World) -> bool {
    // $grab and Giguna_Gateway_Block
    (helper__grab!(ctx, world) && ctx.has(Item::Giguna_Gateway_Block))
}
pub fn access_invoke_grab_and_invoke_can_deploy(ctx: &Context, world: &World) -> bool {
    // $grab and $can_deploy
    (helper__grab!(ctx, world) && helper__can_deploy!(ctx, world))
}
pub fn access_invoke_grab_and_invoke_climb(ctx: &Context, world: &World) -> bool {
    // $grab and $climb
    (helper__grab!(ctx, world) && helper__climb!(ctx, world))
}
pub fn access_invoke_grab_and_switch_40_12(ctx: &Context, world: &World) -> bool {
    // $grab and Switch_40_12
    (helper__grab!(ctx, world) && ctx.has(Item::Switch_40_12))
}
pub fn access_invoke_grab_and_underwater_movement(ctx: &Context, world: &World) -> bool {
    // $grab and Underwater_Movement
    (helper__grab!(ctx, world) && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_grab_or_anuman(ctx: &Context, world: &World) -> bool {
    // $grab or Anuman
    (helper__grab!(ctx, world) || ctx.has(Item::Anuman))
}
pub fn access_invoke_grab_or_invoke_climb(ctx: &Context, world: &World) -> bool {
    // $grab or $climb
    (helper__grab!(ctx, world) || helper__climb!(ctx, world))
}
pub fn access_invoke_grab_or_invoke_climb_or_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $grab or $climb or $hook
    ((helper__grab!(ctx, world) || helper__climb!(ctx, world)) || helper__hook!(ctx, world))
}
pub fn access_invoke_grab_or_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $grab or $hook
    (helper__grab!(ctx, world) || helper__hook!(ctx, world))
}
pub fn access_invoke_grab_or_invoke_hover(ctx: &Context, world: &World) -> bool {
    // $grab or $hover
    (helper__grab!(ctx, world) || helper__hover!(ctx, world))
}
pub fn access_invoke_grab_or_underwater_movement(ctx: &Context, world: &World) -> bool {
    // $grab or Underwater_Movement
    (helper__grab!(ctx, world) || ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $hook
    helper__hook!(ctx, world)
}
pub fn access_invoke_hook_and_annuna__vertical_room__ctx__door_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and ^_door_opened
    (helper__hook!(ctx, world) && ctx.annuna__vertical_room__ctx__door_opened())
}
pub fn access_invoke_hook_and_annuna_east_bridge_gate(ctx: &Context, world: &World) -> bool {
    // $hook and Annuna_East_Bridge_Gate
    (helper__hook!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_hook_and_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and ^_door_open
    (helper__hook!(ctx, world) && ctx.ebih__ebih_west__ctx__door_open())
}
pub fn access_invoke_hook_and_ebih_hidden_portal_gate(ctx: &Context, world: &World) -> bool {
    // $hook and Ebih_Hidden_Portal_Gate
    (helper__hook!(ctx, world) && ctx.has(Item::Ebih_Hidden_Portal_Gate))
}
pub fn access_invoke_hook_and_emergence_rocks_fall_rock_2(ctx: &Context, world: &World) -> bool {
    // $hook and Emergence_Rocks_Fall_Rock_2
    (helper__hook!(ctx, world) && ctx.has(Item::Emergence_Rocks_Fall_Rock_2))
}
pub fn access_invoke_hook_and_emergence_rocks_fall_rock_3(ctx: &Context, world: &World) -> bool {
    // $hook and Emergence_Rocks_Fall_Rock_3
    (helper__hook!(ctx, world) && ctx.has(Item::Emergence_Rocks_Fall_Rock_3))
}
pub fn access_invoke_hook_and_emergence_rocks_fall_rock_4(ctx: &Context, world: &World) -> bool {
    // $hook and Emergence_Rocks_Fall_Rock_4
    (helper__hook!(ctx, world) && ctx.has(Item::Emergence_Rocks_Fall_Rock_4))
}
pub fn access_invoke_hook_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and ^_combo_entered
    (helper__hook!(ctx, world) && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_invoke_hook_and_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and ^_mid_susar
    (helper__hook!(ctx, world) && ctx.giguna__east_caverns__ctx__mid_susar())
}
pub fn access_invoke_hook_and_giguna_gateway_block(ctx: &Context, world: &World) -> bool {
    // $hook and Giguna_Gateway_Block
    (helper__hook!(ctx, world) && ctx.has(Item::Giguna_Gateway_Block))
}
pub fn access_invoke_hook_and_invoke_hover(ctx: &Context, world: &World) -> bool {
    // $hook and $hover
    (helper__hook!(ctx, world) && helper__hover!(ctx, world))
}
pub fn access_invoke_hook_and_invoke_hover_and_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and $hover and Emergence_Rocks_Fall_Rock_4
    ((helper__hook!(ctx, world) && helper__hover!(ctx, world))
        && ctx.has(Item::Emergence_Rocks_Fall_Rock_4))
}
pub fn access_invoke_hook_and_invoke_hover_and_glacier__vertical_room__ctx__upper_gatestone(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and $hover and ^_upper_gatestone
    ((helper__hook!(ctx, world) && helper__hover!(ctx, world))
        && ctx.glacier__vertical_room__ctx__upper_gatestone())
}
pub fn access_invoke_hook_and_invoke_hover_and_slingshot_charge(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and $hover and Slingshot_Charge
    ((helper__hook!(ctx, world) && helper__hover!(ctx, world)) && ctx.has(Item::Slingshot_Charge))
}
pub fn access_invoke_hook_and_invoke_hover_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and $hover and Slingshot_Weapon
    ((helper__hook!(ctx, world) && helper__hover!(ctx, world)) && ctx.has(Item::Slingshot_Weapon))
}
pub fn access_invoke_hook_and_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and $hover and Underwater_Movement
    ((helper__hook!(ctx, world) && helper__hover!(ctx, world))
        && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_hook_and_invoke_hover_and_underwater_movement_and_breach_attractor_and_anuman_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and $hover and Underwater_Movement and Breach_Attractor and Anuman and ^portal == ^portal_start
    (((((helper__hook!(ctx, world) && helper__hover!(ctx, world))
        && ctx.has(Item::Underwater_Movement))
        && ctx.has(Item::Breach_Attractor))
        && ctx.has(Item::Anuman))
        && ctx.portal() == data::portal_start(ctx.position()))
}
pub fn access_invoke_hook_and_not_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook and not ^_platform_moved
    (helper__hook!(ctx, world) && !ctx.ebih__drone_room__ctx__platform_moved())
}
pub fn access_invoke_hook_and_not_ebih_waterfall_block_left(ctx: &Context, world: &World) -> bool {
    // $hook and not Ebih_Waterfall_Block_Left
    (helper__hook!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Left))
}
pub fn access_invoke_hook_and_not_ebih_waterfall_block_right(ctx: &Context, world: &World) -> bool {
    // $hook and not Ebih_Waterfall_Block_Right
    (helper__hook!(ctx, world) && !ctx.has(Item::Ebih_Waterfall_Block_Right))
}
pub fn access_invoke_hook_and_underwater_movement(ctx: &Context, world: &World) -> bool {
    // $hook and Underwater_Movement
    (helper__hook!(ctx, world) && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_hook_or___anuman_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hook or (Anuman and ($grab or $climb))
    (helper__hook!(ctx, world)
        || (ctx.has(Item::Anuman) && (helper__grab!(ctx, world) || helper__climb!(ctx, world))))
}
pub fn access_invoke_hook_or___anuman_and_invoke_climb(ctx: &Context, world: &World) -> bool {
    // $hook or (Anuman and $climb)
    (helper__hook!(ctx, world) || (ctx.has(Item::Anuman) && helper__climb!(ctx, world)))
}
pub fn access_invoke_hook_or___anuman_and_invoke_grab(ctx: &Context, world: &World) -> bool {
    // $hook or (Anuman and $grab)
    (helper__hook!(ctx, world) || (ctx.has(Item::Anuman) && helper__grab!(ctx, world)))
}
pub fn access_invoke_hook_or___invoke_grab_and_anuman(ctx: &Context, world: &World) -> bool {
    // $hook or ($grab and Anuman)
    (helper__hook!(ctx, world) || (helper__grab!(ctx, world) && ctx.has(Item::Anuman)))
}
pub fn access_invoke_hook_or_anuman(ctx: &Context, world: &World) -> bool {
    // $hook or Anuman
    (helper__hook!(ctx, world) || ctx.has(Item::Anuman))
}
pub fn access_invoke_hook_or_invoke_hover(ctx: &Context, world: &World) -> bool {
    // $hook or $hover
    (helper__hook!(ctx, world) || helper__hover!(ctx, world))
}
pub fn access_invoke_hookhover(ctx: &Context, world: &World) -> bool {
    // $hookhover
    helper__hookhover!(ctx, world)
}
pub fn access_invoke_hookhover_and_amagi_gated_community_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hookhover and Amagi_Gated_Community_Gate and Underwater_Movement
    ((helper__hookhover!(ctx, world) && ctx.has(Item::Amagi_Gated_Community_Gate))
        && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_hookhover_and_amagi_gated_community_gate_and_underwater_movement_and_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hookhover and Amagi_Gated_Community_Gate and Underwater_Movement and ^_dur_esla
    (((helper__hookhover!(ctx, world) && ctx.has(Item::Amagi_Gated_Community_Gate))
        && ctx.has(Item::Underwater_Movement))
        && ctx.amagi__gated_community__ctx__dur_esla())
}
pub fn access_invoke_hookhover_and_annuna_east_bridge_gate(ctx: &Context, world: &World) -> bool {
    // $hookhover and Annuna_East_Bridge_Gate
    (helper__hookhover!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_hookhover_and_giguna__gateway__ctx__door_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hookhover and ^_door_opened
    (helper__hookhover!(ctx, world) && ctx.giguna__gateway__ctx__door_opened())
}
pub fn access_invoke_hookhover_and_underwater_movement(ctx: &Context, world: &World) -> bool {
    // $hookhover and Underwater_Movement
    (helper__hookhover!(ctx, world) && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_hookhover_and_underwater_movement_and_amagi_gated_community_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hookhover and Underwater_Movement and Amagi_Gated_Community_Gate
    ((helper__hookhover!(ctx, world) && ctx.has(Item::Underwater_Movement))
        && ctx.has(Item::Amagi_Gated_Community_Gate))
}
pub fn access_invoke_hookhover_or_invoke_spin(ctx: &Context, world: &World) -> bool {
    // $hookhover or $spin
    (helper__hookhover!(ctx, world) || helper__spin!(ctx, world))
}
pub fn access_invoke_hover(ctx: &Context, world: &World) -> bool {
    // $hover
    helper__hover!(ctx, world)
}
pub fn access_invoke_hover_and_anuman(ctx: &Context, world: &World) -> bool {
    // $hover and Anuman
    (helper__hover!(ctx, world) && ctx.has(Item::Anuman))
}
pub fn access_invoke_hover_and_anuman_and_underwater_movement_and___boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hover and Anuman and Underwater_Movement and (Boomerang or Boomerang_Upgrade)
    (((helper__hover!(ctx, world) && ctx.has(Item::Anuman)) && ctx.has(Item::Underwater_Movement))
        && (ctx.has(Item::Boomerang) || ctx.has(Item::Boomerang_Upgrade)))
}
pub fn access_invoke_hover_and_anuman_and_wall_climb(ctx: &Context, world: &World) -> bool {
    // $hover and Anuman and Wall_Climb
    ((helper__hover!(ctx, world) && ctx.has(Item::Anuman)) && ctx.has(Item::Wall_Climb))
}
pub fn access_invoke_hover_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $hover and $hook
    (helper__hover!(ctx, world) && helper__hook!(ctx, world))
}
pub fn access_invoke_hover_and_invoke_hook_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hover and $hook and ^_combo_entered
    ((helper__hover!(ctx, world) && helper__hook!(ctx, world))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_invoke_hover_and_invoke_hook_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // $hover and $hook and Nanite_Mist
    ((helper__hover!(ctx, world) && helper__hook!(ctx, world)) && ctx.has(Item::Nanite_Mist))
}
pub fn access_invoke_hover_and_invoke_hook_and_not_irikar__midwest__ctx__left_platform(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hover and $hook and not ^_left_platform
    ((helper__hover!(ctx, world) && helper__hook!(ctx, world))
        && !ctx.irikar__midwest__ctx__left_platform())
}
pub fn access_invoke_hover_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // $hover and Nanite_Mist
    (helper__hover!(ctx, world) && ctx.has(Item::Nanite_Mist))
}
pub fn access_invoke_hover_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hover and not ^_left_platform_moved
    (helper__hover!(ctx, world) && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_invoke_hover_and_underwater_movement(ctx: &Context, world: &World) -> bool {
    // $hover and Underwater_Movement
    (helper__hover!(ctx, world) && ctx.has(Item::Underwater_Movement))
}
pub fn access_invoke_hover_and_underwater_movement_and_breach_attractor_and_anuman_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
) -> bool {
    // $hover and Underwater_Movement and Breach_Attractor and Anuman and ^portal == ^portal_start
    ((((helper__hover!(ctx, world) && ctx.has(Item::Underwater_Movement))
        && ctx.has(Item::Breach_Attractor))
        && ctx.has(Item::Anuman))
        && ctx.portal() == data::portal_start(ctx.position()))
}
pub fn access_invoke_hover_or_anuman(ctx: &Context, world: &World) -> bool {
    // $hover or Anuman
    (helper__hover!(ctx, world) || ctx.has(Item::Anuman))
}
pub fn access_invoke_hover_or_invoke_grab(ctx: &Context, world: &World) -> bool {
    // $hover or $grab
    (helper__hover!(ctx, world) || helper__grab!(ctx, world))
}
pub fn access_invoke_hover_or_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $hover or $hook
    (helper__hover!(ctx, world) || helper__hook!(ctx, world))
}
pub fn access_invoke_hover_or_nanite_mist(ctx: &Context, world: &World) -> bool {
    // $hover or Nanite_Mist
    (helper__hover!(ctx, world) || ctx.has(Item::Nanite_Mist))
}
pub fn access_invoke_infinite_climb(ctx: &Context, world: &World) -> bool {
    // $infinite_climb
    helper__infinite_climb!(ctx, world)
}
pub fn access_invoke_infinite_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // $infinite_climb and Annuna_East_Bridge_Gate
    (helper__infinite_climb!(ctx, world) && ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_infinite_climb_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // $infinite_climb and not Annuna_East_Bridge_Gate
    (helper__infinite_climb!(ctx, world) && !ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_infinite_climb_and_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // $infinite_climb and Slingshot_Hook
    (helper__infinite_climb!(ctx, world) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_invoke_infinite_climb_and_slingshot_hook_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // $infinite_climb and Slingshot_Hook and not Annuna_East_Bridge_Gate
    ((helper__infinite_climb!(ctx, world) && ctx.has(Item::Slingshot_Hook))
        && !ctx.has(Item::Annuna_East_Bridge_Gate))
}
pub fn access_invoke_melee(ctx: &Context, world: &World) -> bool {
    // $melee
    helper__melee!(ctx, world)
}
pub fn access_invoke_melee_and_not_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $melee and not ^_dur_esla
    (helper__melee!(ctx, world) && !ctx.amagi__gated_community__ctx__dur_esla())
}
pub fn access_invoke_melee_and_not_amagi__secret_chamber__ctx__east_dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $melee and not ^_east_dur_esla
    (helper__melee!(ctx, world) && !ctx.amagi__secret_chamber__ctx__east_dur_esla())
}
pub fn access_invoke_melee_and_not_amagi__secret_chamber__ctx__west_dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $melee and not ^_west_dur_esla
    (helper__melee!(ctx, world) && !ctx.amagi__secret_chamber__ctx__west_dur_esla())
}
pub fn access_invoke_melee_cskip(ctx: &Context, world: &World) -> bool {
    // $melee_cskip
    helper__melee_cskip!(ctx, world)
}
pub fn access_invoke_melee_cskip_and_fast_travel(ctx: &Context, world: &World) -> bool {
    // $melee_cskip and Fast_Travel
    (helper__melee_cskip!(ctx, world) && ctx.has(Item::Fast_Travel))
}
pub fn access_invoke_more_refills(ctx: &Context, world: &World) -> bool {
    // $more_refills
    helper__more_refills!(ctx, world)
}
pub fn access_invoke_offset(ctx: &Context, world: &World) -> bool {
    // $offset
    helper__offset!(ctx, world)
}
pub fn access_invoke_open(ctx: &Context, world: &World) -> bool {
    // $open
    helper__open!(ctx, world)
}
pub fn access_invoke_open_and_invoke_range1(ctx: &Context, world: &World) -> bool {
    // $open and $range1
    (helper__open!(ctx, world) && helper__range1!(ctx, world))
}
pub fn access_invoke_open_and_invoke_range2(ctx: &Context, world: &World) -> bool {
    // $open and $range2
    (helper__open!(ctx, world) && helper__range2!(ctx, world))
}
pub fn access_invoke_open_and_invoke_range2_and_not_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $open and $range2 and not ^_doors_opened
    ((helper__open!(ctx, world) && helper__range2!(ctx, world))
        && !ctx.annuna__west_bridge__ctx__doors_opened())
}
pub fn access_invoke_open_and_invoke_range3(ctx: &Context, world: &World) -> bool {
    // $open and $range3
    (helper__open!(ctx, world) && helper__range3!(ctx, world))
}
pub fn access_invoke_open_and_not_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $open and not ^_doors_opened
    (helper__open!(ctx, world) && !ctx.annuna__west_bridge__ctx__doors_opened())
}
pub fn access_invoke_open_and_not_ebih__vertical_interchange__ctx__door_open(
    ctx: &Context,
    world: &World,
) -> bool {
    // $open and not ^_door_open
    (helper__open!(ctx, world) && !ctx.ebih__vertical_interchange__ctx__door_open())
}
pub fn access_invoke_open_and_not_ebih__vertical_interchange__ctx__door_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
) -> bool {
    // $open and not ^_door_open and $range2
    ((helper__open!(ctx, world) && !ctx.ebih__vertical_interchange__ctx__door_open())
        && helper__range2!(ctx, world))
}
pub fn access_invoke_overheat(ctx: &Context, world: &World) -> bool {
    // $overheat
    helper__overheat!(ctx, world)
}
pub fn access_invoke_overheat_and_invoke_can_damage(ctx: &Context, world: &World) -> bool {
    // $overheat and $can_damage
    (helper__overheat!(ctx, world) && helper__can_damage!(ctx, world))
}
pub fn access_invoke_platform_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // $platform and $hook and $hover
    ((helper__platform!(ctx, world) && helper__hook!(ctx, world)) && helper__hover!(ctx, world))
}
pub fn access_invoke_platform_and_invoke_hook_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // $platform and $hook and not ^_left_platform_moved
    ((helper__platform!(ctx, world) && helper__hook!(ctx, world))
        && !ctx.ebih__base_camp__ctx__left_platform_moved())
}
pub fn access_invoke_remote_boomerang(ctx: &Context, world: &World) -> bool {
    // $remote_boomerang
    helper__remote_boomerang!(ctx, world)
}
pub fn access_invoke_shockwave(ctx: &Context, world: &World) -> bool {
    // $shockwave
    helper__shockwave!(ctx, world)
}
pub fn access_invoke_shockwave_and_not_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $shockwave and not ^_dur_esla
    (helper__shockwave!(ctx, world) && !ctx.amagi__gated_community__ctx__dur_esla())
}
pub fn access_invoke_shockwave_and_not_amagi__secret_chamber__ctx__east_dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $shockwave and not ^_east_dur_esla
    (helper__shockwave!(ctx, world) && !ctx.amagi__secret_chamber__ctx__east_dur_esla())
}
pub fn access_invoke_shockwave_and_not_amagi__secret_chamber__ctx__west_dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // $shockwave and not ^_west_dur_esla
    (helper__shockwave!(ctx, world) && !ctx.amagi__secret_chamber__ctx__west_dur_esla())
}
pub fn access_invoke_shockwave_and_not_defeat_mus_a_m20(ctx: &Context, world: &World) -> bool {
    // $shockwave and not Defeat_MUS_A_M20
    (helper__shockwave!(ctx, world) && !ctx.has(Item::Defeat_MUS_A_M20))
}
pub fn access_invoke_slow(ctx: &Context, world: &World) -> bool {
    // $slow
    helper__slow!(ctx, world)
}
pub fn access_invoke_spin(ctx: &Context, world: &World) -> bool {
    // $spin
    helper__spin!(ctx, world)
}
pub fn access_invoke_spinhover(ctx: &Context, world: &World) -> bool {
    // $spinhover
    helper__spinhover!(ctx, world)
}
pub fn access_invoke_sync(ctx: &Context, world: &World) -> bool {
    // $sync
    helper__sync!(ctx, world)
}
pub fn access_invoke_sync_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // $sync and $hook
    (helper__sync!(ctx, world) && helper__hook!(ctx, world))
}
pub fn access_invoke_unlock3_and_invoke_range2_and_not_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock3 and $range2 and not ^_door_opened
    ((helper__unlock3!(ctx, world) && helper__range2!(ctx, world))
        && !ctx.giguna__giguna_northeast__ctx__door_opened())
}
pub fn access_invoke_unlock3_and_not_giguna__carnelian__ctx__door_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock3 and not ^_door_opened
    (helper__unlock3!(ctx, world) && !ctx.giguna__carnelian__ctx__door_opened())
}
pub fn access_invoke_unlock3_and_not_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock3 and not ^_door_opened
    (helper__unlock3!(ctx, world) && !ctx.giguna__giguna_northeast__ctx__door_opened())
}
pub fn access_invoke_unlock3_and_not_glacier__lonely_bull__ctx__door(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock3 and not ^_door
    (helper__unlock3!(ctx, world) && !ctx.glacier__lonely_bull__ctx__door())
}
pub fn access_invoke_unlock4_and_invoke_range2(ctx: &Context, world: &World) -> bool {
    // $unlock4 and $range2
    (helper__unlock4!(ctx, world) && helper__range2!(ctx, world))
}
pub fn access_invoke_unlock4_and_invoke_range2_and_not_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock4 and $range2 and not ^_door_open
    ((helper__unlock4!(ctx, world) && helper__range2!(ctx, world))
        && !ctx.emergence__storage__ctx__door_open())
}
pub fn access_invoke_unlock4_and_not_annuna__boss_gate__ctx__door(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock4 and not ^_door
    (helper__unlock4!(ctx, world) && !ctx.annuna__boss_gate__ctx__door())
}
pub fn access_invoke_unlock4_and_not_annuna__udug_gate__ctx__door(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock4 and not ^_door
    (helper__unlock4!(ctx, world) && !ctx.annuna__udug_gate__ctx__door())
}
pub fn access_invoke_unlock4_and_not_annuna__west_climb__ctx__door_opened(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock4 and not ^_door_opened
    (helper__unlock4!(ctx, world) && !ctx.annuna__west_climb__ctx__door_opened())
}
pub fn access_invoke_unlock4_and_not_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
) -> bool {
    // $unlock4 and not ^_door_open
    (helper__unlock4!(ctx, world) && !ctx.emergence__storage__ctx__door_open())
}
pub fn access_irikar__basement_portal__ctx__platform_moved_and_invoke_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^_platform_moved and $hook
    (ctx.irikar__basement_portal__ctx__platform_moved() && helper__hook!(ctx, world))
}
pub fn access_irikar_breach_buried_treasure_pillar(ctx: &Context, world: &World) -> bool {
    // Irikar_Breach_Buried_Treasure_Pillar
    ctx.has(Item::Irikar_Breach_Buried_Treasure_Pillar)
}
pub fn access_irikar_breach_uhrum_connector_wall_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Irikar_Breach_Uhrum_Connector_Wall and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Irikar_Breach_Uhrum_Connector_Wall) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_irikar_gudam(ctx: &Context, world: &World) -> bool {
    // Irikar_Gudam
    ctx.has(Item::Irikar_Gudam)
}
pub fn access_irikar_gudam_and_invoke_shockwave(ctx: &Context, world: &World) -> bool {
    // Irikar_Gudam and $shockwave
    (ctx.has(Item::Irikar_Gudam) && helper__shockwave!(ctx, world))
}
pub fn access_irikar_royal_storage_wall(ctx: &Context, world: &World) -> bool {
    // Irikar_Royal_Storage_Wall
    ctx.has(Item::Irikar_Royal_Storage_Wall)
}
pub fn access_map__amagi__east_lake__save(ctx: &Context, world: &World) -> bool {
    // ^map__amagi__east_lake__save
    ctx.map__amagi__east_lake__save()
}
pub fn access_map__amagi__main_area__save(ctx: &Context, world: &World) -> bool {
    // ^map__amagi__main_area__save
    ctx.map__amagi__main_area__save()
}
pub fn access_map__amagi_breach__divided__save(ctx: &Context, world: &World) -> bool {
    // ^map__amagi_breach__divided__save
    ctx.map__amagi_breach__divided__save()
}
pub fn access_map__amagi_breach__east_entrance__save(ctx: &Context, world: &World) -> bool {
    // ^map__amagi_breach__east_entrance__save
    ctx.map__amagi_breach__east_entrance__save()
}
pub fn access_map__amagi_breach__east_ruins__save(ctx: &Context, world: &World) -> bool {
    // ^map__amagi_breach__east_ruins__save
    ctx.map__amagi_breach__east_ruins__save()
}
pub fn access_map__amagi_breach__upper_lake__save(ctx: &Context, world: &World) -> bool {
    // ^map__amagi_breach__upper_lake__save
    ctx.map__amagi_breach__upper_lake__save()
}
pub fn access_map__annuna__center_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna__center_save__save
    ctx.map__annuna__center_save__save()
}
pub fn access_map__annuna__factory_entrance__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna__factory_entrance__save
    ctx.map__annuna__factory_entrance__save()
}
pub fn access_map__annuna__mirror_match__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna__mirror_match__save
    ctx.map__annuna__mirror_match__save()
}
pub fn access_map__annuna__upper_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna__upper_save__save
    ctx.map__annuna__upper_save__save()
}
pub fn access_map__annuna__vertical_room__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna__vertical_room__save
    ctx.map__annuna__vertical_room__save()
}
pub fn access_map__annuna_breach__bottom__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna_breach__bottom__save
    ctx.map__annuna_breach__bottom__save()
}
pub fn access_map__annuna_breach__bridge__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna_breach__bridge__save
    ctx.map__annuna_breach__bridge__save()
}
pub fn access_map__annuna_breach__double_corridor__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna_breach__double_corridor__save
    ctx.map__annuna_breach__double_corridor__save()
}
pub fn access_map__annuna_breach__enclosed__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna_breach__enclosed__save
    ctx.map__annuna_breach__enclosed__save()
}
pub fn access_map__annuna_breach__north_hallway__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna_breach__north_hallway__save
    ctx.map__annuna_breach__north_hallway__save()
}
pub fn access_map__annuna_breach__rear_entrance__save(ctx: &Context, world: &World) -> bool {
    // ^map__annuna_breach__rear_entrance__save
    ctx.map__annuna_breach__rear_entrance__save()
}
pub fn access_map__ebih__base_camp__save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih__base_camp__save
    ctx.map__ebih__base_camp__save()
}
pub fn access_map__ebih__ebih_west__lower_save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih__ebih_west__lower_save
    ctx.map__ebih__ebih_west__lower_save()
}
pub fn access_map__ebih__ebih_west__mid_save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih__ebih_west__mid_save
    ctx.map__ebih__ebih_west__mid_save()
}
pub fn access_map__ebih__ebih_west__upper_save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih__ebih_west__upper_save
    ctx.map__ebih__ebih_west__upper_save()
}
pub fn access_map__ebih__hidden_portal__save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih__hidden_portal__save
    ctx.map__ebih__hidden_portal__save()
}
pub fn access_map__ebih_breach__in_n_out__save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih_breach__in_n_out__save
    ctx.map__ebih_breach__in_n_out__save()
}
pub fn access_map__ebih_breach__peak__save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih_breach__peak__save
    ctx.map__ebih_breach__peak__save()
}
pub fn access_map__ebih_breach__portals_101__save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih_breach__portals_101__save
    ctx.map__ebih_breach__portals_101__save()
}
pub fn access_map__ebih_breach__rock_block__save(ctx: &Context, world: &World) -> bool {
    // ^map__ebih_breach__rock_block__save
    ctx.map__ebih_breach__rock_block__save()
}
pub fn access_map__emergence__camp_exterior__save(ctx: &Context, world: &World) -> bool {
    // ^map__emergence__camp_exterior__save
    ctx.map__emergence__camp_exterior__save()
}
pub fn access_map__giguna__giguna_base__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna__giguna_base__save
    ctx.map__giguna__giguna_base__save()
}
pub fn access_map__giguna__giguna_northeast__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna__giguna_northeast__save
    ctx.map__giguna__giguna_northeast__save()
}
pub fn access_map__giguna__labyrinth__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna__labyrinth__save
    ctx.map__giguna__labyrinth__save()
}
pub fn access_map__giguna__ruins_top__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna__ruins_top__save
    ctx.map__giguna__ruins_top__save()
}
pub fn access_map__giguna__ruins_west__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna__ruins_west__save
    ctx.map__giguna__ruins_west__save()
}
pub fn access_map__giguna__separator__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna__separator__save
    ctx.map__giguna__separator__save()
}
pub fn access_map__giguna_breach__east__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna_breach__east__save
    ctx.map__giguna_breach__east__save()
}
pub fn access_map__giguna_breach__labyrinth__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna_breach__labyrinth__save
    ctx.map__giguna_breach__labyrinth__save()
}
pub fn access_map__giguna_breach__peak__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna_breach__peak__save
    ctx.map__giguna_breach__peak__save()
}
pub fn access_map__giguna_breach__south__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna_breach__south__save
    ctx.map__giguna_breach__south__save()
}
pub fn access_map__giguna_breach__sw_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__giguna_breach__sw_save__save
    ctx.map__giguna_breach__sw_save__save()
}
pub fn access_map__glacier__revival__save(ctx: &Context, world: &World) -> bool {
    // ^map__glacier__revival__save
    ctx.map__glacier__revival__save()
}
pub fn access_map__glacier_breach__guarded_corridor__save(ctx: &Context, world: &World) -> bool {
    // ^map__glacier_breach__guarded_corridor__save
    ctx.map__glacier_breach__guarded_corridor__save()
}
pub fn access_map__glacier_breach__hammonds_breach__save(ctx: &Context, world: &World) -> bool {
    // ^map__glacier_breach__hammonds_breach__save
    ctx.map__glacier_breach__hammonds_breach__save()
}
pub fn access_map__glacier_breach__save_and_exit__save(ctx: &Context, world: &World) -> bool {
    // ^map__glacier_breach__save_and_exit__save
    ctx.map__glacier_breach__save_and_exit__save()
}
pub fn access_map__glacier_breach__south_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__glacier_breach__south_save__save
    ctx.map__glacier_breach__south_save__save()
}
pub fn access_map__glacier_breach__west_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__glacier_breach__west_save__save
    ctx.map__glacier_breach__west_save__save()
}
pub fn access_map__irikar__beach_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar__beach_save__save
    ctx.map__irikar__beach_save__save()
}
pub fn access_map__irikar__hub__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar__hub__save
    ctx.map__irikar__hub__save()
}
pub fn access_map__irikar__midwest__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar__midwest__save
    ctx.map__irikar__midwest__save()
}
pub fn access_map__irikar_breach__basement_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar_breach__basement_save__save
    ctx.map__irikar_breach__basement_save__save()
}
pub fn access_map__irikar_breach__corridor__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar_breach__corridor__save
    ctx.map__irikar_breach__corridor__save()
}
pub fn access_map__irikar_breach__gauntlet__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar_breach__gauntlet__save
    ctx.map__irikar_breach__gauntlet__save()
}
pub fn access_map__irikar_breach__save_room__save(ctx: &Context, world: &World) -> bool {
    // ^map__irikar_breach__save_room__save
    ctx.map__irikar_breach__save_room__save()
}
pub fn access_map__uhrum__annuna_corridor__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum__annuna_corridor__save
    ctx.map__uhrum__annuna_corridor__save()
}
pub fn access_map__uhrum__emergence_save__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum__emergence_save__save
    ctx.map__uhrum__emergence_save__save()
}
pub fn access_map__uhrum__save_room__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum__save_room__save
    ctx.map__uhrum__save_room__save()
}
pub fn access_map__uhrum__west_entrance__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum__west_entrance__save
    ctx.map__uhrum__west_entrance__save()
}
pub fn access_map__uhrum_breach__annuna_gate__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum_breach__annuna_gate__save
    ctx.map__uhrum_breach__annuna_gate__save()
}
pub fn access_map__uhrum_breach__east_glitch__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum_breach__east_glitch__save
    ctx.map__uhrum_breach__east_glitch__save()
}
pub fn access_map__uhrum_breach__locked_down__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum_breach__locked_down__save
    ctx.map__uhrum_breach__locked_down__save()
}
pub fn access_map__uhrum_breach__save_and_go__save(ctx: &Context, world: &World) -> bool {
    // ^map__uhrum_breach__save_and_go__save
    ctx.map__uhrum_breach__save_and_go__save()
}
pub fn access_melee_damage(ctx: &Context, world: &World) -> bool {
    // Melee_Damage
    ctx.has(Item::Melee_Damage)
}
pub fn access_melee_damage_2(ctx: &Context, world: &World) -> bool {
    // Melee_Damage_2
    ctx.has(Item::Melee_Damage_2)
}
pub fn access_melee_speed(ctx: &Context, world: &World) -> bool {
    // Melee_Speed
    ctx.has(Item::Melee_Speed)
}
pub fn access_melee_speed_2(ctx: &Context, world: &World) -> bool {
    // Melee_Speed_2
    ctx.has(Item::Melee_Speed_2)
}
pub fn access_mode_eq_drone(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone'
    ctx.mode() == enums::Mode::Drone
}
pub fn access_mode_eq_drone_and_apocalypse_seals_wall(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Apocalypse_Seals_Wall
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Apocalypse_Seals_Wall))
}
pub fn access_mode_eq_drone_and_drone_melee_damage_3_and_drone_melee_speed_2_and_infect(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^mode == 'drone' and Drone_Melee_Damage_3 and Drone_Melee_Speed_2 and Infect
    (((ctx.mode() == enums::Mode::Drone && ctx.has(Item::Drone_Melee_Damage_3))
        && ctx.has(Item::Drone_Melee_Speed_2))
        && ctx.has(Item::Infect))
}
pub fn access_mode_eq_drone_and_ebih_waterfall_block_left(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Left
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Ebih_Waterfall_Block_Left))
}
pub fn access_mode_eq_drone_and_ebih_waterfall_block_right(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Right
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Ebih_Waterfall_Block_Right))
}
pub fn access_mode_eq_drone_and_fast_travel(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Fast_Travel
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Fast_Travel))
}
pub fn access_mode_eq_drone_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^mode == 'drone' and ^_combo_entered
    (ctx.mode() == enums::Mode::Drone && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_mode_eq_drone_and_giguna_dual_path_wall(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Giguna_Dual_Path_Wall
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Giguna_Dual_Path_Wall))
}
pub fn access_mode_eq_drone_and_giguna_wasteland_passage_h(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Giguna_Wasteland_Passage_H
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Giguna_Wasteland_Passage_H))
}
pub fn access_mode_eq_drone_and_indra_eq_giguna_gt_separator_gt_platform(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^mode == 'drone' and ^indra == `Giguna > Separator > Platform`
    (ctx.mode() == enums::Mode::Drone && ctx.indra() == SpotId::Giguna__Separator__Platform)
}
pub fn access_mode_eq_drone_and_mist_upgrade_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    ((ctx.mode() == enums::Mode::Drone && ctx.has(Item::Mist_Upgrade))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_mode_eq_drone_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Nanite_Mist
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Nanite_Mist))
}
pub fn access_mode_eq_drone_and_nanite_mist_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^mode == 'drone' and Nanite_Mist and ^_combo_entered
    ((ctx.mode() == enums::Mode::Drone && ctx.has(Item::Nanite_Mist))
        && ctx.giguna__east_caverns__ctx__combo_entered())
}
pub fn access_mode_eq_drone_and_portal_eq_position_and_flipside_ne_invoke_default_and___not_portal_hidden_or_breach_sight_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^mode == 'drone' and ^portal == ^position and ^flipside != $default and (not ^portal_hidden or Breach_Sight) and not Apocalypse_Bomb
    ((((ctx.mode() == enums::Mode::Drone && ctx.portal() == ctx.position())
        && data::flipside(ctx.position()) != Default::default())
        && (!data::portal_hidden(ctx.position()) || ctx.has(Item::Breach_Sight)))
        && !ctx.has(Item::Apocalypse_Bomb))
}
pub fn access_mode_eq_drone_and_sniper_valley_rock_2(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Sniper_Valley_Rock_2
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Sniper_Valley_Rock_2))
}
pub fn access_mode_eq_drone_and_uhrum_west_glitch(ctx: &Context, world: &World) -> bool {
    // ^mode == 'drone' and Uhrum_West_Glitch
    (ctx.mode() == enums::Mode::Drone && ctx.has(Item::Uhrum_West_Glitch))
}
pub fn access_mode_ne_drone(ctx: &Context, world: &World) -> bool {
    // ^mode != 'drone'
    ctx.mode() != enums::Mode::Drone
}
pub fn access_mode_ne_drone_and_ice_axe(ctx: &Context, world: &World) -> bool {
    // ^mode != 'drone' and Ice_Axe
    (ctx.mode() != enums::Mode::Drone && ctx.has(Item::Ice_Axe))
}
pub fn access_mode_ne_drone_and_invoke_infinite_climb(ctx: &Context, world: &World) -> bool {
    // ^mode != 'drone' and $infinite_climb
    (ctx.mode() != enums::Mode::Drone && helper__infinite_climb!(ctx, world))
}
pub fn access_nanite_mist(ctx: &Context, world: &World) -> bool {
    // Nanite_Mist
    ctx.has(Item::Nanite_Mist)
}
pub fn access_nanite_mist_and_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
) -> bool {
    // Nanite_Mist and ^_dur_esla
    (ctx.has(Item::Nanite_Mist) && ctx.amagi__gated_community__ctx__dur_esla())
}
pub fn access_nanite_mist_and_not_irikar__midwest__ctx__right_platform(
    ctx: &Context,
    world: &World,
) -> bool {
    // Nanite_Mist and not ^_right_platform
    (ctx.has(Item::Nanite_Mist) && !ctx.irikar__midwest__ctx__right_platform())
}
pub fn access_nano_points(ctx: &Context, world: &World) -> bool {
    // Nano_Points
    ctx.has(Item::Nano_Points)
}
pub fn access_nano_points_2(ctx: &Context, world: &World) -> bool {
    // Nano_Points_2
    ctx.has(Item::Nano_Points_2)
}
pub fn access_not_amagi__main_area__ctx__combo(ctx: &Context, world: &World) -> bool {
    // not ^_combo
    !ctx.amagi__main_area__ctx__combo()
}
pub fn access_not_amashilama(ctx: &Context, world: &World) -> bool {
    // NOT Amashilama
    !ctx.has(Item::Amashilama)
}
pub fn access_not_annuna__boss_gate__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door and Nanite_Mist
    (!ctx.annuna__boss_gate__ctx__door() && ctx.has(Item::Nanite_Mist))
}
pub fn access_not_annuna__east_bridge__ctx__combo(ctx: &Context, world: &World) -> bool {
    // not ^_combo
    !ctx.annuna__east_bridge__ctx__combo()
}
pub fn access_not_annuna__udug_gate__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door and Nanite_Mist
    (!ctx.annuna__udug_gate__ctx__door() && ctx.has(Item::Nanite_Mist))
}
pub fn access_not_apocalypse_bomb(ctx: &Context, world: &World) -> bool {
    // not Apocalypse_Bomb
    !ctx.has(Item::Apocalypse_Bomb)
}
pub fn access_not_drone_hover(ctx: &Context, world: &World) -> bool {
    // not Drone_Hover
    !ctx.has(Item::Drone_Hover)
}
pub fn access_not_drone_melee_damage_3(ctx: &Context, world: &World) -> bool {
    // not Drone_Melee_Damage_3
    !ctx.has(Item::Drone_Melee_Damage_3)
}
pub fn access_not_drone_melee_speed_3(ctx: &Context, world: &World) -> bool {
    // not Drone_Melee_Speed_3
    !ctx.has(Item::Drone_Melee_Speed_3)
}
pub fn access_not_ebih__ebih_east__ctx__platform2_moved(ctx: &Context, world: &World) -> bool {
    // not ^_platform2_moved
    !ctx.ebih__ebih_east__ctx__platform2_moved()
}
pub fn access_not_ebih__ebih_west__ctx__door_open(ctx: &Context, world: &World) -> bool {
    // not ^_door_open
    !ctx.ebih__ebih_west__ctx__door_open()
}
pub fn access_not_ebih__ebih_west__ctx__door_open_or_invoke_grab(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door_open or $grab
    (!ctx.ebih__ebih_west__ctx__door_open() || helper__grab!(ctx, world))
}
pub fn access_not_ebih__truck_gate__ctx__door_open_and_invoke_open(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door_open and $open
    (!ctx.ebih__truck_gate__ctx__door_open() && helper__open!(ctx, world))
}
pub fn access_not_ebih__truck_gate__ctx__door_open_and_invoke_open_and_invoke_range1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door_open and $open and $range1
    ((!ctx.ebih__truck_gate__ctx__door_open() && helper__open!(ctx, world))
        && helper__range1!(ctx, world))
}
pub fn access_not_ebih_interchange_block(ctx: &Context, world: &World) -> bool {
    // not Ebih_Interchange_Block
    !ctx.has(Item::Ebih_Interchange_Block)
}
pub fn access_not_giguna__carnelian__ctx__lower_susar(ctx: &Context, world: &World) -> bool {
    // not ^_lower_susar
    !ctx.giguna__carnelian__ctx__lower_susar()
}
pub fn access_not_giguna__carnelian__ctx__lower_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!ctx.giguna__carnelian__ctx__lower_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna__carnelian__ctx__upper_susar(ctx: &Context, world: &World) -> bool {
    // not ^_upper_susar
    !ctx.giguna__carnelian__ctx__upper_susar()
}
pub fn access_not_giguna__carnelian__ctx__upper_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!ctx.giguna__carnelian__ctx__upper_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna__clouds__ctx__platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_platform and $activate
    (!ctx.giguna__clouds__ctx__platform() && helper__activate!(ctx, world))
}
pub fn access_not_giguna__clouds__ctx__platform_and_invoke_activate_and_invoke_attract_and_breach_sight_and_remote_drone(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_platform and $activate and $attract and Breach_Sight and Remote_Drone
    ((((!ctx.giguna__clouds__ctx__platform() && helper__activate!(ctx, world))
        && helper__attract!(ctx, world))
        && ctx.has(Item::Breach_Sight))
        && ctx.has(Item::Remote_Drone))
}
pub fn access_not_giguna__clouds__ctx__platform_and_invoke_activate_and_invoke_can_deploy_and_invoke_attract_and_breach_sight(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_platform and $activate and $can_deploy and $attract and Breach_Sight
    ((((!ctx.giguna__clouds__ctx__platform() && helper__activate!(ctx, world))
        && helper__can_deploy!(ctx, world))
        && helper__attract!(ctx, world))
        && ctx.has(Item::Breach_Sight))
}
pub fn access_not_giguna__east_caverns__ctx__combo_entered(ctx: &Context, world: &World) -> bool {
    // not ^_combo_entered
    !ctx.giguna__east_caverns__ctx__combo_entered()
}
pub fn access_not_giguna__east_caverns__ctx__door_opened_and_invoke_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door_opened and $open and $range2
    ((!ctx.giguna__east_caverns__ctx__door_opened() && helper__open!(ctx, world))
        && helper__range2!(ctx, world))
}
pub fn access_not_giguna__east_caverns__ctx__door_opened_and_invoke_unlock2(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door_opened and $unlock2
    (!ctx.giguna__east_caverns__ctx__door_opened() && helper__unlock2!(ctx, world))
}
pub fn access_not_giguna__east_caverns__ctx__door_opened_and_invoke_unlock2_and_invoke_range1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door_opened and $unlock2 and $range1
    ((!ctx.giguna__east_caverns__ctx__door_opened() && helper__unlock2!(ctx, world))
        && helper__range1!(ctx, world))
}
pub fn access_not_giguna__east_caverns__ctx__lower_susar(ctx: &Context, world: &World) -> bool {
    // not ^_lower_susar
    !ctx.giguna__east_caverns__ctx__lower_susar()
}
pub fn access_not_giguna__east_caverns__ctx__lower_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__lower_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna__east_caverns__ctx__mid_susar(ctx: &Context, world: &World) -> bool {
    // not ^_mid_susar
    !ctx.giguna__east_caverns__ctx__mid_susar()
}
pub fn access_not_giguna__east_caverns__ctx__mid_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_mid_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__mid_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna__east_caverns__ctx__upper_susar(ctx: &Context, world: &World) -> bool {
    // not ^_upper_susar
    !ctx.giguna__east_caverns__ctx__upper_susar()
}
pub fn access_not_giguna__east_caverns__ctx__upper_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!ctx.giguna__east_caverns__ctx__upper_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna__ruins_west__ctx__kishib_handled_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_kishib_handled and $allegiance1
    (!ctx.giguna__ruins_west__ctx__kishib_handled() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna__ruins_west__ctx__kishib_handled_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_kishib_handled and $shockwave
    (!ctx.giguna__ruins_west__ctx__kishib_handled() && helper__shockwave!(ctx, world))
}
pub fn access_not_giguna__west_caverns__ctx__east_susar(ctx: &Context, world: &World) -> bool {
    // not ^_east_susar
    !ctx.giguna__west_caverns__ctx__east_susar()
}
pub fn access_not_giguna__west_caverns__ctx__east_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_east_susar and $allegiance1
    (!ctx.giguna__west_caverns__ctx__east_susar() && helper__allegiance1!(ctx, world))
}
pub fn access_not_giguna_breach__sw_save__ctx__door_opened(ctx: &Context, world: &World) -> bool {
    // not ^_door_opened
    !ctx.giguna_breach__sw_save__ctx__door_opened()
}
pub fn access_not_glacier__lonely_bull__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_door and Nanite_Mist
    (!ctx.glacier__lonely_bull__ctx__door() && ctx.has(Item::Nanite_Mist))
}
pub fn access_not_hammond_auth(ctx: &Context, world: &World) -> bool {
    // not Hammond_Auth
    !ctx.has(Item::Hammond_Auth)
}
pub fn access_not_invoke_hook(ctx: &Context, world: &World) -> bool {
    // not $hook
    !helper__hook!(ctx, world)
}
pub fn access_not_irikar__basement_portal__ctx__platform_moved(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_platform_moved
    !ctx.irikar__basement_portal__ctx__platform_moved()
}
pub fn access_not_irikar__midwest__ctx__left_platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_left_platform and $activate
    (!ctx.irikar__midwest__ctx__left_platform() && helper__activate!(ctx, world))
}
pub fn access_not_irikar__midwest__ctx__left_platform_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_left_platform and Nanite_Mist
    (!ctx.irikar__midwest__ctx__left_platform() && ctx.has(Item::Nanite_Mist))
}
pub fn access_not_irikar__midwest__ctx__right_platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_right_platform and $activate
    (!ctx.irikar__midwest__ctx__right_platform() && helper__activate!(ctx, world))
}
pub fn access_not_irikar__midwest__ctx__right_platform_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // not ^_right_platform and Nanite_Mist
    (!ctx.irikar__midwest__ctx__right_platform() && ctx.has(Item::Nanite_Mist))
}
pub fn access_not_irikar_royal_storage_wall_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
) -> bool {
    // not Irikar_Royal_Storage_Wall and $shockwave
    (!ctx.has(Item::Irikar_Royal_Storage_Wall) && helper__shockwave!(ctx, world))
}
pub fn access_not_irikar_royal_storage_wall_and_invoke_shockwave_and_not_invoke_visited__irikar_gt_hub_gt_collapsed_column_gt_shockwave_to_get_item(
    ctx: &Context,
    world: &World,
) -> bool {
    // not Irikar_Royal_Storage_Wall and $shockwave and not $visited(`Irikar > Hub > Collapsed Column > Shockwave to Get Item`)
    ((!ctx.has(Item::Irikar_Royal_Storage_Wall) && helper__shockwave!(ctx, world))
        && !ctx.visited(LocationId::Irikar__Hub__Collapsed_Column__Shockwave_to_Get_Item))
}
pub fn access_not_irikar_royal_storage_wall_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // not Irikar_Royal_Storage_Wall and Nanite_Mist
    (!ctx.has(Item::Irikar_Royal_Storage_Wall) && ctx.has(Item::Nanite_Mist))
}
pub fn access_not_mist_upgrade(ctx: &Context, world: &World) -> bool {
    // not Mist_Upgrade
    !ctx.has(Item::Mist_Upgrade)
}
pub fn access_not_separation_or_defeat_indra(ctx: &Context, world: &World) -> bool {
    // NOT Separation or Defeat_Indra
    (!ctx.has(Item::Separation) || ctx.has(Item::Defeat_Indra))
}
pub fn access_not_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // not Slingshot_Hook
    !ctx.has(Item::Slingshot_Hook)
}
pub fn access_not_slingshot_weapon(ctx: &Context, world: &World) -> bool {
    // not Slingshot_Weapon
    !ctx.has(Item::Slingshot_Weapon)
}
pub fn access_not_within_menu_and_anuman_and_mode_ne_drone(ctx: &Context, world: &World) -> bool {
    // NOT WITHIN `Menu` and Anuman and ^mode != 'drone'
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ctx.has(Item::Anuman))
        && ctx.mode() != enums::Mode::Drone)
}
pub fn access_not_within_menu_and_flasks_gt_0(ctx: &Context, world: &World) -> bool {
    // NOT WITHIN `Menu` and ^flasks > 0
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && Into::<i32>::into(ctx.flasks()) > 0.into())
}
pub fn access_not_within_menu_and_invoke_attract_and_portal_ne_invoke_default_and_portal_ne_position(
    ctx: &Context,
    world: &World,
) -> bool {
    // NOT WITHIN `Menu` and $attract and ^portal != $default and ^portal != ^position
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && helper__attract!(ctx, world))
        && ctx.portal() != Default::default())
        && ctx.portal() != ctx.position())
}
pub fn access_not_within_menu_and_invoke_can_deploy(ctx: &Context, world: &World) -> bool {
    // NOT WITHIN `Menu` and $can_deploy
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && helper__can_deploy!(ctx, world))
}
pub fn access_not_within_menu_and_realm_ne_breach_and_anuman_and_mode_eq_drone(
    ctx: &Context,
    world: &World,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and Anuman and ^mode == 'drone'
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && data::realm(ctx.position()) != enums::Realm::Breach)
        && ctx.has(Item::Anuman))
        && ctx.mode() == enums::Mode::Drone)
}
pub fn access_not_within_menu_and_realm_ne_breach_and_invoke_can_recall(
    ctx: &Context,
    world: &World,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and $can_recall
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && data::realm(ctx.position()) != enums::Realm::Breach)
        && helper__can_recall!(ctx, world))
}
pub fn access_portal_eq_position(ctx: &Context, world: &World) -> bool {
    // ^portal == ^position
    ctx.portal() == ctx.position()
}
pub fn access_portal_hidden(ctx: &Context, world: &World) -> bool {
    // ^portal_hidden
    data::portal_hidden(ctx.position())
}
pub fn access_ranged_damage(ctx: &Context, world: &World) -> bool {
    // Ranged_Damage
    ctx.has(Item::Ranged_Damage)
}
pub fn access_ranged_damage_2(ctx: &Context, world: &World) -> bool {
    // Ranged_Damage_2
    ctx.has(Item::Ranged_Damage_2)
}
pub fn access_ranged_speed(ctx: &Context, world: &World) -> bool {
    // Ranged_Speed
    ctx.has(Item::Ranged_Speed)
}
pub fn access_ranged_speed_2(ctx: &Context, world: &World) -> bool {
    // Ranged_Speed_2
    ctx.has(Item::Ranged_Speed_2)
}
pub fn access_realm_eq_breach_and_exit_breach_and_flipside_ne_invoke_default(
    ctx: &Context,
    world: &World,
) -> bool {
    // ^realm == 'breach' and Exit_Breach and ^flipside != $default
    ((data::realm(ctx.position()) == enums::Realm::Breach && ctx.has(Item::Exit_Breach))
        && data::flipside(ctx.position()) != Default::default())
}
pub fn access_remote_drone(ctx: &Context, world: &World) -> bool {
    // Remote_Drone
    ctx.has(Item::Remote_Drone)
}
pub fn access_robopede(ctx: &Context, world: &World) -> bool {
    // Robopede
    ctx.has(Item::Robopede)
}
pub fn access_separation(ctx: &Context, world: &World) -> bool {
    // Separation
    ctx.has(Item::Separation)
}
pub fn access_separation_and_not_defeat_indra_and_nanite_mist(
    ctx: &Context,
    world: &World,
) -> bool {
    // Separation and NOT Defeat_Indra and Nanite_Mist
    ((ctx.has(Item::Separation) && !ctx.has(Item::Defeat_Indra)) && ctx.has(Item::Nanite_Mist))
}
pub fn access_siuna_storage_wall(ctx: &Context, world: &World) -> bool {
    // Siuna_Storage_Wall
    ctx.has(Item::Siuna_Storage_Wall)
}
pub fn access_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook
    ctx.has(Item::Slingshot_Hook)
}
pub fn access_slingshot_hook_and___not_slingshot_weapon_or_invoke_visited__irikar_breach_gt_gauntlet_gt_hidden_path_reward_gt_item(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and (not Slingshot_Weapon or $visited(`Irikar Breach > Gauntlet > Hidden Path Reward > Item`))
    (ctx.has(Item::Slingshot_Hook)
        && (!ctx.has(Item::Slingshot_Weapon)
            || ctx.visited(LocationId::Irikar_Breach__Gauntlet__Hidden_Path_Reward__Item)))
}
pub fn access_slingshot_hook_and___slingshot_weapon_or_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and (Slingshot_Weapon or Drone_Hover)
    (ctx.has(Item::Slingshot_Hook)
        && (ctx.has(Item::Slingshot_Weapon) || ctx.has(Item::Drone_Hover)))
}
pub fn access_slingshot_hook_and_drone_hover(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook and Drone_Hover
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover))
}
pub fn access_slingshot_hook_and_drone_hover_and_ebih_breach_in_n_out_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Ebih_Breach_In_n_Out_Gate
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Ebih_Breach_In_n_Out_Gate))
}
pub fn access_slingshot_hook_and_drone_hover_and_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Ebih_Breach_Rock_Block_Rock
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Ebih_Breach_Rock_Block_Rock))
}
pub fn access_slingshot_hook_and_drone_hover_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Giguna_Breach_Crab_Rave_Gate
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Giguna_Breach_Crab_Rave_Gate))
}
pub fn access_slingshot_hook_and_drone_hover_and_infect_l1_and_drone_melee_damage_2_and_drone_melee_speed_2(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Infect_L1 and Drone_Melee_Damage_2 and Drone_Melee_Speed_2
    ((((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover)) && ctx.has(Item::Infect_L1))
        && ctx.has(Item::Drone_Melee_Damage_2))
        && ctx.has(Item::Drone_Melee_Speed_2))
}
pub fn access_slingshot_hook_and_drone_hover_and_not_irikar_breach_buried_treasure_pillar(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Drone_Hover and not Irikar_Breach_Buried_Treasure_Pillar
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover))
        && !ctx.has(Item::Irikar_Breach_Buried_Treasure_Pillar))
}
pub fn access_slingshot_hook_and_drone_hover_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Slingshot_Weapon
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Slingshot_Weapon))
}
pub fn access_slingshot_hook_and_drone_melee_damage_3(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook and Drone_Melee_Damage_3
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Drone_Melee_Damage_3))
}
pub fn access_slingshot_hook_and_ebih_breach_lake_gate(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook and Ebih_Breach_Lake_Gate
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Ebih_Breach_Lake_Gate))
}
pub fn access_slingshot_hook_and_ebih_breach_rock_block_rock(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook and Ebih_Breach_Rock_Block_Rock
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Ebih_Breach_Rock_Block_Rock))
}
pub fn access_slingshot_hook_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Giguna_Breach_Crab_Rave_Gate
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Giguna_Breach_Crab_Rave_Gate))
}
pub fn access_slingshot_hook_and_giguna_breach_gate_and_wall_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Giguna_Breach_Gate_and_Wall_Gate
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Giguna_Breach_Gate_and_Wall_Gate))
}
pub fn access_slingshot_hook_and_slingshot_charge(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook and Slingshot_Charge
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Slingshot_Charge))
}
pub fn access_slingshot_hook_and_slingshot_charge_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Slingshot_Charge and Drone_Hover
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Slingshot_Charge))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_slingshot_hook_and_slingshot_weapon(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook and Slingshot_Weapon
    (ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Slingshot_Weapon))
}
pub fn access_slingshot_hook_and_slingshot_weapon_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Slingshot_Weapon and Drone_Hover
    ((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Slingshot_Weapon))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_slingshot_hook_and_slingshot_weapon_and_drone_hover_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Slingshot_Hook and Slingshot_Weapon and Drone_Hover and Giguna_Breach_Crab_Rave_Gate
    (((ctx.has(Item::Slingshot_Hook) && ctx.has(Item::Slingshot_Weapon))
        && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Giguna_Breach_Crab_Rave_Gate))
}
pub fn access_slingshot_hook_or_drone_hover(ctx: &Context, world: &World) -> bool {
    // Slingshot_Hook or Drone_Hover
    (ctx.has(Item::Slingshot_Hook) || ctx.has(Item::Drone_Hover))
}
pub fn access_sniper_valley_rock_1(ctx: &Context, world: &World) -> bool {
    // Sniper_Valley_Rock_1
    ctx.has(Item::Sniper_Valley_Rock_1)
}
pub fn access_station_power(ctx: &Context, world: &World) -> bool {
    // Station_Power
    ctx.has(Item::Station_Power)
}
pub fn access_switch_36_11(ctx: &Context, world: &World) -> bool {
    // Switch_36_11
    ctx.has(Item::Switch_36_11)
}
pub fn access_switch_40_12(ctx: &Context, world: &World) -> bool {
    // Switch_40_12
    ctx.has(Item::Switch_40_12)
}
pub fn access_uhrum_annuna_corridor_block(ctx: &Context, world: &World) -> bool {
    // Uhrum_Annuna_Corridor_Block
    ctx.has(Item::Uhrum_Annuna_Corridor_Block)
}
pub fn access_uhrum_breach_annuna_gate_gate(ctx: &Context, world: &World) -> bool {
    // Uhrum_Breach_Annuna_Gate_Gate
    ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate)
}
pub fn access_uhrum_breach_annuna_gate_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Breach_Annuna_Gate_Gate and Slingshot_Hook
    (ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_uhrum_breach_annuna_gate_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Breach_Annuna_Gate_Gate and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_uhrum_breach_locked_down_gate(ctx: &Context, world: &World) -> bool {
    // Uhrum_Breach_Locked_Down_Gate
    ctx.has(Item::Uhrum_Breach_Locked_Down_Gate)
}
pub fn access_uhrum_breach_locked_down_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Breach_Locked_Down_Gate and Slingshot_Hook
    (ctx.has(Item::Uhrum_Breach_Locked_Down_Gate) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_uhrum_breach_overgrown_ruins_wall(ctx: &Context, world: &World) -> bool {
    // Uhrum_Breach_Overgrown_Ruins_Wall
    ctx.has(Item::Uhrum_Breach_Overgrown_Ruins_Wall)
}
pub fn access_uhrum_breach_rock_and_gate_gate(ctx: &Context, world: &World) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Gate
    ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Gate)
}
pub fn access_uhrum_breach_rock_and_gate_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Gate and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Gate) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_uhrum_breach_rock_and_gate_rock(ctx: &Context, world: &World) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Rock
    ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Rock)
}
pub fn access_uhrum_breach_rock_and_gate_rock_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Rock and Slingshot_Hook
    (ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Rock) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_uhrum_cavern_wall(ctx: &Context, world: &World) -> bool {
    // Uhrum_Cavern_Wall
    ctx.has(Item::Uhrum_Cavern_Wall)
}
pub fn access_uhrum_cavern_wall_and_invoke_hookhover(ctx: &Context, world: &World) -> bool {
    // Uhrum_Cavern_Wall and $hookhover
    (ctx.has(Item::Uhrum_Cavern_Wall) && helper__hookhover!(ctx, world))
}
pub fn access_uhrum_east_glitch(ctx: &Context, world: &World) -> bool {
    // Uhrum_East_Glitch
    ctx.has(Item::Uhrum_East_Glitch)
}
pub fn access_uhrum_east_lake_block(ctx: &Context, world: &World) -> bool {
    // Uhrum_East_Lake_Block
    ctx.has(Item::Uhrum_East_Lake_Block)
}
pub fn access_uhrum_east_lake_block_and_invoke_hookhover(ctx: &Context, world: &World) -> bool {
    // Uhrum_East_Lake_Block and $hookhover
    (ctx.has(Item::Uhrum_East_Lake_Block) && helper__hookhover!(ctx, world))
}
pub fn access_uhrum_emergence_wall(ctx: &Context, world: &World) -> bool {
    // Uhrum_Emergence_Wall
    ctx.has(Item::Uhrum_Emergence_Wall)
}
pub fn access_uhrum_emergence_wall_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Emergence_Wall and $hook and $hover
    ((ctx.has(Item::Uhrum_Emergence_Wall) && helper__hook!(ctx, world))
        && helper__hover!(ctx, world))
}
pub fn access_uhrum_emergence_wall_and_invoke_hover(ctx: &Context, world: &World) -> bool {
    // Uhrum_Emergence_Wall and $hover
    (ctx.has(Item::Uhrum_Emergence_Wall) && helper__hover!(ctx, world))
}
pub fn access_uhrum_glitchy_corridor_rock(ctx: &Context, world: &World) -> bool {
    // Uhrum_Glitchy_Corridor_Rock
    ctx.has(Item::Uhrum_Glitchy_Corridor_Rock)
}
pub fn access_uhrum_glitchy_corridor_rock_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Uhrum_Glitchy_Corridor_Rock and $hook
    (ctx.has(Item::Uhrum_Glitchy_Corridor_Rock) && helper__hook!(ctx, world))
}
pub fn access_uhrum_glitchy_corridor_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Uhrum_Glitchy_Corridor_Rock and $hookhover
    (ctx.has(Item::Uhrum_Glitchy_Corridor_Rock) && helper__hookhover!(ctx, world))
}
pub fn access_uhrum_rocky_gate_rock(ctx: &Context, world: &World) -> bool {
    // Uhrum_Rocky_Gate_Rock
    ctx.has(Item::Uhrum_Rocky_Gate_Rock)
}
pub fn access_uhrum_rocky_gate_rock_and_invoke_hookhover(ctx: &Context, world: &World) -> bool {
    // Uhrum_Rocky_Gate_Rock and $hookhover
    (ctx.has(Item::Uhrum_Rocky_Gate_Rock) && helper__hookhover!(ctx, world))
}
pub fn access_uhrum_waterfall_wall(ctx: &Context, world: &World) -> bool {
    // Uhrum_Waterfall_Wall
    ctx.has(Item::Uhrum_Waterfall_Wall)
}
pub fn access_uhrum_waterfalls_block(ctx: &Context, world: &World) -> bool {
    // Uhrum_Waterfalls_Block
    ctx.has(Item::Uhrum_Waterfalls_Block)
}
pub fn access_uhrum_waterfalls_block_and_invoke_grab(ctx: &Context, world: &World) -> bool {
    // Uhrum_Waterfalls_Block and $grab
    (ctx.has(Item::Uhrum_Waterfalls_Block) && helper__grab!(ctx, world))
}
pub fn access_uhrum_waterfalls_block_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Uhrum_Waterfalls_Block and $hook
    (ctx.has(Item::Uhrum_Waterfalls_Block) && helper__hook!(ctx, world))
}
pub fn access_uhrum_west_entrance_gate(ctx: &Context, world: &World) -> bool {
    // Uhrum_West_Entrance_Gate
    ctx.has(Item::Uhrum_West_Entrance_Gate)
}
pub fn access_uhrum_west_entrance_gate_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Uhrum_West_Entrance_Gate and $hook
    (ctx.has(Item::Uhrum_West_Entrance_Gate) && helper__hook!(ctx, world))
}
pub fn access_uhrum_west_entrance_gate_and_invoke_hover(ctx: &Context, world: &World) -> bool {
    // Uhrum_West_Entrance_Gate and $hover
    (ctx.has(Item::Uhrum_West_Entrance_Gate) && helper__hover!(ctx, world))
}
pub fn access_uhrum_west_entrance_lower_wall(ctx: &Context, world: &World) -> bool {
    // Uhrum_West_Entrance_Lower_Wall
    ctx.has(Item::Uhrum_West_Entrance_Lower_Wall)
}
pub fn access_uhrum_west_entrance_upper_wall(ctx: &Context, world: &World) -> bool {
    // Uhrum_West_Entrance_Upper_Wall
    ctx.has(Item::Uhrum_West_Entrance_Upper_Wall)
}
pub fn access_uhrum_west_glitch(ctx: &Context, world: &World) -> bool {
    // Uhrum_West_Glitch
    ctx.has(Item::Uhrum_West_Glitch)
}
pub fn access_underwater_movement(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement
    ctx.has(Item::Underwater_Movement)
}
pub fn access_underwater_movement_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and ($grab or $climb)
    (ctx.has(Item::Underwater_Movement)
        && (helper__grab!(ctx, world) || helper__climb!(ctx, world)))
}
pub fn access_underwater_movement_and___invoke_hook_or_invoke_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and ($hook or $hover)
    (ctx.has(Item::Underwater_Movement)
        && (helper__hook!(ctx, world) || helper__hover!(ctx, world)))
}
pub fn access_underwater_movement_and___slingshot_hook_or_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and (Slingshot_Hook or Drone_Hover)
    (ctx.has(Item::Underwater_Movement)
        && (ctx.has(Item::Slingshot_Hook) || ctx.has(Item::Drone_Hover)))
}
pub fn access_underwater_movement_and_amagi_breach_center_ruins_blocks(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Center_Ruins_Blocks
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Amagi_Breach_Center_Ruins_Blocks))
}
pub fn access_underwater_movement_and_amagi_breach_lower_hallway_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate))
}
pub fn access_underwater_movement_and_amagi_breach_lower_hallway_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate and Slingshot_Hook
    ((ctx.has(Item::Underwater_Movement) && ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate))
        && ctx.has(Item::Slingshot_Hook))
}
pub fn access_underwater_movement_and_amagi_breach_lower_hallway_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate and Slingshot_Hook and Drone_Hover
    (((ctx.has(Item::Underwater_Movement) && ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate))
        && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_underwater_movement_and_amagi_breach_split_gate(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Split_Gate
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Amagi_Breach_Split_Gate))
}
pub fn access_underwater_movement_and_amagi_wiggly_room_gate(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and Amagi_Wiggly_Room_Gate
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Amagi_Wiggly_Room_Gate))
}
pub fn access_underwater_movement_and_drone_hover(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and Drone_Hover
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Drone_Hover))
}
pub fn access_underwater_movement_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Drone_Hover and Slingshot_Hook
    ((ctx.has(Item::Underwater_Movement) && ctx.has(Item::Drone_Hover))
        && ctx.has(Item::Slingshot_Hook))
}
pub fn access_underwater_movement_and_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and ^_lower_gatestones
    (ctx.has(Item::Underwater_Movement) && ctx.glacier__vertical_room__ctx__lower_gatestones())
}
pub fn access_underwater_movement_and_invoke_climb(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and $climb
    (ctx.has(Item::Underwater_Movement) && helper__climb!(ctx, world))
}
pub fn access_underwater_movement_and_invoke_grab(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and $grab
    (ctx.has(Item::Underwater_Movement) && helper__grab!(ctx, world))
}
pub fn access_underwater_movement_and_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and $grab and $climb
    ((ctx.has(Item::Underwater_Movement) && helper__grab!(ctx, world))
        && helper__climb!(ctx, world))
}
pub fn access_underwater_movement_and_invoke_hook(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and $hook
    (ctx.has(Item::Underwater_Movement) && helper__hook!(ctx, world))
}
pub fn access_underwater_movement_and_invoke_hook_and_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and $hook and ^_lower_gatestones
    ((ctx.has(Item::Underwater_Movement) && helper__hook!(ctx, world))
        && ctx.glacier__vertical_room__ctx__lower_gatestones())
}
pub fn access_underwater_movement_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and $hook and $hover
    ((ctx.has(Item::Underwater_Movement) && helper__hook!(ctx, world))
        && helper__hover!(ctx, world))
}
pub fn access_underwater_movement_and_invoke_hookhover(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and $hookhover
    (ctx.has(Item::Underwater_Movement) && helper__hookhover!(ctx, world))
}
pub fn access_underwater_movement_and_invoke_hover(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and $hover
    (ctx.has(Item::Underwater_Movement) && helper__hover!(ctx, world))
}
pub fn access_underwater_movement_and_nanite_mist(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and Nanite_Mist
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Nanite_Mist))
}
pub fn access_underwater_movement_and_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement and Slingshot_Hook
    (ctx.has(Item::Underwater_Movement) && ctx.has(Item::Slingshot_Hook))
}
pub fn access_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
) -> bool {
    // Underwater_Movement and Slingshot_Hook and Drone_Hover
    ((ctx.has(Item::Underwater_Movement) && ctx.has(Item::Slingshot_Hook))
        && ctx.has(Item::Drone_Hover))
}
pub fn access_underwater_movement_or_slingshot_hook(ctx: &Context, world: &World) -> bool {
    // Underwater_Movement or Slingshot_Hook
    (ctx.has(Item::Underwater_Movement) || ctx.has(Item::Slingshot_Hook))
}
pub fn access_within_menu_gt_upgrade_menu(ctx: &Context, world: &World) -> bool {
    // WITHIN `Menu > Upgrade Menu`
    (match get_area(ctx.position()) {
        AreaId::Menu__Upgrade_Menu => true,
        _ => false,
    })
}
pub fn action_amagi__gated_community__ctx__dur_esla_set_true(ctx: &mut Context, world: &World) {
    // ^_dur_esla = true
    ctx.set_amagi__gated_community__ctx__dur_esla(true);
}
pub fn action_amagi__main_area__ctx__combo_set_true(ctx: &mut Context, world: &World) {
    // ^_combo = true
    ctx.set_amagi__main_area__ctx__combo(true);
}
pub fn action_amagi__secret_chamber__ctx__east_dur_esla_set_true(ctx: &mut Context, world: &World) {
    // ^_east_dur_esla = true
    ctx.set_amagi__secret_chamber__ctx__east_dur_esla(true);
}
pub fn action_amagi__secret_chamber__ctx__west_dur_esla_set_true(ctx: &mut Context, world: &World) {
    // ^_west_dur_esla = true
    ctx.set_amagi__secret_chamber__ctx__west_dur_esla(true);
}
pub fn action_annuna__boss_gate__ctx__door_set_true(ctx: &mut Context, world: &World) {
    // ^_door = true
    ctx.set_annuna__boss_gate__ctx__door(true);
}
pub fn action_annuna__east_bridge__ctx__combo_set_true(ctx: &mut Context, world: &World) {
    // ^_combo = true
    ctx.set_annuna__east_bridge__ctx__combo(true);
}
pub fn action_annuna__invisible_enemies__ctx__door_opened_set_true(
    ctx: &mut Context,
    world: &World,
) {
    // ^_door_opened = true
    ctx.set_annuna__invisible_enemies__ctx__door_opened(true);
}
pub fn action_annuna__invisible_enemies__ctx__nw_utu_set_true(ctx: &mut Context, world: &World) {
    // ^_nw_utu = true
    ctx.set_annuna__invisible_enemies__ctx__nw_utu(true);
}
pub fn action_annuna__udug_gate__ctx__door_set_true(ctx: &mut Context, world: &World) {
    // ^_door = true
    ctx.set_annuna__udug_gate__ctx__door(true);
}
pub fn action_annuna__vertical_room__ctx__door_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_door_opened = true
    ctx.set_annuna__vertical_room__ctx__door_opened(true);
}
pub fn action_annuna__west_bridge__ctx__doors_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_doors_opened = true
    ctx.set_annuna__west_bridge__ctx__doors_opened(true);
}
pub fn action_annuna__west_climb__ctx__door_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_door_opened = true
    ctx.set_annuna__west_climb__ctx__door_opened(true);
}
pub fn action_ebih__base_camp__ctx__left_platform_moved_set_false(
    ctx: &mut Context,
    world: &World,
) {
    // ^_left_platform_moved = false
    ctx.set_ebih__base_camp__ctx__left_platform_moved(false);
}
pub fn action_ebih__base_camp__ctx__left_platform_moved_set_true(ctx: &mut Context, world: &World) {
    // ^_left_platform_moved = true
    ctx.set_ebih__base_camp__ctx__left_platform_moved(true);
}
pub fn action_ebih__drone_room__ctx__platform_moved_set_false(ctx: &mut Context, world: &World) {
    // ^_platform_moved = false
    ctx.set_ebih__drone_room__ctx__platform_moved(false);
}
pub fn action_ebih__drone_room__ctx__platform_moved_set_true(ctx: &mut Context, world: &World) {
    // ^_platform_moved = true
    ctx.set_ebih__drone_room__ctx__platform_moved(true);
}
pub fn action_ebih__ebih_east__ctx__platform1_moved_set_true(ctx: &mut Context, world: &World) {
    // ^_platform1_moved = true
    ctx.set_ebih__ebih_east__ctx__platform1_moved(true);
}
pub fn action_ebih__ebih_east__ctx__platform2_moved_set_false(ctx: &mut Context, world: &World) {
    // ^_platform2_moved = false
    ctx.set_ebih__ebih_east__ctx__platform2_moved(false);
}
pub fn action_ebih__ebih_east__ctx__platform2_moved_set_true(ctx: &mut Context, world: &World) {
    // ^_platform2_moved = true
    ctx.set_ebih__ebih_east__ctx__platform2_moved(true);
}
pub fn action_ebih__ebih_west__ctx__door_open_set_true_if___indra_within_ebih_gt_ebih_west_gt_above_door____indra_set_ebih_gt_ebih_west_gt_below_door_(
    ctx: &mut Context,
    world: &World,
) {
    // ^_door_open = true; IF (^indra WITHIN `Ebih > Ebih West > Above Door`) { ^indra = `Ebih > Ebih West > Below Door`; }
    ctx.set_ebih__ebih_west__ctx__door_open(true);
    if ctx.indra() == SpotId::Ebih__Ebih_West__Above_Door {
        ctx.set_indra(SpotId::Ebih__Ebih_West__Below_Door);
    }
}
pub fn action_ebih__grid_25_10_12__ctx__door_open_set_true(ctx: &mut Context, world: &World) {
    // ^_door_open = true
    ctx.set_ebih__grid_25_10_12__ctx__door_open(true);
}
pub fn action_ebih__truck_gate__ctx__door_open_set_true(ctx: &mut Context, world: &World) {
    // ^_door_open = true
    ctx.set_ebih__truck_gate__ctx__door_open(true);
}
pub fn action_ebih__vertical_interchange__ctx__door_open_set_true(
    ctx: &mut Context,
    world: &World,
) {
    // ^_door_open = true
    ctx.set_ebih__vertical_interchange__ctx__door_open(true);
}
pub fn action_ebih__waterfall__ctx__east_door_open_set_true(ctx: &mut Context, world: &World) {
    // ^_east_door_open = true
    ctx.set_ebih__waterfall__ctx__east_door_open(true);
}
pub fn action_ebih__waterfall__ctx__west_door_open_set_true(ctx: &mut Context, world: &World) {
    // ^_west_door_open = true
    ctx.set_ebih__waterfall__ctx__west_door_open(true);
}
pub fn action_emergence__storage__ctx__door_open_set_true(ctx: &mut Context, world: &World) {
    // ^_door_open = true
    ctx.set_emergence__storage__ctx__door_open(true);
}
pub fn action_flasks_incr_1(ctx: &mut Context, world: &World) {
    // ^flasks += 1
    ctx.flasks += 1;
}
pub fn action_flasks_incr_2(ctx: &mut Context, world: &World) {
    // ^flasks += 2
    ctx.flasks += 2;
}
pub fn action_flasks_incr_4(ctx: &mut Context, world: &World) {
    // ^flasks += 4
    ctx.flasks += 4;
}
pub fn action_giguna__carnelian__ctx__door_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_door_opened = true
    ctx.set_giguna__carnelian__ctx__door_opened(true);
}
pub fn action_giguna__carnelian__ctx__lower_susar_set_true(ctx: &mut Context, world: &World) {
    // ^_lower_susar = true
    ctx.set_giguna__carnelian__ctx__lower_susar(true);
}
pub fn action_giguna__carnelian__ctx__upper_susar_set_true(ctx: &mut Context, world: &World) {
    // ^_upper_susar = true
    ctx.set_giguna__carnelian__ctx__upper_susar(true);
}
pub fn action_giguna__clouds__ctx__platform_set_true(ctx: &mut Context, world: &World) {
    // ^_platform = true
    ctx.set_giguna__clouds__ctx__platform(true);
}
pub fn action_giguna__clouds__ctx__platform_set_true_if___indra_within_position____indra_set_giguna_gt_clouds_gt_platform_stop__portal_set_giguna_gt_clouds_gt_platform_stop(
    ctx: &mut Context,
    world: &World,
) {
    // ^_platform = true; if (^indra WITHIN ^position) { ^indra = `Giguna > Clouds > Platform Stop`; }; ^portal = `Giguna > Clouds > Platform Stop`;
    ctx.set_giguna__clouds__ctx__platform(true);
    if ctx.indra() == ctx.position() {
        ctx.set_indra(SpotId::Giguna__Clouds__Platform_Stop);
    }
    ctx.set_portal(SpotId::Giguna__Clouds__Platform_Stop);
}
pub fn action_giguna__clouds__ctx__platform_set_true_portal_set_giguna_gt_clouds_gt_platform_stop_invoke_deploy_drone_and_move__giguna_gt_clouds_gt_platform_stop(
    ctx: &mut Context,
    world: &World,
) {
    // ^_platform = true; ^portal = `Giguna > Clouds > Platform Stop`; $deploy_drone_and_move(`Giguna > Clouds > Platform Stop`)
    ctx.set_giguna__clouds__ctx__platform(true);
    ctx.set_portal(SpotId::Giguna__Clouds__Platform_Stop);
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Clouds__Platform_Stop);
}
pub fn action_giguna__east_caverns__ctx__combo_entered_set_true(ctx: &mut Context, world: &World) {
    // ^_combo_entered = true
    ctx.set_giguna__east_caverns__ctx__combo_entered(true);
}
pub fn action_giguna__east_caverns__ctx__door_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_door_opened = true
    ctx.set_giguna__east_caverns__ctx__door_opened(true);
}
pub fn action_giguna__east_caverns__ctx__lower_susar_set_true(ctx: &mut Context, world: &World) {
    // ^_lower_susar = true
    ctx.set_giguna__east_caverns__ctx__lower_susar(true);
}
pub fn action_giguna__east_caverns__ctx__mid_susar_set_true(ctx: &mut Context, world: &World) {
    // ^_mid_susar = true
    ctx.set_giguna__east_caverns__ctx__mid_susar(true);
}
pub fn action_giguna__east_caverns__ctx__upper_susar_set_true(ctx: &mut Context, world: &World) {
    // ^_upper_susar = true
    ctx.set_giguna__east_caverns__ctx__upper_susar(true);
}
pub fn action_giguna__gateway__ctx__door_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_door_opened = true
    ctx.set_giguna__gateway__ctx__door_opened(true);
}
pub fn action_giguna__giguna_base__ctx__door_open_set_true(ctx: &mut Context, world: &World) {
    // ^_door_open = true
    ctx.set_giguna__giguna_base__ctx__door_open(true);
}
pub fn action_giguna__giguna_northeast__ctx__door_opened_set_true(
    ctx: &mut Context,
    world: &World,
) {
    // ^_door_opened = true
    ctx.set_giguna__giguna_northeast__ctx__door_opened(true);
}
pub fn action_giguna__labyrinth__ctx__door_set_true(ctx: &mut Context, world: &World) {
    // ^_door = true
    ctx.set_giguna__labyrinth__ctx__door(true);
}
pub fn action_giguna__ruins_top__ctx__doors_open_set_true(ctx: &mut Context, world: &World) {
    // ^_doors_open = true
    ctx.set_giguna__ruins_top__ctx__doors_open(true);
}
pub fn action_giguna__ruins_west__ctx__kishib_handled_set_true(ctx: &mut Context, world: &World) {
    // ^_kishib_handled = true
    ctx.set_giguna__ruins_west__ctx__kishib_handled(true);
}
pub fn action_giguna__west_caverns__ctx__east_susar_set_true(ctx: &mut Context, world: &World) {
    // ^_east_susar = true
    ctx.set_giguna__west_caverns__ctx__east_susar(true);
}
pub fn action_giguna_breach__sw_save__ctx__door_opened_set_true(ctx: &mut Context, world: &World) {
    // ^_door_opened = true
    ctx.set_giguna_breach__sw_save__ctx__door_opened(true);
}
pub fn action_glacier__ctx__hammonds_doors_set_true(ctx: &mut Context, world: &World) {
    // ^_hammonds_doors = true
    ctx.set_glacier__ctx__hammonds_doors(true);
}
pub fn action_glacier__lonely_bull__ctx__door_set_true(ctx: &mut Context, world: &World) {
    // ^_door = true
    ctx.set_glacier__lonely_bull__ctx__door(true);
}
pub fn action_glacier__vertical_room__ctx__lower_gatestones_set_true(
    ctx: &mut Context,
    world: &World,
) {
    // ^_lower_gatestones = true
    ctx.set_glacier__vertical_room__ctx__lower_gatestones(true);
}
pub fn action_glacier__vertical_room__ctx__upper_gatestone_set_true(
    ctx: &mut Context,
    world: &World,
) {
    // ^_upper_gatestone = true
    ctx.set_glacier__vertical_room__ctx__upper_gatestone(true);
}
pub fn action_if___indra_within_position____indra_set_giguna_gt_clouds_gt_platform_early_portal__portal_set_giguna_gt_clouds_gt_platform_early_portal(
    ctx: &mut Context,
    world: &World,
) {
    // if (^indra WITHIN ^position) { ^indra = `Giguna > Clouds > Platform Early Portal`; }; ^portal = `Giguna > Clouds > Platform Early Portal`;
    if ctx.indra() == ctx.position() {
        ctx.set_indra(SpotId::Giguna__Clouds__Platform_Early_Portal);
    }
    ctx.set_portal(SpotId::Giguna__Clouds__Platform_Early_Portal);
}
pub fn action_indra_set_invoke_default(ctx: &mut Context, world: &World) {
    // ^indra = $default
    ctx.set_indra(Default::default());
}
pub fn action_invoke_collect__irikar_royal_storage_wall_invoke_collect__flask_invoke_visit__irikar_gt_hub_gt_royal_storage_in_wall_gt_item_invoke_visit__irikar_gt_hub_gt_royal_storage_by_wall_gt_shockwave_just_the_wall(
    ctx: &mut Context,
    world: &World,
) {
    // $collect(Irikar_Royal_Storage_Wall); $collect(Flask); $visit(`Irikar > Hub > Royal Storage in Wall > Item`); $visit(`Irikar > Hub > Royal Storage By Wall > Shockwave Just The Wall`);
    ctx.collect(Item::Irikar_Royal_Storage_Wall, world);
    ctx.collect(Item::Flask, world);
    ctx.visit(LocationId::Irikar__Hub__Royal_Storage_in_Wall__Item);
    ctx.visit(LocationId::Irikar__Hub__Royal_Storage_By_Wall__Shockwave_Just_The_Wall);
}
pub fn action_invoke_deploy_drone(ctx: &mut Context, world: &World) {
    // $deploy_drone
    helper__deploy_drone!(ctx, world);
}
pub fn action_invoke_deploy_drone_and_move__annuna_gt_east_bridge_gt_center_corridor(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Center Corridor`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Annuna__East_Bridge__Center_Corridor);
}
pub fn action_invoke_deploy_drone_and_move__annuna_gt_east_bridge_gt_tower_base_east(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Tower Base East`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Annuna__East_Bridge__Tower_Base_East);
}
pub fn action_invoke_deploy_drone_and_move__ebih_gt_base_camp_gt_save_point(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Ebih > Base Camp > Save Point`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Base_Camp__Save_Point);
}
pub fn action_invoke_deploy_drone_and_move__ebih_gt_drone_room_gt_tree(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Ebih > Drone Room > Tree`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Drone_Room__Tree);
}
pub fn action_invoke_deploy_drone_and_move__ebih_gt_ebih_west_gt_alcove_entrance(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Ebih > Ebih West > Alcove Entrance`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Ebih_West__Alcove_Entrance);
}
pub fn action_invoke_deploy_drone_and_move__giguna_gt_giguna_base_gt_kari(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Giguna > Giguna Base > Kari`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Giguna_Base__Kari);
}
pub fn action_invoke_deploy_drone_and_move__giguna_gt_ruins_top_gt_west_7(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Giguna > Ruins Top > West 7`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Ruins_Top__West_7);
}
pub fn action_invoke_deploy_drone_and_move__giguna_gt_wasteland_gt_middle_path(
    ctx: &mut Context,
    world: &World,
) {
    // $deploy_drone_and_move(`Giguna > Wasteland > Middle Path`)
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Wasteland__Middle_Path);
}
pub fn action_invoke_post_portal_save_update(ctx: &mut Context, world: &World) {
    // $post_portal_save_update
    helper__post_portal_save_update!(ctx, world);
}
pub fn action_invoke_refill_energy(ctx: &mut Context, world: &World) {
    // $refill_energy
    helper__refill_energy!(ctx, world);
}
pub fn action_invoke_reload(ctx: &mut Context, world: &World) {
    // $reload
    helper__reload!(ctx, world);
}
pub fn action_invoke_reset_old_area__newpos(ctx: &mut Context, world: &World, newpos: SpotId) {
    // $reset_old_area(^newpos)
    helper__reset_old_area!(ctx, world, newpos);
}
pub fn action_invoke_save(ctx: &mut Context, world: &World) {
    // $save
    helper__save!(ctx, world);
}
pub fn action_invoke_save_last(ctx: &mut Context, world: &World, newpos: SpotId) {
    // $save_last
    helper__save_last!(ctx, world);
}
pub fn action_invoke_save_last_invoke_refill_energy(
    ctx: &mut Context,
    world: &World,
    newpos: SpotId,
) {
    // $save_last; $refill_energy
    helper__save_last!(ctx, world);
    helper__refill_energy!(ctx, world);
}
pub fn action_invoke_visit__amagi_gt_west_lake_gt_cavern_refill_station_gt_break_wall_invoke_add_item__amagi_dragon_eye_passage(
    ctx: &mut Context,
    world: &World,
) {
    // $visit(`Amagi > West Lake > Cavern Refill Station > Break Wall`); $add_item(Amagi_Dragon_Eye_Passage);
    ctx.visit(LocationId::Amagi__West_Lake__Cavern_Refill_Station__Break_Wall);
    ctx.add_item(Item::Amagi_Dragon_Eye_Passage);
}
pub fn action_invoke_visit__amagi_gt_west_lake_gt_stronghold_ceiling_left_gt_knock_down_left_boulder_invoke_add_item__amagi_stronghold_wall_1_invoke_add_item__amagi_stronghold_boulder_1(
    ctx: &mut Context,
    world: &World,
) {
    // $visit(`Amagi > West Lake > Stronghold Ceiling Left > Knock Down Left Boulder`); $add_item(Amagi_Stronghold_Wall_1); $add_item(Amagi_Stronghold_Boulder_1);
    ctx.visit(LocationId::Amagi__West_Lake__Stronghold_Ceiling_Left__Knock_Down_Left_Boulder);
    ctx.add_item(Item::Amagi_Stronghold_Wall_1);
    ctx.add_item(Item::Amagi_Stronghold_Boulder_1);
}
pub fn action_invoke_visit__amagi_gt_west_lake_gt_stronghold_ceiling_right_gt_knock_down_right_boulder_invoke_add_item__amagi_stronghold_wall_2_invoke_add_item__amagi_stronghold_boulder_2(
    ctx: &mut Context,
    world: &World,
) {
    // $visit(`Amagi > West Lake > Stronghold Ceiling Right > Knock Down Right Boulder`); $add_item(Amagi_Stronghold_Wall_2); $add_item(Amagi_Stronghold_Boulder_2);
    ctx.visit(LocationId::Amagi__West_Lake__Stronghold_Ceiling_Right__Knock_Down_Right_Boulder);
    ctx.add_item(Item::Amagi_Stronghold_Wall_2);
    ctx.add_item(Item::Amagi_Stronghold_Boulder_2);
}
pub fn action_invoke_visit__ebih_gt_waterfall_gt_alcove_gt_block_left_invoke_visit__ebih_gt_waterfall_gt_alcove_gt_block_right_invoke_add_item__ebih_waterfall_block_right_invoke_add_item__ebih_waterfall_block_left(
    ctx: &mut Context,
    world: &World,
) {
    // $visit(`Ebih > Waterfall > Alcove > Block Left`); $visit(`Ebih > Waterfall > Alcove > Block Right`); $add_item(Ebih_Waterfall_Block_Right); $add_item(Ebih_Waterfall_Block_Left);
    ctx.visit(LocationId::Ebih__Waterfall__Alcove__Block_Left);
    ctx.visit(LocationId::Ebih__Waterfall__Alcove__Block_Right);
    ctx.add_item(Item::Ebih_Waterfall_Block_Right);
    ctx.add_item(Item::Ebih_Waterfall_Block_Left);
}
pub fn action_invoke_visit__giguna_gt_separator_gt_upper_brick_gt_break_bricks_invoke_add_item__giguna_separator_bricks_indra_set_invoke_default(
    ctx: &mut Context,
    world: &World,
) {
    // $visit(`Giguna > Separator > Upper Brick > Break Bricks`); $add_item(Giguna_Separator_Bricks); ^indra = $default;
    ctx.visit(LocationId::Giguna__Separator__Upper_Brick__Break_Bricks);
    ctx.add_item(Item::Giguna_Separator_Bricks);
    ctx.set_indra(Default::default());
}
pub fn action_invoke_visit__glacier_gt_fortress_gt_inner_center_gt_shockwave_block_invoke_visit__glacier_gt_fortress_gt_button_gt_hit_button_invoke_collect__big_flask_invoke_add_item__glacier_fortress_gate(
    ctx: &mut Context,
    world: &World,
) {
    // $visit(`Glacier > Fortress > Inner Center > Shockwave Block`); $visit(`Glacier > Fortress > Button > Hit Button`); $collect(Big_Flask); $add_item(Glacier_Fortress_Gate);
    ctx.visit(LocationId::Glacier__Fortress__Inner_Center__Shockwave_Block);
    ctx.visit(LocationId::Glacier__Fortress__Button__Hit_Button);
    ctx.collect(Item::Big_Flask, world);
    ctx.add_item(Item::Glacier_Fortress_Gate);
}
pub fn action_irikar__basement_portal__ctx__platform_moved_set_true(
    ctx: &mut Context,
    world: &World,
) {
    // ^_platform_moved = true
    ctx.set_irikar__basement_portal__ctx__platform_moved(true);
}
pub fn action_irikar__midwest__ctx__left_platform_set_true(ctx: &mut Context, world: &World) {
    // ^_left_platform = true
    ctx.set_irikar__midwest__ctx__left_platform(true);
}
pub fn action_irikar__midwest__ctx__right_platform_set_true(ctx: &mut Context, world: &World) {
    // ^_right_platform = true
    ctx.set_irikar__midwest__ctx__right_platform(true);
}
pub fn action_last_set_invoke_default(ctx: &mut Context, world: &World) {
    // ^last = $default
    ctx.set_last(Default::default());
}
pub fn action_last_set_position(ctx: &mut Context, world: &World) {
    // ^last = ^position
    ctx.set_last(ctx.position());
}
pub fn action_mode_set_drone(ctx: &mut Context, world: &World) {
    // ^mode = 'drone'
    ctx.set_mode(enums::Mode::Drone);
}
pub fn action_mode_set_drone_indra_set_position(ctx: &mut Context, world: &World) {
    // ^mode = 'drone'; ^indra = ^position
    ctx.set_mode(enums::Mode::Drone);
    ctx.set_indra(ctx.position());
}
pub fn action_mode_set_indra(ctx: &mut Context, world: &World) {
    // ^mode = 'Indra'
    ctx.set_mode(enums::Mode::Indra);
}
pub fn action_mode_set_indra_last_set_indra(ctx: &mut Context, world: &World) {
    // ^mode = 'Indra'; ^last = ^indra
    ctx.set_mode(enums::Mode::Indra);
    ctx.set_last(ctx.indra());
}
pub fn action_portal_set_amagi_gt_east_lake_gt_arch_east(ctx: &mut Context, world: &World) {
    // ^portal = `Amagi > East Lake > Arch East`
    ctx.set_portal(SpotId::Amagi__East_Lake__Arch_East);
}
pub fn action_portal_set_amagi_gt_east_lake_gt_arch_west(ctx: &mut Context, world: &World) {
    // ^portal = `Amagi > East Lake > Arch West`
    ctx.set_portal(SpotId::Amagi__East_Lake__Arch_West);
}
pub fn action_portal_set_giguna_gt_clouds_gt_platform_early_portal_invoke_deploy_drone_and_move__giguna_gt_clouds_gt_platform_early_portal(
    ctx: &mut Context,
    world: &World,
) {
    // ^portal = `Giguna > Clouds > Platform Early Portal`; $deploy_drone_and_move(`Giguna > Clouds > Platform Early Portal`)
    ctx.set_portal(SpotId::Giguna__Clouds__Platform_Early_Portal);
    helper__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Clouds__Platform_Early_Portal);
}
pub fn action_portal_set_glacier_breach_gt_angry_lions_gt_second_platform(
    ctx: &mut Context,
    world: &World,
) {
    // ^portal = `Glacier Breach > Angry Lions > Second Platform`
    ctx.set_portal(SpotId::Glacier_Breach__Angry_Lions__Second_Platform);
}
pub fn action_portal_set_glacier_breach_gt_angry_lions_gt_top_platform(
    ctx: &mut Context,
    world: &World,
) {
    // ^portal = `Glacier Breach > Angry Lions > Top Platform`
    ctx.set_portal(SpotId::Glacier_Breach__Angry_Lions__Top_Platform);
}
pub fn action_portal_set_glacier_gt_hammonds_end_gt_corner(ctx: &mut Context, world: &World) {
    // ^portal = `Glacier > Hammond's End > Corner`
    ctx.set_portal(SpotId::Glacier__Hammonds_End__Corner);
}
pub fn action_portal_set_glacier_gt_hammonds_end_gt_hammond(ctx: &mut Context, world: &World) {
    // ^portal = `Glacier > Hammond's End > Hammond`
    ctx.set_portal(SpotId::Glacier__Hammonds_End__Hammond);
}
pub fn action_portal_set_glacier_gt_hammonds_end_gt_lower_pedestal_west(
    ctx: &mut Context,
    world: &World,
) {
    // ^portal = `Glacier > Hammond's End > Lower Pedestal West`
    ctx.set_portal(SpotId::Glacier__Hammonds_End__Lower_Pedestal_West);
}
pub fn action_portal_set_position(ctx: &mut Context, world: &World) {
    // ^portal = ^position
    ctx.set_portal(ctx.position());
}
pub fn action_refills_incr_1(ctx: &mut Context, world: &World) {
    // ^refills += 1
    ctx.refills += 1;
}
pub fn action_save_set_emergence_gt_camp_exterior_gt_save_point(ctx: &mut Context, world: &World) {
    // ^save = `Emergence > Camp Exterior > Save Point`
    ctx.set_save(SpotId::Emergence__Camp_Exterior__Save_Point);
}
pub fn action_save_set_glacier_gt_revival_gt_save_point(ctx: &mut Context, world: &World) {
    // ^save = `Glacier > Revival > Save Point`
    ctx.set_save(SpotId::Glacier__Revival__Save_Point);
}
pub fn action_save_set_uhrum_gt_emergence_save_gt_save_point(ctx: &mut Context, world: &World) {
    // ^save = `Uhrum > Emergence Save > Save Point`
    ctx.set_save(SpotId::Uhrum__Emergence_Save__Save_Point);
}
pub fn explain___bridge_hover_or_slingshot_charge_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // (bridge_hover or Slingshot_Charge) and $hookhover
    {
        let mut left = ({
            let mut left = {
                let s = world.bridge_hover;
                edict.insert("bridge_hover", format!("{}", s));
                (s, vec!["bridge_hover"])
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Charge);
                    edict.insert("Slingshot_Charge", format!("{}", h));
                    (h, vec!["Slingshot_Charge"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        });
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain___escape_apocalypse_bomb_invoke_objective(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Escape, Apocalypse_Bomb, $objective]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Escape);
            edict.insert("Escape", format!("{}", h));
            (h, vec!["Escape"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = {
            let h = ctx.has(Item::Apocalypse_Bomb);
            edict.insert("Apocalypse_Bomb", format!("{}", h));
            (h, vec!["Apocalypse_Bomb"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = rexplain__objective!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___infect_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Infect, Nanite_Mist]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = {
            let h = ctx.has(Item::Nanite_Mist);
            edict.insert("Nanite_Mist", format!("{}", h));
            (h, vec!["Nanite_Mist"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___invoke_all_urns(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [$all_urns]
    {
        let mut refs = Vec::new();
        let mut h = hexplain__all_urns!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___invoke_all_urns_invoke_all_weapons_invoke_other_items_invoke_all_notes_invoke_all_health_invoke_all_flasks(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [$all_urns, $all_weapons, $other_items, $all_notes, $all_health, $all_flasks]
    {
        let mut refs = Vec::new();
        let mut h = hexplain__all_urns!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_weapons!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__other_items!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_notes!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_health!(ctx, world, edict);
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = hexplain__all_flasks!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___invoke_grab_and_anuman_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ($grab and Anuman) or $climb
    {
        let mut left = ({
            let mut left = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        });
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain___invoke_grab_or_invoke_climb_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ($grab or $climb) and Underwater_Movement
    {
        let mut left = ({
            let mut left = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                    edict.insert("$climb", format!("{:?}", res));
                    refs.push("$climb");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        });
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain___invoke_grab_or_invoke_climb_or_invoke_hook_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ($grab or $climb or $hook) and Underwater_Movement
    {
        let mut left = ({
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        });
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain___invoke_hook_or_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ($hook or $hover) and Underwater_Movement
    {
        let mut left = ({
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        });
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain___invoke_objective(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [$objective]
    {
        let mut refs = Vec::new();
        let mut h = rexplain__objective!(ctx, world, edict);
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain___remote_drone_flask__6(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // [Remote_Drone, Flask{6}]
    {
        let mut refs = Vec::new();
        let mut h = {
            let h = ctx.has(Item::Remote_Drone);
            edict.insert("Remote_Drone", format!("{}", h));
            (h, vec!["Remote_Drone"])
        };
        refs.append(&mut h.1);
        if !h.0 {
            return (false, refs);
        };
        let mut h = {
            let ct = ctx.count(Item::Flask);
            edict.insert("Flask count", format!("{}", ct));
            (ct >= 6, vec!["Flask count"])
        };
        refs.append(&mut h.1);
        (h.0, refs)
    }
}
pub fn explain_allow_warps_and_invoke_ft_breach_and___map_spot_within_menu_gt_breach_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // allow_warps and $ft_breach and (^map_spot WITHIN `Menu > Breach Map`) and not Apocalypse_Bomb
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let s = world.allow_warps;
                    edict.insert("allow_warps", format!("{}", s));
                    (s, vec!["allow_warps"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__ft_breach!(ctx, world, edict);
                        edict.insert("$ft_breach", format!("{:?}", res));
                        refs.push("$ft_breach");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let r = {
                        let r = data::map_spot(ctx.position());
                        edict.insert("^map_spot", format!("{:?}", r));
                        (r, vec!["^map_spot"])
                    };
                    (
                        r.0 != SpotId::None && get_area(r.0) == AreaId::Menu__Breach_Map,
                        r.1,
                    )
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Bomb);
                edict.insert("Apocalypse_Bomb", format!("{}", h));
                (!h, vec!["Apocalypse_Bomb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_allow_warps_and_invoke_ft_main_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // allow_warps and $ft_main and (^map_spot WITHIN `Menu > Kiengir Map`) and not Apocalypse_Bomb
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let s = world.allow_warps;
                    edict.insert("allow_warps", format!("{}", s));
                    (s, vec!["allow_warps"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__ft_main!(ctx, world, edict);
                        edict.insert("$ft_main", format!("{:?}", res));
                        refs.push("$ft_main");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let r = {
                        let r = data::map_spot(ctx.position());
                        edict.insert("^map_spot", format!("{:?}", r));
                        (r, vec!["^map_spot"])
                    };
                    (
                        r.0 != SpotId::None && get_area(r.0) == AreaId::Menu__Kiengir_Map,
                        r.1,
                    )
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Bomb);
                edict.insert("Apocalypse_Bomb", format!("{}", h));
                (!h, vec!["Apocalypse_Bomb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_allow_warps_and_not_within_menu_and_invoke_ft_main_and_invoke_can_recall_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // allow_warps and NOT WITHIN `Menu` and $ft_main and $can_recall and (^map_spot WITHIN `Menu > Kiengir Map`) and not Apocalypse_Bomb
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let mut left = {
                            let s = world.allow_warps;
                            edict.insert("allow_warps", format!("{}", s));
                            (s, vec!["allow_warps"])
                        };
                        if !left.0 {
                            left
                        } else {
                            let mut right = {
                                let r = ctx.position();
                                edict.insert("^position", format!("{:?}", r));
                                (
                                    match get_region(r) {
                                        RegionId::Menu => false,
                                        _ => true,
                                    },
                                    vec!["^position"],
                                )
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__ft_main!(ctx, world, edict);
                            edict.insert("$ft_main", format!("{:?}", res));
                            refs.push("$ft_main");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__can_recall!(ctx, world, edict);
                        edict.insert("$can_recall", format!("{:?}", res));
                        refs.push("$can_recall");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let r = {
                        let r = data::map_spot(ctx.position());
                        edict.insert("^map_spot", format!("{:?}", r));
                        (r, vec!["^map_spot"])
                    };
                    (
                        r.0 != SpotId::None && get_area(r.0) == AreaId::Menu__Kiengir_Map,
                        r.1,
                    )
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Bomb);
                edict.insert("Apocalypse_Bomb", format!("{}", h));
                (!h, vec!["Apocalypse_Bomb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_allow_warps_and_realm_eq_breach_and_breach_save_ne_invoke_default_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // allow_warps and ^realm == 'breach' and ^breach_save != $default and not Apocalypse_Bomb
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let s = world.allow_warps;
                    edict.insert("allow_warps", format!("{}", s));
                    (s, vec!["allow_warps"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let mut refs = vec!["^realm"];
                        let mut left = {
                            let r = data::realm(ctx.position());
                            edict.insert("^realm", format!("{:?}", r));
                            (r, vec!["^realm"])
                        };
                        let right = enums::Realm::Breach;
                        edict.insert("^realm", format!("{}", left.0));
                        refs.append(&mut left.1);
                        (left.0 == right, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut left = {
                        let r = ctx.breach_save();
                        edict.insert("^breach_save", format!("{:?}", r));
                        (r, vec!["^breach_save"])
                    };
                    let mut right = (Default::default(), vec![]);
                    left.1.append(&mut right.1);
                    (left.0 != right.0, left.1)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Bomb);
                edict.insert("Apocalypse_Bomb", format!("{}", h));
                (!h, vec!["Apocalypse_Bomb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_allow_warps_and_realm_in___main_interior_emergence_and_amashilama_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // allow_warps and ^realm IN ['main', 'interior', 'emergence'] and Amashilama and not Apocalypse_Bomb
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let s = world.allow_warps;
                    edict.insert("allow_warps", format!("{}", s));
                    (s, vec!["allow_warps"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let r = {
                            let r = data::realm(ctx.position());
                            edict.insert("^realm", format!("{:?}", r));
                            (r, vec!["^realm"])
                        };
                        (
                            matches!(
                                r.0,
                                enums::Realm::Main
                                    | enums::Realm::Interior
                                    | enums::Realm::Emergence
                            ),
                            r.1,
                        )
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Amashilama);
                    edict.insert("Amashilama", format!("{}", h));
                    (h, vec!["Amashilama"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Bomb);
                edict.insert("Apocalypse_Bomb", format!("{}", h));
                (!h, vec!["Apocalypse_Bomb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_allow_warps_and_within_antarctica(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // allow_warps and WITHIN `Antarctica`
    {
        let mut left = {
            let s = world.allow_warps;
            edict.insert("allow_warps", format!("{}", s));
            (s, vec!["allow_warps"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.position();
                edict.insert("^position", format!("{:?}", r));
                (
                    match get_region(r) {
                        RegionId::Antarctica => true,
                        _ => false,
                    },
                    vec!["^position"],
                )
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__main_area__ctx__combo_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and ($grab or $climb)
    {
        let mut left = {
            let r = ctx.amagi__main_area__ctx__combo();
            edict.insert("^amagi__main_area__ctx__combo", format!("{:?}", r));
            (r, vec!["^amagi__main_area__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__main_area__ctx__combo_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and $hook
    {
        let mut left = {
            let r = ctx.amagi__main_area__ctx__combo();
            edict.insert("^amagi__main_area__ctx__combo", format!("{:?}", r));
            (r, vec!["^amagi__main_area__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__secret_chamber__ctx__east_dur_esla_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_dur_esla and Nanite_Mist
    {
        let mut left = {
            let r = ctx.amagi__secret_chamber__ctx__east_dur_esla();
            edict.insert(
                "^amagi__secret_chamber__ctx__east_dur_esla",
                format!("{:?}", r),
            );
            (r, vec!["^amagi__secret_chamber__ctx__east_dur_esla"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__secret_chamber__ctx__east_dur_esla_and_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_dur_esla and Underwater_Movement and $hookhover
    {
        let mut left = {
            let mut left = {
                let r = ctx.amagi__secret_chamber__ctx__east_dur_esla();
                edict.insert(
                    "^amagi__secret_chamber__ctx__east_dur_esla",
                    format!("{:?}", r),
                );
                (r, vec!["^amagi__secret_chamber__ctx__east_dur_esla"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__secret_chamber__ctx__west_dur_esla_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_dur_esla and Nanite_Mist
    {
        let mut left = {
            let r = ctx.amagi__secret_chamber__ctx__west_dur_esla();
            edict.insert(
                "^amagi__secret_chamber__ctx__west_dur_esla",
                format!("{:?}", r),
            );
            (r, vec!["^amagi__secret_chamber__ctx__west_dur_esla"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi__secret_chamber__ctx__west_dur_esla_and_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_dur_esla and Underwater_Movement and $hookhover
    {
        let mut left = {
            let mut left = {
                let r = ctx.amagi__secret_chamber__ctx__west_dur_esla();
                edict.insert(
                    "^amagi__secret_chamber__ctx__west_dur_esla",
                    format!("{:?}", r),
                );
                (r, vec!["^amagi__secret_chamber__ctx__west_dur_esla"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_breach_lower_hallway_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Breach_Lower_Hallway_Gate
    {
        let h = ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate);
        edict.insert("Amagi_Breach_Lower_Hallway_Gate", format!("{}", h));
        (h, vec!["Amagi_Breach_Lower_Hallway_Gate"])
    }
}
pub fn explain_amagi_breach_lower_hallway_gate_and_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Breach_Lower_Hallway_Gate and Underwater_Movement and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let h = ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate);
                    edict.insert("Amagi_Breach_Lower_Hallway_Gate", format!("{}", h));
                    (h, vec!["Amagi_Breach_Lower_Hallway_Gate"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Underwater_Movement);
                        edict.insert("Underwater_Movement", format!("{}", h));
                        (h, vec!["Underwater_Movement"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_breach_split_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Breach_Split_Gate
    {
        let h = ctx.has(Item::Amagi_Breach_Split_Gate);
        edict.insert("Amagi_Breach_Split_Gate", format!("{}", h));
        (h, vec!["Amagi_Breach_Split_Gate"])
    }
}
pub fn explain_amagi_breach_west_ruins_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Breach_West_Ruins_Gate
    {
        let h = ctx.has(Item::Amagi_Breach_West_Ruins_Gate);
        edict.insert("Amagi_Breach_West_Ruins_Gate", format!("{}", h));
        (h, vec!["Amagi_Breach_West_Ruins_Gate"])
    }
}
pub fn explain_amagi_breach_west_ruins_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Breach_West_Ruins_Gate and Underwater_Movement
    {
        let mut left = {
            let h = ctx.has(Item::Amagi_Breach_West_Ruins_Gate);
            edict.insert("Amagi_Breach_West_Ruins_Gate", format!("{}", h));
            (h, vec!["Amagi_Breach_West_Ruins_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_breach_west_ruins_gate_and_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Breach_West_Ruins_Gate and Underwater_Movement and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let h = ctx.has(Item::Amagi_Breach_West_Ruins_Gate);
                    edict.insert("Amagi_Breach_West_Ruins_Gate", format!("{}", h));
                    (h, vec!["Amagi_Breach_West_Ruins_Gate"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Underwater_Movement);
                        edict.insert("Underwater_Movement", format!("{}", h));
                        (h, vec!["Underwater_Movement"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_dragon_eye_passage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Dragon_Eye_Passage
    {
        let h = ctx.has(Item::Amagi_Dragon_Eye_Passage);
        edict.insert("Amagi_Dragon_Eye_Passage", format!("{}", h));
        (h, vec!["Amagi_Dragon_Eye_Passage"])
    }
}
pub fn explain_amagi_gated_community_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Gated_Community_Gate
    {
        let h = ctx.has(Item::Amagi_Gated_Community_Gate);
        edict.insert("Amagi_Gated_Community_Gate", format!("{}", h));
        (h, vec!["Amagi_Gated_Community_Gate"])
    }
}
pub fn explain_amagi_gated_community_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Gated_Community_Gate and Underwater_Movement
    {
        let mut left = {
            let h = ctx.has(Item::Amagi_Gated_Community_Gate);
            edict.insert("Amagi_Gated_Community_Gate", format!("{}", h));
            (h, vec!["Amagi_Gated_Community_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_stronghold_boulder_1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_1
    {
        let h = ctx.has(Item::Amagi_Stronghold_Boulder_1);
        edict.insert("Amagi_Stronghold_Boulder_1", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Boulder_1"])
    }
}
pub fn explain_amagi_stronghold_boulder_1_and_underwater_movement_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_1 and Underwater_Movement and ($grab or $climb)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Amagi_Stronghold_Boulder_1);
                edict.insert("Amagi_Stronghold_Boulder_1", format!("{}", h));
                (h, vec!["Amagi_Stronghold_Boulder_1"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_stronghold_boulder_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_2
    {
        let h = ctx.has(Item::Amagi_Stronghold_Boulder_2);
        edict.insert("Amagi_Stronghold_Boulder_2", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Boulder_2"])
    }
}
pub fn explain_amagi_stronghold_boulder_2_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Boulder_2 and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Amagi_Stronghold_Boulder_2);
            edict.insert("Amagi_Stronghold_Boulder_2", format!("{}", h));
            (h, vec!["Amagi_Stronghold_Boulder_2"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_stronghold_left_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Left_Wall
    {
        let h = ctx.has(Item::Amagi_Stronghold_Left_Wall);
        edict.insert("Amagi_Stronghold_Left_Wall", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Left_Wall"])
    }
}
pub fn explain_amagi_stronghold_left_wall_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Left_Wall and Underwater_Movement
    {
        let mut left = {
            let h = ctx.has(Item::Amagi_Stronghold_Left_Wall);
            edict.insert("Amagi_Stronghold_Left_Wall", format!("{}", h));
            (h, vec!["Amagi_Stronghold_Left_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_stronghold_wall_1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Wall_1
    {
        let h = ctx.has(Item::Amagi_Stronghold_Wall_1);
        edict.insert("Amagi_Stronghold_Wall_1", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Wall_1"])
    }
}
pub fn explain_amagi_stronghold_wall_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Stronghold_Wall_2
    {
        let h = ctx.has(Item::Amagi_Stronghold_Wall_2);
        edict.insert("Amagi_Stronghold_Wall_2", format!("{}", h));
        (h, vec!["Amagi_Stronghold_Wall_2"])
    }
}
pub fn explain_amagi_west_lake_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_West_Lake_Gate
    {
        let h = ctx.has(Item::Amagi_West_Lake_Gate);
        edict.insert("Amagi_West_Lake_Gate", format!("{}", h));
        (h, vec!["Amagi_West_Lake_Gate"])
    }
}
pub fn explain_amagi_west_lake_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_West_Lake_Gate and Underwater_Movement
    {
        let mut left = {
            let h = ctx.has(Item::Amagi_West_Lake_Gate);
            edict.insert("Amagi_West_Lake_Gate", format!("{}", h));
            (h, vec!["Amagi_West_Lake_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_amagi_west_lake_surface_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_West_Lake_Surface_Wall
    {
        let h = ctx.has(Item::Amagi_West_Lake_Surface_Wall);
        edict.insert("Amagi_West_Lake_Surface_Wall", format!("{}", h));
        (h, vec!["Amagi_West_Lake_Surface_Wall"])
    }
}
pub fn explain_amagi_wiggly_room_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Amagi_Wiggly_Room_Gate
    {
        let h = ctx.has(Item::Amagi_Wiggly_Room_Gate);
        edict.insert("Amagi_Wiggly_Room_Gate", format!("{}", h));
        (h, vec!["Amagi_Wiggly_Room_Gate"])
    }
}
pub fn explain_annuna__boss_gate__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door
    {
        let r = ctx.annuna__boss_gate__ctx__door();
        edict.insert("^annuna__boss_gate__ctx__door", format!("{:?}", r));
        (r, vec!["^annuna__boss_gate__ctx__door"])
    }
}
pub fn explain_annuna__east_bridge__ctx__combo(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo
    {
        let r = ctx.annuna__east_bridge__ctx__combo();
        edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
        (r, vec!["^annuna__east_bridge__ctx__combo"])
    }
}
pub fn explain_annuna__east_bridge__ctx__combo_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and $grab
    {
        let mut left = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__east_bridge__ctx__combo_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_combo and $hook
    {
        let mut left = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__invisible_enemies__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.annuna__invisible_enemies__ctx__door_opened();
        edict.insert(
            "^annuna__invisible_enemies__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^annuna__invisible_enemies__ctx__door_opened"])
    }
}
pub fn explain_annuna__invisible_enemies__ctx__door_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened and $hookhover
    {
        let mut left = {
            let r = ctx.annuna__invisible_enemies__ctx__door_opened();
            edict.insert(
                "^annuna__invisible_enemies__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^annuna__invisible_enemies__ctx__door_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__invisible_enemies__ctx__nw_utu(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_nw_utu
    {
        let r = ctx.annuna__invisible_enemies__ctx__nw_utu();
        edict.insert(
            "^annuna__invisible_enemies__ctx__nw_utu",
            format!("{:?}", r),
        );
        (r, vec!["^annuna__invisible_enemies__ctx__nw_utu"])
    }
}
pub fn explain_annuna__invisible_enemies__ctx__nw_utu_and_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_nw_utu and $melee_cskip
    {
        let mut left = {
            let r = ctx.annuna__invisible_enemies__ctx__nw_utu();
            edict.insert(
                "^annuna__invisible_enemies__ctx__nw_utu",
                format!("{:?}", r),
            );
            (r, vec!["^annuna__invisible_enemies__ctx__nw_utu"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__melee_cskip!(ctx, world, edict);
                edict.insert("$melee_cskip", format!("{:?}", res));
                refs.push("$melee_cskip");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__invisible_enemies__ctx__nw_utu_and_invoke_melee_cskip_and_fast_travel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_nw_utu and $melee_cskip and Fast_Travel
    {
        let mut left = {
            let mut left = {
                let r = ctx.annuna__invisible_enemies__ctx__nw_utu();
                edict.insert(
                    "^annuna__invisible_enemies__ctx__nw_utu",
                    format!("{:?}", r),
                );
                (r, vec!["^annuna__invisible_enemies__ctx__nw_utu"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__melee_cskip!(ctx, world, edict);
                    edict.insert("$melee_cskip", format!("{:?}", res));
                    refs.push("$melee_cskip");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Fast_Travel);
                edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__udug_gate__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door
    {
        let r = ctx.annuna__udug_gate__ctx__door();
        edict.insert("^annuna__udug_gate__ctx__door", format!("{:?}", r));
        (r, vec!["^annuna__udug_gate__ctx__door"])
    }
}
pub fn explain_annuna__vertical_room__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.annuna__vertical_room__ctx__door_opened();
        edict.insert(
            "^annuna__vertical_room__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^annuna__vertical_room__ctx__door_opened"])
    }
}
pub fn explain_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_opened
    {
        let r = ctx.annuna__west_bridge__ctx__doors_opened();
        edict.insert(
            "^annuna__west_bridge__ctx__doors_opened",
            format!("{:?}", r),
        );
        (r, vec!["^annuna__west_bridge__ctx__doors_opened"])
    }
}
pub fn explain_annuna__west_bridge__ctx__doors_opened_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_opened and $grab
    {
        let mut left = {
            let r = ctx.annuna__west_bridge__ctx__doors_opened();
            edict.insert(
                "^annuna__west_bridge__ctx__doors_opened",
                format!("{:?}", r),
            );
            (r, vec!["^annuna__west_bridge__ctx__doors_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__west_bridge__ctx__doors_opened_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_opened and $hook
    {
        let mut left = {
            let r = ctx.annuna__west_bridge__ctx__doors_opened();
            edict.insert(
                "^annuna__west_bridge__ctx__doors_opened",
                format!("{:?}", r),
            );
            (r, vec!["^annuna__west_bridge__ctx__doors_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__west_bridge__ctx__doors_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_opened and $hookhover
    {
        let mut left = {
            let r = ctx.annuna__west_bridge__ctx__doors_opened();
            edict.insert(
                "^annuna__west_bridge__ctx__doors_opened",
                format!("{:?}", r),
            );
            (r, vec!["^annuna__west_bridge__ctx__doors_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna__west_climb__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.annuna__west_climb__ctx__door_opened();
        edict.insert("^annuna__west_climb__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^annuna__west_climb__ctx__door_opened"])
    }
}
pub fn explain_annuna_breach_factory_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Breach_Factory_Gate
    {
        let h = ctx.has(Item::Annuna_Breach_Factory_Gate);
        edict.insert("Annuna_Breach_Factory_Gate", format!("{}", h));
        (h, vec!["Annuna_Breach_Factory_Gate"])
    }
}
pub fn explain_annuna_breach_upper_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Breach_Upper_Gate
    {
        let h = ctx.has(Item::Annuna_Breach_Upper_Gate);
        edict.insert("Annuna_Breach_Upper_Gate", format!("{}", h));
        (h, vec!["Annuna_Breach_Upper_Gate"])
    }
}
pub fn explain_annuna_breach_upper_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Breach_Upper_Gate and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Annuna_Breach_Upper_Gate);
            edict.insert("Annuna_Breach_Upper_Gate", format!("{}", h));
            (h, vec!["Annuna_Breach_Upper_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_double_trouble_bosses_and_invoke_can_damage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Double_Trouble_Bosses and $can_damage
    {
        let mut left = {
            let h = ctx.has(Item::Annuna_Double_Trouble_Bosses);
            edict.insert("Annuna_Double_Trouble_Bosses", format!("{}", h));
            (h, vec!["Annuna_Double_Trouble_Bosses"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_damage!(ctx, world, edict);
                edict.insert("$can_damage", format!("{:?}", res));
                refs.push("$can_damage");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_double_trouble_bosses_and_invoke_shockwave_and___boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Double_Trouble_Bosses and $shockwave and (Boomerang or Boomerang_Upgrade)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Annuna_Double_Trouble_Bosses);
                edict.insert("Annuna_Double_Trouble_Bosses", format!("{}", h));
                (h, vec!["Annuna_Double_Trouble_Bosses"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                    edict.insert("$shockwave", format!("{:?}", res));
                    refs.push("$shockwave");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Boomerang);
                    edict.insert("Boomerang", format!("{}", h));
                    (h, vec!["Boomerang"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Boomerang_Upgrade);
                        edict.insert("Boomerang_Upgrade", format!("{}", h));
                        (h, vec!["Boomerang_Upgrade"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_double_trouble_bosses_and_invoke_shockwave_and___invoke_weapon_or_anuman_or_boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Double_Trouble_Bosses and $shockwave and ($weapon or Anuman or Boomerang or Boomerang_Upgrade)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Annuna_Double_Trouble_Bosses);
                edict.insert("Annuna_Double_Trouble_Bosses", format!("{}", h));
                (h, vec!["Annuna_Double_Trouble_Bosses"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                    edict.insert("$shockwave", format!("{:?}", res));
                    refs.push("$shockwave");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let mut left = {
                        let mut left = {
                            let (res, mut refs) = hexplain__weapon!(ctx, world, edict);
                            edict.insert("$weapon", format!("{:?}", res));
                            refs.push("$weapon");
                            (res, refs)
                        };
                        if left.0 {
                            left
                        } else {
                            let mut right = {
                                let h = ctx.has(Item::Anuman);
                                edict.insert("Anuman", format!("{}", h));
                                (h, vec!["Anuman"])
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    };
                    if left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = ctx.has(Item::Boomerang);
                            edict.insert("Boomerang", format!("{}", h));
                            (h, vec!["Boomerang"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Boomerang_Upgrade);
                        edict.insert("Boomerang_Upgrade", format!("{}", h));
                        (h, vec!["Boomerang_Upgrade"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_East_Bridge_Gate
    {
        let h = ctx.has(Item::Annuna_East_Bridge_Gate);
        edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
        (h, vec!["Annuna_East_Bridge_Gate"])
    }
}
pub fn explain_annuna_east_bridge_gate_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_East_Bridge_Gate and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Annuna_East_Bridge_Gate);
            edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
            (h, vec!["Annuna_East_Bridge_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_lower_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Lower_Gate
    {
        let h = ctx.has(Item::Annuna_Lower_Gate);
        edict.insert("Annuna_Lower_Gate", format!("{}", h));
        (h, vec!["Annuna_Lower_Gate"])
    }
}
pub fn explain_annuna_lower_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Lower_Gate and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Annuna_Lower_Gate);
            edict.insert("Annuna_Lower_Gate", format!("{}", h));
            (h, vec!["Annuna_Lower_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_mirror_match_switch(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Mirror_Match_Switch
    {
        let h = ctx.has(Item::Annuna_Mirror_Match_Switch);
        edict.insert("Annuna_Mirror_Match_Switch", format!("{}", h));
        (h, vec!["Annuna_Mirror_Match_Switch"])
    }
}
pub fn explain_annuna_remote_training_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Remote_Training_Gate
    {
        let h = ctx.has(Item::Annuna_Remote_Training_Gate);
        edict.insert("Annuna_Remote_Training_Gate", format!("{}", h));
        (h, vec!["Annuna_Remote_Training_Gate"])
    }
}
pub fn explain_annuna_remote_training_gate_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Remote_Training_Gate and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Annuna_Remote_Training_Gate);
            edict.insert("Annuna_Remote_Training_Gate", format!("{}", h));
            (h, vec!["Annuna_Remote_Training_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_annuna_vertical_room_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Annuna_Vertical_Room_Gate
    {
        let h = ctx.has(Item::Annuna_Vertical_Room_Gate);
        edict.insert("Annuna_Vertical_Room_Gate", format!("{}", h));
        (h, vec!["Annuna_Vertical_Room_Gate"])
    }
}
pub fn explain_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman
    {
        let h = ctx.has(Item::Anuman);
        edict.insert("Anuman", format!("{}", h));
        (h, vec!["Anuman"])
    }
}
pub fn explain_anuman_and_invoke_boomerang(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and $boomerang
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__boomerang!(ctx, world, edict);
                edict.insert("$boomerang", format!("{:?}", res));
                refs.push("$boomerang");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and $climb
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and $shockwave
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_and_mode_eq_indra_and___ledge_grab_or_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and ^mode == 'Indra' and (Ledge_Grab or Slingshot_Hook)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = ctx.mode();
                        edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Indra;
                    edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Ledge_Grab);
                    edict.insert("Ledge_Grab", format!("{}", h));
                    (h, vec!["Ledge_Grab"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Slingshot_Hook);
                        edict.insert("Slingshot_Hook", format!("{}", h));
                        (h, vec!["Slingshot_Hook"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and ^mode != 'drone'
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_anuman_or___invoke_hook_and___not_slingshot_weapon_or_invoke_visited__annuna_gt_invisible_enemies_gt_corner_cache_gt_flask(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Anuman or ($hook and (not Slingshot_Weapon or $visited(`Annuna > Invisible Enemies > Corner Cache > Flask`)))
    {
        let mut left = {
            let h = ctx.has(Item::Anuman);
            edict.insert("Anuman", format!("{}", h));
            (h, vec!["Anuman"])
        };
        if left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = ({
                        let mut left = {
                            let h = ctx.has(Item::Slingshot_Weapon);
                            edict.insert("Slingshot_Weapon", format!("{}", h));
                            (!h, vec!["Slingshot_Weapon"])
                        };
                        if left.0 {
                            left
                        } else {
                            let mut right = {
                                let res = ctx.visited(
                                    LocationId::Annuna__Invisible_Enemies__Corner_Cache__Flask,
                                );
                                edict.insert(
                                    "$visited(`Annuna > Invisible Enemies > Corner Cache > Flask`)",
                                    format!("{:?}", res),
                                );
                                (res, vec!["$visited(`Annuna > Invisible Enemies > Corner Cache > Flask`)"])
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    });
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Apocalypse_Bomb
    {
        let h = ctx.has(Item::Apocalypse_Bomb);
        edict.insert("Apocalypse_Bomb", format!("{}", h));
        (h, vec!["Apocalypse_Bomb"])
    }
}
pub fn explain_apocalypse_bomb_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Apocalypse_Bomb and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Apocalypse_Bomb);
            edict.insert("Apocalypse_Bomb", format!("{}", h));
            (h, vec!["Apocalypse_Bomb"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_block_fast_travel_and_invoke_shockwave_and_fast_travel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // block_fast_travel and $shockwave and Fast_Travel
    {
        let mut left = {
            let mut left = {
                let s = world.block_fast_travel;
                edict.insert("block_fast_travel", format!("{}", s));
                (s, vec!["block_fast_travel"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                    edict.insert("$shockwave", format!("{:?}", res));
                    refs.push("$shockwave");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Fast_Travel);
                edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_boomerang(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Boomerang
    {
        let h = ctx.has(Item::Boomerang);
        edict.insert("Boomerang", format!("{}", h));
        (h, vec!["Boomerang"])
    }
}
pub fn explain_breach_attractor(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Breach_Attractor
    {
        let h = ctx.has(Item::Breach_Attractor);
        edict.insert("Breach_Attractor", format!("{}", h));
        (h, vec!["Breach_Attractor"])
    }
}
pub fn explain_breach_attractor_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Breach_Attractor and Anuman
    {
        let mut left = {
            let h = ctx.has(Item::Breach_Attractor);
            edict.insert("Breach_Attractor", format!("{}", h));
            (h, vec!["Breach_Attractor"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_breach_attractor_and_mode_eq_drone_and_indra_within___glacier_gt_grid_39sub40_7sub9_glacier_gt_revival_glacier_gt_dock_outside_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Breach_Attractor and ^mode == 'drone' and ^indra WITHIN (`Glacier > Grid 39-40,7-9`, `Glacier > Revival`, `Glacier > Dock Outside`) and ^portal == ^portal_start
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let h = ctx.has(Item::Breach_Attractor);
                    edict.insert("Breach_Attractor", format!("{}", h));
                    (h, vec!["Breach_Attractor"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let mut refs = vec!["^mode"];
                        let mut left = {
                            let r = ctx.mode();
                            edict.insert("^mode", format!("{:?}", r));
                            (r, vec!["^mode"])
                        };
                        let right = enums::Mode::Drone;
                        edict.insert("^mode", format!("{}", left.0));
                        refs.append(&mut left.1);
                        (left.0 == right, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let r = {
                        let r = ctx.indra();
                        edict.insert("^indra", format!("{:?}", r));
                        (r, vec!["^indra"])
                    };
                    (
                        r.0 != SpotId::None
                            && matches!(
                                get_area(r.0),
                                AreaId::Glacier__Grid_39_40_7_9
                                    | AreaId::Glacier__Revival
                                    | AreaId::Glacier__Dock_Outside
                            ),
                        r.1,
                    )
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut left = {
                    let r = ctx.portal();
                    edict.insert("^portal", format!("{:?}", r));
                    (r, vec!["^portal"])
                };
                let mut right = {
                    let r = data::portal_start(ctx.position());
                    edict.insert("^portal_start", format!("{:?}", r));
                    (r, vec!["^portal_start"])
                };
                left.1.append(&mut right.1);
                (left.0 == right.0, left.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_breach_attractor_and_mode_eq_drone_and_indra_within_annuna_gt_filter_teleporter_gt_shaft_top(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Breach_Attractor and ^mode == 'drone' and ^indra WITHIN `Annuna > Filter Teleporter > Shaft Top`
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Breach_Attractor);
                edict.insert("Breach_Attractor", format!("{}", h));
                (h, vec!["Breach_Attractor"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = ctx.mode();
                        edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = {
                    let r = ctx.indra();
                    edict.insert("^indra", format!("{:?}", r));
                    (r, vec!["^indra"])
                };
                (r.0 == SpotId::Annuna__Filter_Teleporter__Shaft_Top, r.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_defeat_indra(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Defeat_Indra
    {
        let h = ctx.has(Item::Defeat_Indra);
        edict.insert("Defeat_Indra", format!("{}", h));
        (h, vec!["Defeat_Indra"])
    }
}
pub fn explain_defeat_mus_a_m20(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Defeat_MUS_A_M20
    {
        let h = ctx.has(Item::Defeat_MUS_A_M20);
        edict.insert("Defeat_MUS_A_M20", format!("{}", h));
        (h, vec!["Defeat_MUS_A_M20"])
    }
}
pub fn explain_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Hover
    {
        let h = ctx.has(Item::Drone_Hover);
        edict.insert("Drone_Hover", format!("{}", h));
        (h, vec!["Drone_Hover"])
    }
}
pub fn explain_drone_hover_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Hover and Nanite_Mist
    {
        let mut left = {
            let h = ctx.has(Item::Drone_Hover);
            edict.insert("Drone_Hover", format!("{}", h));
            (h, vec!["Drone_Hover"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_drone_melee_damage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Damage
    {
        let h = ctx.has(Item::Drone_Melee_Damage);
        edict.insert("Drone_Melee_Damage", format!("{}", h));
        (h, vec!["Drone_Melee_Damage"])
    }
}
pub fn explain_drone_melee_damage_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Damage_2
    {
        let h = ctx.has(Item::Drone_Melee_Damage_2);
        edict.insert("Drone_Melee_Damage_2", format!("{}", h));
        (h, vec!["Drone_Melee_Damage_2"])
    }
}
pub fn explain_drone_melee_damage_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Damage_3
    {
        let h = ctx.has(Item::Drone_Melee_Damage_3);
        edict.insert("Drone_Melee_Damage_3", format!("{}", h));
        (h, vec!["Drone_Melee_Damage_3"])
    }
}
pub fn explain_drone_melee_speed(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Speed
    {
        let h = ctx.has(Item::Drone_Melee_Speed);
        edict.insert("Drone_Melee_Speed", format!("{}", h));
        (h, vec!["Drone_Melee_Speed"])
    }
}
pub fn explain_drone_melee_speed_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Drone_Melee_Speed_2
    {
        let h = ctx.has(Item::Drone_Melee_Speed_2);
        edict.insert("Drone_Melee_Speed_2", format!("{}", h));
        (h, vec!["Drone_Melee_Speed_2"])
    }
}
pub fn explain_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_left_platform_moved
    {
        let r = ctx.ebih__base_camp__ctx__left_platform_moved();
        edict.insert(
            "^ebih__base_camp__ctx__left_platform_moved",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
    }
}
pub fn explain_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__ebih_west__ctx__door_open();
        edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__ebih_west__ctx__door_open"])
    }
}
pub fn explain_ebih__grid_25_10_12__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__grid_25_10_12__ctx__door_open();
        edict.insert("^ebih__grid_25_10_12__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__grid_25_10_12__ctx__door_open"])
    }
}
pub fn explain_ebih__truck_gate__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__truck_gate__ctx__door_open();
        edict.insert("^ebih__truck_gate__ctx__door_open", format!("{:?}", r));
        (r, vec!["^ebih__truck_gate__ctx__door_open"])
    }
}
pub fn explain_ebih__vertical_interchange__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.ebih__vertical_interchange__ctx__door_open();
        edict.insert(
            "^ebih__vertical_interchange__ctx__door_open",
            format!("{:?}", r),
        );
        (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
    }
}
pub fn explain_ebih__waterfall__ctx__east_door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_door_open
    {
        let r = ctx.ebih__waterfall__ctx__east_door_open();
        edict.insert("^ebih__waterfall__ctx__east_door_open", format!("{:?}", r));
        (r, vec!["^ebih__waterfall__ctx__east_door_open"])
    }
}
pub fn explain_ebih__waterfall__ctx__east_door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_door_open and $hook
    {
        let mut left = {
            let r = ctx.ebih__waterfall__ctx__east_door_open();
            edict.insert("^ebih__waterfall__ctx__east_door_open", format!("{:?}", r));
            (r, vec!["^ebih__waterfall__ctx__east_door_open"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih__waterfall__ctx__west_door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_west_door_open
    {
        let r = ctx.ebih__waterfall__ctx__west_door_open();
        edict.insert("^ebih__waterfall__ctx__west_door_open", format!("{:?}", r));
        (r, vec!["^ebih__waterfall__ctx__west_door_open"])
    }
}
pub fn explain_ebih_alu(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Alu
    {
        let h = ctx.has(Item::Ebih_Alu);
        edict.insert("Ebih_Alu", format!("{}", h));
        (h, vec!["Ebih_Alu"])
    }
}
pub fn explain_ebih_breach_double_gate_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Double_Gate_Gate
    {
        let h = ctx.has(Item::Ebih_Breach_Double_Gate_Gate);
        edict.insert("Ebih_Breach_Double_Gate_Gate", format!("{}", h));
        (h, vec!["Ebih_Breach_Double_Gate_Gate"])
    }
}
pub fn explain_ebih_breach_double_gate_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Double_Gate_Gate and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Ebih_Breach_Double_Gate_Gate);
            edict.insert("Ebih_Breach_Double_Gate_Gate", format!("{}", h));
            (h, vec!["Ebih_Breach_Double_Gate_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_breach_in_n_out_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_In_n_Out_Gate
    {
        let h = ctx.has(Item::Ebih_Breach_In_n_Out_Gate);
        edict.insert("Ebih_Breach_In_n_Out_Gate", format!("{}", h));
        (h, vec!["Ebih_Breach_In_n_Out_Gate"])
    }
}
pub fn explain_ebih_breach_lake_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Lake_Gate
    {
        let h = ctx.has(Item::Ebih_Breach_Lake_Gate);
        edict.insert("Ebih_Breach_Lake_Gate", format!("{}", h));
        (h, vec!["Ebih_Breach_Lake_Gate"])
    }
}
pub fn explain_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Rock_Block_Rock
    {
        let h = ctx.has(Item::Ebih_Breach_Rock_Block_Rock);
        edict.insert("Ebih_Breach_Rock_Block_Rock", format!("{}", h));
        (h, vec!["Ebih_Breach_Rock_Block_Rock"])
    }
}
pub fn explain_ebih_breach_rocky_cages_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Rocky_Cages_Gate
    {
        let h = ctx.has(Item::Ebih_Breach_Rocky_Cages_Gate);
        edict.insert("Ebih_Breach_Rocky_Cages_Gate", format!("{}", h));
        (h, vec!["Ebih_Breach_Rocky_Cages_Gate"])
    }
}
pub fn explain_ebih_breach_rocky_cages_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Rocky_Cages_Gate and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Ebih_Breach_Rocky_Cages_Gate);
            edict.insert("Ebih_Breach_Rocky_Cages_Gate", format!("{}", h));
            (h, vec!["Ebih_Breach_Rocky_Cages_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_breach_spider_guards_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Spider_Guards_Gate
    {
        let h = ctx.has(Item::Ebih_Breach_Spider_Guards_Gate);
        edict.insert("Ebih_Breach_Spider_Guards_Gate", format!("{}", h));
        (h, vec!["Ebih_Breach_Spider_Guards_Gate"])
    }
}
pub fn explain_ebih_breach_spider_guards_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Breach_Spider_Guards_Gate and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Breach_Spider_Guards_Gate);
                edict.insert("Ebih_Breach_Spider_Guards_Gate", format!("{}", h));
                (h, vec!["Ebih_Breach_Spider_Guards_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_east_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_East_Wall
    {
        let h = ctx.has(Item::Ebih_East_Wall);
        edict.insert("Ebih_East_Wall", format!("{}", h));
        (h, vec!["Ebih_East_Wall"])
    }
}
pub fn explain_ebih_gem_room_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Gem_Room_Gate
    {
        let h = ctx.has(Item::Ebih_Gem_Room_Gate);
        edict.insert("Ebih_Gem_Room_Gate", format!("{}", h));
        (h, vec!["Ebih_Gem_Room_Gate"])
    }
}
pub fn explain_ebih_hidden_portal_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Hidden_Portal_Gate
    {
        let h = ctx.has(Item::Ebih_Hidden_Portal_Gate);
        edict.insert("Ebih_Hidden_Portal_Gate", format!("{}", h));
        (h, vec!["Ebih_Hidden_Portal_Gate"])
    }
}
pub fn explain_ebih_interchange_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Block
    {
        let h = ctx.has(Item::Ebih_Interchange_Block);
        edict.insert("Ebih_Interchange_Block", format!("{}", h));
        (h, vec!["Ebih_Interchange_Block"])
    }
}
pub fn explain_ebih_interchange_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate
    {
        let h = ctx.has(Item::Ebih_Interchange_Gate);
        edict.insert("Ebih_Interchange_Gate", format!("{}", h));
        (h, vec!["Ebih_Interchange_Gate"])
    }
}
pub fn explain_ebih_interchange_gate_and_ebih_interchange_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $grab
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_interchange_gate_and_ebih_interchange_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $hook
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_interchange_gate_and_not_ebih_interchange_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $grab
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (!h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_interchange_gate_and_not_ebih_interchange_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $hook
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Ebih_Interchange_Gate);
                edict.insert("Ebih_Interchange_Gate", format!("{}", h));
                (h, vec!["Ebih_Interchange_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Ebih_Interchange_Block);
                    edict.insert("Ebih_Interchange_Block", format!("{}", h));
                    (!h, vec!["Ebih_Interchange_Block"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_ebih_walled_off_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Walled_Off_Wall
    {
        let h = ctx.has(Item::Ebih_Walled_Off_Wall);
        edict.insert("Ebih_Walled_Off_Wall", format!("{}", h));
        (h, vec!["Ebih_Walled_Off_Wall"])
    }
}
pub fn explain_ebih_waterfall_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_Waterfall_Wall
    {
        let h = ctx.has(Item::Ebih_Waterfall_Wall);
        edict.insert("Ebih_Waterfall_Wall", format!("{}", h));
        (h, vec!["Ebih_Waterfall_Wall"])
    }
}
pub fn explain_ebih_west_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ebih_West_Block
    {
        let h = ctx.has(Item::Ebih_West_Block);
        edict.insert("Ebih_West_Block", format!("{}", h));
        (h, vec!["Ebih_West_Block"])
    }
}
pub fn explain_ellag(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ellag
    {
        let h = ctx.has(Item::Ellag);
        edict.insert("Ellag", format!("{}", h));
        (h, vec!["Ellag"])
    }
}
pub fn explain_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.emergence__storage__ctx__door_open();
        edict.insert("^emergence__storage__ctx__door_open", format!("{:?}", r));
        (r, vec!["^emergence__storage__ctx__door_open"])
    }
}
pub fn explain_emergence__storage__ctx__door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $hook
    {
        let mut left = {
            let r = ctx.emergence__storage__ctx__door_open();
            edict.insert("^emergence__storage__ctx__door_open", format!("{:?}", r));
            (r, vec!["^emergence__storage__ctx__door_open"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_emergence_dropoff_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Dropoff_Wall
    {
        let h = ctx.has(Item::Emergence_Dropoff_Wall);
        edict.insert("Emergence_Dropoff_Wall", format!("{}", h));
        (h, vec!["Emergence_Dropoff_Wall"])
    }
}
pub fn explain_emergence_dropoff_wall_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Dropoff_Wall and Anuman
    {
        let mut left = {
            let h = ctx.has(Item::Emergence_Dropoff_Wall);
            edict.insert("Emergence_Dropoff_Wall", format!("{}", h));
            (h, vec!["Emergence_Dropoff_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_emergence_dropoff_wall_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Dropoff_Wall and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Emergence_Dropoff_Wall);
            edict.insert("Emergence_Dropoff_Wall", format!("{}", h));
            (h, vec!["Emergence_Dropoff_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_emergence_dropoff_wall_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Dropoff_Wall and Nanite_Mist
    {
        let mut left = {
            let h = ctx.has(Item::Emergence_Dropoff_Wall);
            edict.insert("Emergence_Dropoff_Wall", format!("{}", h));
            (h, vec!["Emergence_Dropoff_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_emergence_rocks_fall_rock_1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Rocks_Fall_Rock_1
    {
        let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_1);
        edict.insert("Emergence_Rocks_Fall_Rock_1", format!("{}", h));
        (h, vec!["Emergence_Rocks_Fall_Rock_1"])
    }
}
pub fn explain_emergence_rocks_fall_rock_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Rocks_Fall_Rock_2
    {
        let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_2);
        edict.insert("Emergence_Rocks_Fall_Rock_2", format!("{}", h));
        (h, vec!["Emergence_Rocks_Fall_Rock_2"])
    }
}
pub fn explain_emergence_rocks_fall_rock_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Rocks_Fall_Rock_3
    {
        let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_3);
        edict.insert("Emergence_Rocks_Fall_Rock_3", format!("{}", h));
        (h, vec!["Emergence_Rocks_Fall_Rock_3"])
    }
}
pub fn explain_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Rocks_Fall_Rock_4
    {
        let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_4);
        edict.insert("Emergence_Rocks_Fall_Rock_4", format!("{}", h));
        (h, vec!["Emergence_Rocks_Fall_Rock_4"])
    }
}
pub fn explain_emergence_storage_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Storage_Rock
    {
        let h = ctx.has(Item::Emergence_Storage_Rock);
        edict.insert("Emergence_Storage_Rock", format!("{}", h));
        (h, vec!["Emergence_Storage_Rock"])
    }
}
pub fn explain_emergence_storage_tunnel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Emergence_Storage_Tunnel
    {
        let h = ctx.has(Item::Emergence_Storage_Tunnel);
        edict.insert("Emergence_Storage_Tunnel", format!("{}", h));
        (h, vec!["Emergence_Storage_Tunnel"])
    }
}
pub fn explain_fast_travel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Fast_Travel
    {
        let h = ctx.has(Item::Fast_Travel);
        edict.insert("Fast_Travel", format!("{}", h));
        (h, vec!["Fast_Travel"])
    }
}
pub fn explain_fast_travel_and_invoke_boomerang(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Fast_Travel and $boomerang
    {
        let mut left = {
            let h = ctx.has(Item::Fast_Travel);
            edict.insert("Fast_Travel", format!("{}", h));
            (h, vec!["Fast_Travel"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__boomerang!(ctx, world, edict);
                edict.insert("$boomerang", format!("{:?}", res));
                refs.push("$boomerang");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_fast_travel_and_invoke_boomerang2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Fast_Travel and $boomerang2
    {
        let mut left = {
            let h = ctx.has(Item::Fast_Travel);
            edict.insert("Fast_Travel", format!("{}", h));
            (h, vec!["Fast_Travel"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__boomerang2!(ctx, world, edict);
                edict.insert("$boomerang2", format!("{:?}", res));
                refs.push("$boomerang2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_fast_travel_and_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Fast_Travel and $melee_cskip
    {
        let mut left = {
            let h = ctx.has(Item::Fast_Travel);
            edict.insert("Fast_Travel", format!("{}", h));
            (h, vec!["Fast_Travel"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__melee_cskip!(ctx, world, edict);
                edict.insert("$melee_cskip", format!("{:?}", res));
                refs.push("$melee_cskip");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__carnelian__ctx__door_opened();
        edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__door_opened"])
    }
}
pub fn explain_giguna__carnelian__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar
    {
        let r = ctx.giguna__carnelian__ctx__lower_susar();
        edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__lower_susar"])
    }
}
pub fn explain_giguna__carnelian__ctx__lower_susar_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar and $grab
    {
        let mut left = {
            let r = ctx.giguna__carnelian__ctx__lower_susar();
            edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__lower_susar"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__ctx__lower_susar_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar and $hook
    {
        let mut left = {
            let r = ctx.giguna__carnelian__ctx__lower_susar();
            edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__lower_susar"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__carnelian__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__carnelian__ctx__upper_susar();
        edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
        (r, vec!["^giguna__carnelian__ctx__upper_susar"])
    }
}
pub fn explain_giguna__clouds__ctx__platform_and_invoke_attract_and_breach_sight_and_remote_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_platform and $attract and Breach_Sight and Remote_Drone
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let r = ctx.giguna__clouds__ctx__platform();
                    edict.insert("^giguna__clouds__ctx__platform", format!("{:?}", r));
                    (r, vec!["^giguna__clouds__ctx__platform"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                        edict.insert("$attract", format!("{:?}", res));
                        refs.push("$attract");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Breach_Sight);
                    edict.insert("Breach_Sight", format!("{}", h));
                    (h, vec!["Breach_Sight"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Remote_Drone);
                edict.insert("Remote_Drone", format!("{}", h));
                (h, vec!["Remote_Drone"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__clouds__ctx__platform_and_invoke_attract_and_invoke_can_deploy_and_breach_sight(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_platform and $attract and $can_deploy and Breach_Sight
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let r = ctx.giguna__clouds__ctx__platform();
                    edict.insert("^giguna__clouds__ctx__platform", format!("{:?}", r));
                    (r, vec!["^giguna__clouds__ctx__platform"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                        edict.insert("$attract", format!("{:?}", res));
                        refs.push("$attract");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                    edict.insert("$can_deploy", format!("{:?}", res));
                    refs.push("$can_deploy");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Breach_Sight);
                edict.insert("Breach_Sight", format!("{}", h));
                (h, vec!["Breach_Sight"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__east_caverns__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__east_caverns__ctx__door_opened();
        edict.insert(
            "^giguna__east_caverns__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__door_opened"])
    }
}
pub fn explain_giguna__east_caverns__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_susar
    {
        let r = ctx.giguna__east_caverns__ctx__lower_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__lower_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
    }
}
pub fn explain_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_mid_susar
    {
        let r = ctx.giguna__east_caverns__ctx__mid_susar();
        edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
        (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
    }
}
pub fn explain_giguna__east_caverns__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_susar
    {
        let r = ctx.giguna__east_caverns__ctx__upper_susar();
        edict.insert(
            "^giguna__east_caverns__ctx__upper_susar",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
    }
}
pub fn explain_giguna__gateway__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__gateway__ctx__door_opened();
        edict.insert("^giguna__gateway__ctx__door_opened", format!("{:?}", r));
        (r, vec!["^giguna__gateway__ctx__door_opened"])
    }
}
pub fn explain_giguna__giguna_base__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open
    {
        let r = ctx.giguna__giguna_base__ctx__door_open();
        edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
        (r, vec!["^giguna__giguna_base__ctx__door_open"])
    }
}
pub fn explain_giguna__giguna_base__ctx__door_open_and_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $grab and $climb
    {
        let mut left = {
            let mut left = {
                let r = ctx.giguna__giguna_base__ctx__door_open();
                edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
                (r, vec!["^giguna__giguna_base__ctx__door_open"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_base__ctx__door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_open and $hook
    {
        let mut left = {
            let r = ctx.giguna__giguna_base__ctx__door_open();
            edict.insert("^giguna__giguna_base__ctx__door_open", format!("{:?}", r));
            (r, vec!["^giguna__giguna_base__ctx__door_open"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna__giguna_northeast__ctx__door_opened();
        edict.insert(
            "^giguna__giguna_northeast__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
    }
}
pub fn explain_giguna__giguna_northeast__ctx__door_opened_and___invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened and ($grab or $hook)
    {
        let mut left = {
            let r = ctx.giguna__giguna_northeast__ctx__door_opened();
            edict.insert(
                "^giguna__giguna_northeast__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                        edict.insert("$hook", format!("{:?}", res));
                        refs.push("$hook");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_northeast__ctx__door_opened_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened and $hook
    {
        let mut left = {
            let r = ctx.giguna__giguna_northeast__ctx__door_opened();
            edict.insert(
                "^giguna__giguna_northeast__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__giguna_northeast__ctx__door_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened and $hookhover
    {
        let mut left = {
            let r = ctx.giguna__giguna_northeast__ctx__door_opened();
            edict.insert(
                "^giguna__giguna_northeast__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna__labyrinth__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door
    {
        let r = ctx.giguna__labyrinth__ctx__door();
        edict.insert("^giguna__labyrinth__ctx__door", format!("{:?}", r));
        (r, vec!["^giguna__labyrinth__ctx__door"])
    }
}
pub fn explain_giguna__ruins_top__ctx__doors_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_doors_open
    {
        let r = ctx.giguna__ruins_top__ctx__doors_open();
        edict.insert("^giguna__ruins_top__ctx__doors_open", format!("{:?}", r));
        (r, vec!["^giguna__ruins_top__ctx__doors_open"])
    }
}
pub fn explain_giguna__west_caverns__ctx__east_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_east_susar
    {
        let r = ctx.giguna__west_caverns__ctx__east_susar();
        edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
        (r, vec!["^giguna__west_caverns__ctx__east_susar"])
    }
}
pub fn explain_giguna_boulder(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Boulder
    {
        let h = ctx.has(Item::Giguna_Boulder);
        edict.insert("Giguna_Boulder", format!("{}", h));
        (h, vec!["Giguna_Boulder"])
    }
}
pub fn explain_giguna_breach__sw_save__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door_opened
    {
        let r = ctx.giguna_breach__sw_save__ctx__door_opened();
        edict.insert(
            "^giguna_breach__sw_save__ctx__door_opened",
            format!("{:?}", r),
        );
        (r, vec!["^giguna_breach__sw_save__ctx__door_opened"])
    }
}
pub fn explain_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Breach_Crab_Rave_Gate
    {
        let h = ctx.has(Item::Giguna_Breach_Crab_Rave_Gate);
        edict.insert("Giguna_Breach_Crab_Rave_Gate", format!("{}", h));
        (h, vec!["Giguna_Breach_Crab_Rave_Gate"])
    }
}
pub fn explain_giguna_breach_gate_and_wall_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Breach_Gate_and_Wall_Gate
    {
        let h = ctx.has(Item::Giguna_Breach_Gate_and_Wall_Gate);
        edict.insert("Giguna_Breach_Gate_and_Wall_Gate", format!("{}", h));
        (h, vec!["Giguna_Breach_Gate_and_Wall_Gate"])
    }
}
pub fn explain_giguna_breach_lower_machinery_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Breach_Lower_Machinery_Gate
    {
        let h = ctx.has(Item::Giguna_Breach_Lower_Machinery_Gate);
        edict.insert("Giguna_Breach_Lower_Machinery_Gate", format!("{}", h));
        (h, vec!["Giguna_Breach_Lower_Machinery_Gate"])
    }
}
pub fn explain_giguna_breach_pinkness_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Breach_Pinkness_Rock
    {
        let h = ctx.has(Item::Giguna_Breach_Pinkness_Rock);
        edict.insert("Giguna_Breach_Pinkness_Rock", format!("{}", h));
        (h, vec!["Giguna_Breach_Pinkness_Rock"])
    }
}
pub fn explain_giguna_dual_path_switch(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch
    {
        let h = ctx.has(Item::Giguna_Dual_Path_Switch);
        edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
        (h, vec!["Giguna_Dual_Path_Switch"])
    }
}
pub fn explain_giguna_dual_path_switch_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch and ($grab or $climb)
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Dual_Path_Switch);
            edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
            (h, vec!["Giguna_Dual_Path_Switch"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_dual_path_switch_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch and $climb
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Dual_Path_Switch);
            edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
            (h, vec!["Giguna_Dual_Path_Switch"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_dual_path_switch_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Dual_Path_Switch and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Dual_Path_Switch);
            edict.insert("Giguna_Dual_Path_Switch", format!("{}", h));
            (h, vec!["Giguna_Dual_Path_Switch"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_gateway_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gateway_Block
    {
        let h = ctx.has(Item::Giguna_Gateway_Block);
        edict.insert("Giguna_Gateway_Block", format!("{}", h));
        (h, vec!["Giguna_Gateway_Block"])
    }
}
pub fn explain_giguna_gateway_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gateway_Gate
    {
        let h = ctx.has(Item::Giguna_Gateway_Gate);
        edict.insert("Giguna_Gateway_Gate", format!("{}", h));
        (h, vec!["Giguna_Gateway_Gate"])
    }
}
pub fn explain_giguna_gubi_and_invoke_boomerang(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gubi and $boomerang
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Gubi);
            edict.insert("Giguna_Gubi", format!("{}", h));
            (h, vec!["Giguna_Gubi"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__boomerang!(ctx, world, edict);
                edict.insert("$boomerang", format!("{:?}", res));
                refs.push("$boomerang");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_gubi_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Gubi and $hover
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Gubi);
            edict.insert("Giguna_Gubi", format!("{}", h));
            (h, vec!["Giguna_Gubi"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_labyrinth_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Labyrinth_Gate
    {
        let h = ctx.has(Item::Giguna_Labyrinth_Gate);
        edict.insert("Giguna_Labyrinth_Gate", format!("{}", h));
        (h, vec!["Giguna_Labyrinth_Gate"])
    }
}
pub fn explain_giguna_northeast_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Northeast_Gate
    {
        let h = ctx.has(Item::Giguna_Northeast_Gate);
        edict.insert("Giguna_Northeast_Gate", format!("{}", h));
        (h, vec!["Giguna_Northeast_Gate"])
    }
}
pub fn explain_giguna_separator_bricks(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Separator_Bricks
    {
        let h = ctx.has(Item::Giguna_Separator_Bricks);
        edict.insert("Giguna_Separator_Bricks", format!("{}", h));
        (h, vec!["Giguna_Separator_Bricks"])
    }
}
pub fn explain_giguna_separator_bricks_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Separator_Bricks and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Separator_Bricks);
            edict.insert("Giguna_Separator_Bricks", format!("{}", h));
            (h, vec!["Giguna_Separator_Bricks"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_vertical_interchange_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Vertical_Interchange_Gate
    {
        let h = ctx.has(Item::Giguna_Vertical_Interchange_Gate);
        edict.insert("Giguna_Vertical_Interchange_Gate", format!("{}", h));
        (h, vec!["Giguna_Vertical_Interchange_Gate"])
    }
}
pub fn explain_giguna_vertical_interchange_gate_and___invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Vertical_Interchange_Gate and ($hook or Anuman)
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Vertical_Interchange_Gate);
            edict.insert("Giguna_Vertical_Interchange_Gate", format!("{}", h));
            (h, vec!["Giguna_Vertical_Interchange_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Anuman);
                        edict.insert("Anuman", format!("{}", h));
                        (h, vec!["Anuman"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_vertical_interchange_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Vertical_Interchange_Rock
    {
        let h = ctx.has(Item::Giguna_Vertical_Interchange_Rock);
        edict.insert("Giguna_Vertical_Interchange_Rock", format!("{}", h));
        (h, vec!["Giguna_Vertical_Interchange_Rock"])
    }
}
pub fn explain_giguna_vertical_interchange_rock_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Vertical_Interchange_Rock and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Vertical_Interchange_Rock);
            edict.insert("Giguna_Vertical_Interchange_Rock", format!("{}", h));
            (h, vec!["Giguna_Vertical_Interchange_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_vertical_interchange_rock_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Vertical_Interchange_Rock and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Vertical_Interchange_Rock);
            edict.insert("Giguna_Vertical_Interchange_Rock", format!("{}", h));
            (h, vec!["Giguna_Vertical_Interchange_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_vertical_interchange_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Vertical_Interchange_Rock and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Giguna_Vertical_Interchange_Rock);
            edict.insert("Giguna_Vertical_Interchange_Rock", format!("{}", h));
            (h, vec!["Giguna_Vertical_Interchange_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_giguna_wasteland_door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Giguna_Wasteland_Door
    {
        let h = ctx.has(Item::Giguna_Wasteland_Door);
        edict.insert("Giguna_Wasteland_Door", format!("{}", h));
        (h, vec!["Giguna_Wasteland_Door"])
    }
}
pub fn explain_glacier__ctx__hammonds_doors(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_hammonds_doors
    {
        let r = ctx.glacier__ctx__hammonds_doors();
        edict.insert("^glacier__ctx__hammonds_doors", format!("{:?}", r));
        (r, vec!["^glacier__ctx__hammonds_doors"])
    }
}
pub fn explain_glacier__ctx__hammonds_doors_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_hammonds_doors and $hook
    {
        let mut left = {
            let r = ctx.glacier__ctx__hammonds_doors();
            edict.insert("^glacier__ctx__hammonds_doors", format!("{:?}", r));
            (r, vec!["^glacier__ctx__hammonds_doors"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier__ctx__hammonds_doors_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_hammonds_doors and $hookhover
    {
        let mut left = {
            let r = ctx.glacier__ctx__hammonds_doors();
            edict.insert("^glacier__ctx__hammonds_doors", format!("{:?}", r));
            (r, vec!["^glacier__ctx__hammonds_doors"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier__lonely_bull__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_door
    {
        let r = ctx.glacier__lonely_bull__ctx__door();
        edict.insert("^glacier__lonely_bull__ctx__door", format!("{:?}", r));
        (r, vec!["^glacier__lonely_bull__ctx__door"])
    }
}
pub fn explain_glacier__the_big_drop__ctx__bridge_open_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_bridge_open and Nanite_Mist
    {
        let mut left = {
            let r = ctx.glacier__the_big_drop__ctx__bridge_open();
            edict.insert(
                "^glacier__the_big_drop__ctx__bridge_open",
                format!("{:?}", r),
            );
            (r, vec!["^glacier__the_big_drop__ctx__bridge_open"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_gatestones
    {
        let r = ctx.glacier__vertical_room__ctx__lower_gatestones();
        edict.insert(
            "^glacier__vertical_room__ctx__lower_gatestones",
            format!("{:?}", r),
        );
        (r, vec!["^glacier__vertical_room__ctx__lower_gatestones"])
    }
}
pub fn explain_glacier__vertical_room__ctx__lower_gatestones_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_lower_gatestones and Underwater_Movement
    {
        let mut left = {
            let r = ctx.glacier__vertical_room__ctx__lower_gatestones();
            edict.insert(
                "^glacier__vertical_room__ctx__lower_gatestones",
                format!("{:?}", r),
            );
            (r, vec!["^glacier__vertical_room__ctx__lower_gatestones"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier__vertical_room__ctx__upper_gatestone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_upper_gatestone
    {
        let r = ctx.glacier__vertical_room__ctx__upper_gatestone();
        edict.insert(
            "^glacier__vertical_room__ctx__upper_gatestone",
            format!("{:?}", r),
        );
        (r, vec!["^glacier__vertical_room__ctx__upper_gatestone"])
    }
}
pub fn explain_glacier_big_drop_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Big_Drop_Rock
    {
        let h = ctx.has(Item::Glacier_Big_Drop_Rock);
        edict.insert("Glacier_Big_Drop_Rock", format!("{}", h));
        (h, vec!["Glacier_Big_Drop_Rock"])
    }
}
pub fn explain_glacier_breach_spidery_connector_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Breach_Spidery_Connector_Gate
    {
        let h = ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate);
        edict.insert("Glacier_Breach_Spidery_Connector_Gate", format!("{}", h));
        (h, vec!["Glacier_Breach_Spidery_Connector_Gate"])
    }
}
pub fn explain_glacier_breach_spidery_connector_gate_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Breach_Spidery_Connector_Gate and Drone_Hover
    {
        let mut left = {
            let h = ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate);
            edict.insert("Glacier_Breach_Spidery_Connector_Gate", format!("{}", h));
            (h, vec!["Glacier_Breach_Spidery_Connector_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier_breach_spidery_connector_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Breach_Spidery_Connector_Gate and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate);
                edict.insert("Glacier_Breach_Spidery_Connector_Gate", format!("{}", h));
                (h, vec!["Glacier_Breach_Spidery_Connector_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier_fortress_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Fortress_Gate
    {
        let h = ctx.has(Item::Glacier_Fortress_Gate);
        edict.insert("Glacier_Fortress_Gate", format!("{}", h));
        (h, vec!["Glacier_Fortress_Gate"])
    }
}
pub fn explain_glacier_fortress_gate_and___invoke_grab_or_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Fortress_Gate and ($grab or $hover)
    {
        let mut left = {
            let h = ctx.has(Item::Glacier_Fortress_Gate);
            edict.insert("Glacier_Fortress_Gate", format!("{}", h));
            (h, vec!["Glacier_Fortress_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                        edict.insert("$hover", format!("{:?}", res));
                        refs.push("$hover");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier_fortress_gate_and___invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Fortress_Gate and ($hook or Anuman)
    {
        let mut left = {
            let h = ctx.has(Item::Glacier_Fortress_Gate);
            edict.insert("Glacier_Fortress_Gate", format!("{}", h));
            (h, vec!["Glacier_Fortress_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Anuman);
                        edict.insert("Anuman", format!("{}", h));
                        (h, vec!["Anuman"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier_gudam(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Gudam
    {
        let h = ctx.has(Item::Glacier_Gudam);
        edict.insert("Glacier_Gudam", format!("{}", h));
        (h, vec!["Glacier_Gudam"])
    }
}
pub fn explain_glacier_gudam_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Gudam and $shockwave
    {
        let mut left = {
            let h = ctx.has(Item::Glacier_Gudam);
            edict.insert("Glacier_Gudam", format!("{}", h));
            (h, vec!["Glacier_Gudam"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_glacier_sea_burial_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Glacier_Sea_Burial_Rock
    {
        let h = ctx.has(Item::Glacier_Sea_Burial_Rock);
        edict.insert("Glacier_Sea_Burial_Rock", format!("{}", h));
        (h, vec!["Glacier_Sea_Burial_Rock"])
    }
}
pub fn explain_hammond_auth(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Hammond_Auth
    {
        let h = ctx.has(Item::Hammond_Auth);
        edict.insert("Hammond_Auth", format!("{}", h));
        (h, vec!["Hammond_Auth"])
    }
}
pub fn explain_health_upgrade(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade
    {
        let h = ctx.has(Item::Health_Upgrade);
        edict.insert("Health_Upgrade", format!("{}", h));
        (h, vec!["Health_Upgrade"])
    }
}
pub fn explain_health_upgrade_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade_2
    {
        let h = ctx.has(Item::Health_Upgrade_2);
        edict.insert("Health_Upgrade_2", format!("{}", h));
        (h, vec!["Health_Upgrade_2"])
    }
}
pub fn explain_health_upgrade_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade_3
    {
        let h = ctx.has(Item::Health_Upgrade_3);
        edict.insert("Health_Upgrade_3", format!("{}", h));
        (h, vec!["Health_Upgrade_3"])
    }
}
pub fn explain_health_upgrade_4(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Health_Upgrade_4
    {
        let h = ctx.has(Item::Health_Upgrade_4);
        edict.insert("Health_Upgrade_4", format!("{}", h));
        (h, vec!["Health_Upgrade_4"])
    }
}
pub fn explain_if___mode_eq_drone____drone_melee_damage_3_and_drone_hover__else____invoke_weapon_and_melee_damage_3_and___boomerang_or_boomerang_upgrade_(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // IF (^mode == 'drone') { Drone_Melee_Damage_3 and Drone_Hover } ELSE { $weapon and Melee_Damage_3 and (Boomerang or Boomerang_Upgrade) }
    {
        let mut refs = Vec::new();
        let mut cond = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        refs.append(&mut cond.1);
        if cond.0 {
            let mut then = {
                let mut left = {
                    let h = ctx.has(Item::Drone_Melee_Damage_3);
                    edict.insert("Drone_Melee_Damage_3", format!("{}", h));
                    (h, vec!["Drone_Melee_Damage_3"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Drone_Hover);
                        edict.insert("Drone_Hover", format!("{}", h));
                        (h, vec!["Drone_Hover"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            refs.append(&mut then.1);
            (then.0, refs)
        } else {
            let mut then = {
                let mut left = {
                    let h = ctx.has(Item::Drone_Melee_Damage_3);
                    edict.insert("Drone_Melee_Damage_3", format!("{}", h));
                    (h, vec!["Drone_Melee_Damage_3"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Drone_Hover);
                        edict.insert("Drone_Hover", format!("{}", h));
                        (h, vec!["Drone_Hover"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            refs.append(&mut then.1);
            (then.0, refs)
        }
    }
}
pub fn explain_infect(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect
    {
        let h = ctx.has(Item::Infect);
        edict.insert("Infect", format!("{}", h));
        (h, vec!["Infect"])
    }
}
pub fn explain_infect_and_anuman_and_invoke_objective(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and Anuman and $objective
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = rexplain__objective!(ctx, world, edict);
                edict.insert("$objective", format!("{:?}", res));
                refs.push("$objective");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and ^_platform_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__drone_room__ctx__platform_moved();
                edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                (r, vec!["^ebih__drone_room__ctx__platform_moved"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_ebih__ebih_east__ctx__platform2_moved_and___invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and ^_platform2_moved and ($grab or $hook)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                        edict.insert("$hook", format!("{:?}", res));
                        refs.push("$hook");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_invoke_grab_and_not_ebih__ebih_east__ctx__platform1_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and $grab and not ^_platform1_moved
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform1_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform1_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform1_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_invoke_grab_and_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and $grab and not ^_platform2_moved
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_not_anuman_and_invoke_objective(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not Anuman and $objective
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (!h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = rexplain__objective!(ctx, world, edict);
                edict.insert("$objective", format!("{:?}", res));
                refs.push("$objective");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_not_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not ^_platform_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__drone_room__ctx__platform_moved();
                    edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                    (r, vec!["^ebih__drone_room__ctx__platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_and_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect and not ^_platform2_moved
    {
        let mut left = {
            let h = ctx.has(Item::Infect);
            edict.insert("Infect", format!("{}", h));
            (h, vec!["Infect"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__ebih_east__ctx__platform2_moved();
                    edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
                    (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_infect_l1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect_L1
    {
        let h = ctx.has(Item::Infect_L1);
        edict.insert("Infect_L1", format!("{}", h));
        (h, vec!["Infect_L1"])
    }
}
pub fn explain_infect_l2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infect_L2
    {
        let h = ctx.has(Item::Infect_L2);
        edict.insert("Infect_L2", format!("{}", h));
        (h, vec!["Infect_L2"])
    }
}
pub fn explain_infection_range(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infection_Range
    {
        let h = ctx.has(Item::Infection_Range);
        edict.insert("Infection_Range", format!("{}", h));
        (h, vec!["Infection_Range"])
    }
}
pub fn explain_infection_range_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infection_Range_2
    {
        let h = ctx.has(Item::Infection_Range_2);
        edict.insert("Infection_Range_2", format!("{}", h));
        (h, vec!["Infection_Range_2"])
    }
}
pub fn explain_infection_speed(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Infection_Speed
    {
        let h = ctx.has(Item::Infection_Speed);
        edict.insert("Infection_Speed", format!("{}", h));
        (h, vec!["Infection_Speed"])
    }
}
pub fn explain_invoke_activate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $activate
    {
        let (res, mut refs) = hexplain__activate!(ctx, world, edict);
        edict.insert("$activate", format!("{:?}", res));
        refs.push("$activate");
        (res, refs)
    }
}
pub fn explain_invoke_activate_and_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $activate and ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
            edict.insert("$activate", format!("{:?}", res));
            refs.push("$activate");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                edict.insert(
                    "^ebih__base_camp__ctx__left_platform_moved",
                    format!("{:?}", r),
                );
                (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_activate_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $activate and not ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
            edict.insert("$activate", format!("{:?}", res));
            refs.push("$activate");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_allegiance4(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $allegiance4
    {
        let (res, mut refs) = hexplain__allegiance4!(ctx, world, edict);
        edict.insert("$allegiance4", format!("{:?}", res));
        refs.push("$allegiance4");
        (res, refs)
    }
}
pub fn explain_invoke_block_clip_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip and not Ebih_Waterfall_Block_Left
    {
        let mut left = {
            let (res, mut refs) = hexplain__block_clip!(ctx, world, edict);
            edict.insert("$block_clip", format!("{:?}", res));
            refs.push("$block_clip");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Left);
                edict.insert("Ebih_Waterfall_Block_Left", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Left"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_block_clip_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip and not Ebih_Waterfall_Block_Right
    {
        let mut left = {
            let (res, mut refs) = hexplain__block_clip!(ctx, world, edict);
            edict.insert("$block_clip", format!("{:?}", res));
            refs.push("$block_clip");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Right);
                edict.insert("Ebih_Waterfall_Block_Right", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Right"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_block_clip_and_slingshot_hook_and_not_uhrum_east_lake_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip and Slingshot_Hook and not Uhrum_East_Lake_Block
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__block_clip!(ctx, world, edict);
                edict.insert("$block_clip", format!("{:?}", res));
                refs.push("$block_clip");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Uhrum_East_Lake_Block);
                edict.insert("Uhrum_East_Lake_Block", format!("{}", h));
                (!h, vec!["Uhrum_East_Lake_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_block_clip_escape_and_not_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $block_clip_escape and not Uhrum_Annuna_Corridor_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__block_clip_escape!(ctx, world, edict);
            edict.insert("$block_clip_escape", format!("{:?}", res));
            refs.push("$block_clip_escape");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Uhrum_Annuna_Corridor_Block);
                edict.insert("Uhrum_Annuna_Corridor_Block", format!("{}", h));
                (!h, vec!["Uhrum_Annuna_Corridor_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_bomberang_and_anuman_and_not_invoke_visited__glacier_gt_fortress_gt_inner_center_gt_shockwave_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $bomberang and Anuman and not $visited(`Glacier > Fortress > Inner Center > Shockwave Block`)
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__bomberang!(ctx, world, edict);
                edict.insert("$bomberang", format!("{:?}", res));
                refs.push("$bomberang");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let res = ctx.visited(LocationId::Glacier__Fortress__Inner_Center__Shockwave_Block);
                edict.insert(
                    "not$visited(`Glacier > Fortress > Inner Center > Shockwave Block`)",
                    format!("{:?}", res),
                );
                (
                    !res,
                    vec!["not$visited(`Glacier > Fortress > Inner Center > Shockwave Block`)"],
                )
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_boomerang(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $boomerang
    {
        let (res, mut refs) = hexplain__boomerang!(ctx, world, edict);
        edict.insert("$boomerang", format!("{:?}", res));
        refs.push("$boomerang");
        (res, refs)
    }
}
pub fn explain_invoke_boomerang2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $boomerang2
    {
        let (res, mut refs) = hexplain__boomerang2!(ctx, world, edict);
        edict.insert("$boomerang2", format!("{:?}", res));
        refs.push("$boomerang2");
        (res, refs)
    }
}
pub fn explain_invoke_boomerang2_and_ranged_damage_3_and_invoke_weapon_and_melee_damage_3_and_melee_speed_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $boomerang2 and Ranged_Damage_3 and $weapon and Melee_Damage_3 and Melee_Speed_3
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let (res, mut refs) = hexplain__boomerang2!(ctx, world, edict);
                        edict.insert("$boomerang2", format!("{:?}", res));
                        refs.push("$boomerang2");
                        (res, refs)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = ctx.has(Item::Ranged_Damage_3);
                            edict.insert("Ranged_Damage_3", format!("{}", h));
                            (h, vec!["Ranged_Damage_3"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__weapon!(ctx, world, edict);
                        edict.insert("$weapon", format!("{:?}", res));
                        refs.push("$weapon");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Melee_Damage_3);
                    edict.insert("Melee_Damage_3", format!("{}", h));
                    (h, vec!["Melee_Damage_3"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Melee_Speed_3);
                edict.insert("Melee_Speed_3", format!("{}", h));
                (h, vec!["Melee_Speed_3"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_boomerang_and_fast_travel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $boomerang and Fast_Travel
    {
        let mut left = {
            let (res, mut refs) = hexplain__boomerang!(ctx, world, edict);
            edict.insert("$boomerang", format!("{:?}", res));
            refs.push("$boomerang");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Fast_Travel);
                edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_bs(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $bs
    {
        let (res, mut refs) = hexplain__bs!(ctx, world, edict);
        edict.insert("$bs", format!("{:?}", res));
        refs.push("$bs");
        (res, refs)
    }
}
pub fn explain_invoke_can_damage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_damage
    {
        let (res, mut refs) = hexplain__can_damage!(ctx, world, edict);
        edict.insert("$can_damage", format!("{:?}", res));
        refs.push("$can_damage");
        (res, refs)
    }
}
pub fn explain_invoke_can_deploy(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy
    {
        let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
        edict.insert("$can_deploy", format!("{:?}", res));
        refs.push("$can_deploy");
        (res, refs)
    }
}
pub fn explain_invoke_can_deploy_and___drone_hover_or_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and (Drone_Hover or Slingshot_Hook)
    {
        let mut left = {
            let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
            edict.insert("$can_deploy", format!("{:?}", res));
            refs.push("$can_deploy");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Slingshot_Hook);
                        edict.insert("Slingshot_Hook", format!("{}", h));
                        (h, vec!["Slingshot_Hook"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_can_deploy_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Drone_Hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
            edict.insert("$can_deploy", format!("{:?}", res));
            refs.push("$can_deploy");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_can_deploy_and_drone_hover_and_ebih_walled_off_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Drone_Hover and Ebih_Walled_Off_Wall
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Walled_Off_Wall);
                edict.insert("Ebih_Walled_Off_Wall", format!("{}", h));
                (h, vec!["Ebih_Walled_Off_Wall"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_can_deploy_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Drone_Hover and Slingshot_Hook
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_can_deploy_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Slingshot_Hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
            edict.insert("$can_deploy", format!("{:?}", res));
            refs.push("$can_deploy");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_can_deploy_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $can_deploy and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_charge(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $charge
    {
        let (res, mut refs) = hexplain__charge!(ctx, world, edict);
        edict.insert("$charge", format!("{:?}", res));
        refs.push("$charge");
        (res, refs)
    }
}
pub fn explain_invoke_chargehover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $chargehover
    {
        let (res, mut refs) = hexplain__chargehover!(ctx, world, edict);
        edict.insert("$chargehover", format!("{:?}", res));
        refs.push("$chargehover");
        (res, refs)
    }
}
pub fn explain_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb
    {
        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
        edict.insert("$climb", format!("{:?}", res));
        refs.push("$climb");
        (res, refs)
    }
}
pub fn explain_invoke_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_climb_and_invoke_can_deploy_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and $can_deploy and Drone_Hover and Slingshot_Hook
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                    edict.insert("$climb", format!("{:?}", res));
                    refs.push("$climb");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                        edict.insert("$can_deploy", format!("{:?}", res));
                        refs.push("$can_deploy");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_climb_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and $grab
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_climb_and_invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and $grab and Anuman
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_climb_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb and Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_climb_or___invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb or ($grab and Anuman)
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Anuman);
                        edict.insert("Anuman", format!("{}", h));
                        (h, vec!["Anuman"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_climb_or_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $climb or $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__climb!(ctx, world, edict);
            edict.insert("$climb", format!("{:?}", res));
            refs.push("$climb");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab
    {
        let (res, mut refs) = hexplain__grab!(ctx, world, edict);
        edict.insert("$grab", format!("{:?}", res));
        refs.push("$grab");
        (res, refs)
    }
}
pub fn explain_invoke_grab_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__ebih_west__ctx__door_open();
                edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__ebih_west__ctx__door_open"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_ebih_hidden_portal_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Ebih_Hidden_Portal_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Hidden_Portal_Gate);
                edict.insert("Ebih_Hidden_Portal_Gate", format!("{}", h));
                (h, vec!["Ebih_Hidden_Portal_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and ^_mid_susar
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__mid_susar();
                edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
                (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_giguna__ruins_west__ctx__kishib_handled(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and ^_kishib_handled
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__ruins_west__ctx__kishib_handled();
                edict.insert(
                    "^giguna__ruins_west__ctx__kishib_handled",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__ruins_west__ctx__kishib_handled"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_giguna_gateway_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Giguna_Gateway_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Gateway_Block);
                edict.insert("Giguna_Gateway_Block", format!("{}", h));
                (h, vec!["Giguna_Gateway_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_invoke_can_deploy(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and $can_deploy
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and $climb
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_switch_40_12(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Switch_40_12
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Switch_40_12);
                edict.insert("Switch_40_12", format!("{}", h));
                (h, vec!["Switch_40_12"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab and Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_or_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $climb
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_or_invoke_climb_or_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $climb or $hook
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            if left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                    edict.insert("$climb", format!("{:?}", res));
                    refs.push("$climb");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_or_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or $hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_grab_or_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $grab or Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
            edict.insert("$grab", format!("{:?}", res));
            refs.push("$grab");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook
    {
        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
        edict.insert("$hook", format!("{:?}", res));
        refs.push("$hook");
        (res, refs)
    }
}
pub fn explain_invoke_hook_and_annuna__vertical_room__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.annuna__vertical_room__ctx__door_opened();
                edict.insert(
                    "^annuna__vertical_room__ctx__door_opened",
                    format!("{:?}", r),
                );
                (r, vec!["^annuna__vertical_room__ctx__door_opened"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.ebih__ebih_west__ctx__door_open();
                edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__ebih_west__ctx__door_open"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_ebih_hidden_portal_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Ebih_Hidden_Portal_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Hidden_Portal_Gate);
                edict.insert("Ebih_Hidden_Portal_Gate", format!("{}", h));
                (h, vec!["Ebih_Hidden_Portal_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_emergence_rocks_fall_rock_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Emergence_Rocks_Fall_Rock_2
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_2);
                edict.insert("Emergence_Rocks_Fall_Rock_2", format!("{}", h));
                (h, vec!["Emergence_Rocks_Fall_Rock_2"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_emergence_rocks_fall_rock_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Emergence_Rocks_Fall_Rock_3
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_3);
                edict.insert("Emergence_Rocks_Fall_Rock_3", format!("{}", h));
                (h, vec!["Emergence_Rocks_Fall_Rock_3"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Emergence_Rocks_Fall_Rock_4
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_4);
                edict.insert("Emergence_Rocks_Fall_Rock_4", format!("{}", h));
                (h, vec!["Emergence_Rocks_Fall_Rock_4"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_combo_entered
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and ^_mid_susar
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__mid_susar();
                edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
                (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_giguna_gateway_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Giguna_Gateway_Block
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Gateway_Block);
                edict.insert("Giguna_Gateway_Block", format!("{}", h));
                (h, vec!["Giguna_Gateway_Block"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover_and_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and Emergence_Rocks_Fall_Rock_4
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Emergence_Rocks_Fall_Rock_4);
                edict.insert("Emergence_Rocks_Fall_Rock_4", format!("{}", h));
                (h, vec!["Emergence_Rocks_Fall_Rock_4"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover_and_glacier__vertical_room__ctx__upper_gatestone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and ^_upper_gatestone
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.glacier__vertical_room__ctx__upper_gatestone();
                edict.insert(
                    "^glacier__vertical_room__ctx__upper_gatestone",
                    format!("{:?}", r),
                );
                (r, vec!["^glacier__vertical_room__ctx__upper_gatestone"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover_and_slingshot_charge(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and Slingshot_Charge
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Charge);
                edict.insert("Slingshot_Charge", format!("{}", h));
                (h, vec!["Slingshot_Charge"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and Slingshot_Weapon
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Weapon);
                edict.insert("Slingshot_Weapon", format!("{}", h));
                (h, vec!["Slingshot_Weapon"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and Underwater_Movement
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_invoke_hover_and_underwater_movement_and_breach_attractor_and_anuman_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and $hover and Underwater_Movement and Breach_Attractor and Anuman and ^portal == ^portal_start
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let mut left = {
                            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                            edict.insert("$hook", format!("{:?}", res));
                            refs.push("$hook");
                            (res, refs)
                        };
                        if !left.0 {
                            left
                        } else {
                            let mut right = {
                                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                                edict.insert("$hover", format!("{:?}", res));
                                refs.push("$hover");
                                (res, refs)
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = ctx.has(Item::Underwater_Movement);
                            edict.insert("Underwater_Movement", format!("{}", h));
                            (h, vec!["Underwater_Movement"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Breach_Attractor);
                        edict.insert("Breach_Attractor", format!("{}", h));
                        (h, vec!["Breach_Attractor"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut left = {
                    let r = ctx.portal();
                    edict.insert("^portal", format!("{:?}", r));
                    (r, vec!["^portal"])
                };
                let mut right = {
                    let r = data::portal_start(ctx.position());
                    edict.insert("^portal_start", format!("{:?}", r));
                    (r, vec!["^portal_start"])
                };
                left.1.append(&mut right.1);
                (left.0 == right.0, left.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_not_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not ^_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__drone_room__ctx__platform_moved();
                    edict.insert("^ebih__drone_room__ctx__platform_moved", format!("{:?}", r));
                    (r, vec!["^ebih__drone_room__ctx__platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not Ebih_Waterfall_Block_Left
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Left);
                edict.insert("Ebih_Waterfall_Block_Left", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Left"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and not Ebih_Waterfall_Block_Right
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Right);
                edict.insert("Ebih_Waterfall_Block_Right", format!("{}", h));
                (!h, vec!["Ebih_Waterfall_Block_Right"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook and Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_or___anuman_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or (Anuman and ($grab or $climb))
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = ({
                        let mut left = {
                            let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                            edict.insert("$grab", format!("{:?}", res));
                            refs.push("$grab");
                            (res, refs)
                        };
                        if left.0 {
                            left
                        } else {
                            let mut right = {
                                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                                edict.insert("$climb", format!("{:?}", res));
                                refs.push("$climb");
                                (res, refs)
                            };
                            left.1.append(&mut right.1);
                            (right.0, left.1)
                        }
                    });
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_or___anuman_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or (Anuman and $climb)
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_or___anuman_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or (Anuman and $grab)
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                        edict.insert("$grab", format!("{:?}", res));
                        refs.push("$grab");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_or___invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or ($grab and Anuman)
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Anuman);
                        edict.insert("Anuman", format!("{}", h));
                        (h, vec!["Anuman"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hook_or_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hook or $hover
    {
        let mut left = {
            let (res, mut refs) = hexplain__hook!(ctx, world, edict);
            edict.insert("$hook", format!("{:?}", res));
            refs.push("$hook");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover
    {
        let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
        edict.insert("$hookhover", format!("{:?}", res));
        refs.push("$hookhover");
        (res, refs)
    }
}
pub fn explain_invoke_hookhover_and_amagi_gated_community_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover and Amagi_Gated_Community_Gate and Underwater_Movement
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Amagi_Gated_Community_Gate);
                    edict.insert("Amagi_Gated_Community_Gate", format!("{}", h));
                    (h, vec!["Amagi_Gated_Community_Gate"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover_and_amagi_gated_community_gate_and_underwater_movement_and_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover and Amagi_Gated_Community_Gate and Underwater_Movement and ^_dur_esla
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                    edict.insert("$hookhover", format!("{:?}", res));
                    refs.push("$hookhover");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Amagi_Gated_Community_Gate);
                        edict.insert("Amagi_Gated_Community_Gate", format!("{}", h));
                        (h, vec!["Amagi_Gated_Community_Gate"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.amagi__gated_community__ctx__dur_esla();
                edict.insert("^amagi__gated_community__ctx__dur_esla", format!("{:?}", r));
                (r, vec!["^amagi__gated_community__ctx__dur_esla"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
            edict.insert("$hookhover", format!("{:?}", res));
            refs.push("$hookhover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover_and_giguna__gateway__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover and ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
            edict.insert("$hookhover", format!("{:?}", res));
            refs.push("$hookhover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__gateway__ctx__door_opened();
                edict.insert("^giguna__gateway__ctx__door_opened", format!("{:?}", r));
                (r, vec!["^giguna__gateway__ctx__door_opened"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover and Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
            edict.insert("$hookhover", format!("{:?}", res));
            refs.push("$hookhover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover_and_underwater_movement_and_amagi_gated_community_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover and Underwater_Movement and Amagi_Gated_Community_Gate
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Amagi_Gated_Community_Gate);
                edict.insert("Amagi_Gated_Community_Gate", format!("{}", h));
                (h, vec!["Amagi_Gated_Community_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hookhover_or_invoke_spin(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hookhover or $spin
    {
        let mut left = {
            let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
            edict.insert("$hookhover", format!("{:?}", res));
            refs.push("$hookhover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__spin!(ctx, world, edict);
                edict.insert("$spin", format!("{:?}", res));
                refs.push("$spin");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover
    {
        let (res, mut refs) = hexplain__hover!(ctx, world, edict);
        edict.insert("$hover", format!("{:?}", res));
        refs.push("$hover");
        (res, refs)
    }
}
pub fn explain_invoke_hover_and_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_anuman_and_underwater_movement_and___boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Anuman and Underwater_Movement and (Boomerang or Boomerang_Upgrade)
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                    edict.insert("$hover", format!("{:?}", res));
                    refs.push("$hover");
                    (res, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Anuman);
                        edict.insert("Anuman", format!("{}", h));
                        (h, vec!["Anuman"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Boomerang);
                    edict.insert("Boomerang", format!("{}", h));
                    (h, vec!["Boomerang"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Boomerang_Upgrade);
                        edict.insert("Boomerang_Upgrade", format!("{}", h));
                        (h, vec!["Boomerang_Upgrade"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_anuman_and_wall_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Anuman and Wall_Climb
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Wall_Climb);
                edict.insert("Wall_Climb", format!("{}", h));
                (h, vec!["Wall_Climb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_invoke_hook_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_invoke_hook_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook and Nanite_Mist
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_invoke_hook_and_not_irikar__midwest__ctx__left_platform(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and $hook and not ^_left_platform
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.irikar__midwest__ctx__left_platform();
                    edict.insert("^irikar__midwest__ctx__left_platform", format!("{:?}", r));
                    (r, vec!["^irikar__midwest__ctx__left_platform"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Nanite_Mist
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and not ^_left_platform_moved
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Underwater_Movement
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_and_underwater_movement_and_breach_attractor_and_anuman_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover and Underwater_Movement and Breach_Attractor and Anuman and ^portal == ^portal_start
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                        edict.insert("$hover", format!("{:?}", res));
                        refs.push("$hover");
                        (res, refs)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = ctx.has(Item::Underwater_Movement);
                            edict.insert("Underwater_Movement", format!("{}", h));
                            (h, vec!["Underwater_Movement"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Breach_Attractor);
                        edict.insert("Breach_Attractor", format!("{}", h));
                        (h, vec!["Breach_Attractor"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut left = {
                    let r = ctx.portal();
                    edict.insert("^portal", format!("{:?}", r));
                    (r, vec!["^portal"])
                };
                let mut right = {
                    let r = data::portal_start(ctx.position());
                    edict.insert("^portal_start", format!("{:?}", r));
                    (r, vec!["^portal_start"])
                };
                left.1.append(&mut right.1);
                (left.0 == right.0, left.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_or_anuman(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover or Anuman
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Anuman);
                edict.insert("Anuman", format!("{}", h));
                (h, vec!["Anuman"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_or_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover or $grab
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_or_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover or $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_hover_or_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $hover or Nanite_Mist
    {
        let mut left = {
            let (res, mut refs) = hexplain__hover!(ctx, world, edict);
            edict.insert("$hover", format!("{:?}", res));
            refs.push("$hover");
            (res, refs)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_infinite_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb
    {
        let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
        edict.insert("$infinite_climb", format!("{:?}", res));
        refs.push("$infinite_climb");
        (res, refs)
    }
}
pub fn explain_invoke_infinite_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
            edict.insert("$infinite_climb", format!("{:?}", res));
            refs.push("$infinite_climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_infinite_climb_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and not Annuna_East_Bridge_Gate
    {
        let mut left = {
            let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
            edict.insert("$infinite_climb", format!("{:?}", res));
            refs.push("$infinite_climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (!h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_infinite_climb_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and Slingshot_Hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
            edict.insert("$infinite_climb", format!("{:?}", res));
            refs.push("$infinite_climb");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_infinite_climb_and_slingshot_hook_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $infinite_climb and Slingshot_Hook and not Annuna_East_Bridge_Gate
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
                edict.insert("$infinite_climb", format!("{:?}", res));
                refs.push("$infinite_climb");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Annuna_East_Bridge_Gate);
                edict.insert("Annuna_East_Bridge_Gate", format!("{}", h));
                (!h, vec!["Annuna_East_Bridge_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_melee(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $melee
    {
        let (res, mut refs) = hexplain__melee!(ctx, world, edict);
        edict.insert("$melee", format!("{:?}", res));
        refs.push("$melee");
        (res, refs)
    }
}
pub fn explain_invoke_melee_and_not_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $melee and not ^_dur_esla
    {
        let mut left = {
            let (res, mut refs) = hexplain__melee!(ctx, world, edict);
            edict.insert("$melee", format!("{:?}", res));
            refs.push("$melee");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.amagi__gated_community__ctx__dur_esla();
                    edict.insert("^amagi__gated_community__ctx__dur_esla", format!("{:?}", r));
                    (r, vec!["^amagi__gated_community__ctx__dur_esla"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_melee_and_not_amagi__secret_chamber__ctx__east_dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $melee and not ^_east_dur_esla
    {
        let mut left = {
            let (res, mut refs) = hexplain__melee!(ctx, world, edict);
            edict.insert("$melee", format!("{:?}", res));
            refs.push("$melee");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.amagi__secret_chamber__ctx__east_dur_esla();
                    edict.insert(
                        "^amagi__secret_chamber__ctx__east_dur_esla",
                        format!("{:?}", r),
                    );
                    (r, vec!["^amagi__secret_chamber__ctx__east_dur_esla"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_melee_and_not_amagi__secret_chamber__ctx__west_dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $melee and not ^_west_dur_esla
    {
        let mut left = {
            let (res, mut refs) = hexplain__melee!(ctx, world, edict);
            edict.insert("$melee", format!("{:?}", res));
            refs.push("$melee");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.amagi__secret_chamber__ctx__west_dur_esla();
                    edict.insert(
                        "^amagi__secret_chamber__ctx__west_dur_esla",
                        format!("{:?}", r),
                    );
                    (r, vec!["^amagi__secret_chamber__ctx__west_dur_esla"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $melee_cskip
    {
        let (res, mut refs) = hexplain__melee_cskip!(ctx, world, edict);
        edict.insert("$melee_cskip", format!("{:?}", res));
        refs.push("$melee_cskip");
        (res, refs)
    }
}
pub fn explain_invoke_melee_cskip_and_fast_travel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $melee_cskip and Fast_Travel
    {
        let mut left = {
            let (res, mut refs) = hexplain__melee_cskip!(ctx, world, edict);
            edict.insert("$melee_cskip", format!("{:?}", res));
            refs.push("$melee_cskip");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Fast_Travel);
                edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_more_refills(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $more_refills
    {
        let (res, mut refs) = hexplain__more_refills!(ctx, world, edict);
        edict.insert("$more_refills", format!("{:?}", res));
        refs.push("$more_refills");
        (res, refs)
    }
}
pub fn explain_invoke_offset(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $offset
    {
        let (res, mut refs) = hexplain__offset!(ctx, world, edict);
        edict.insert("$offset", format!("{:?}", res));
        refs.push("$offset");
        (res, refs)
    }
}
pub fn explain_invoke_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open
    {
        let (res, mut refs) = hexplain__open!(ctx, world, edict);
        edict.insert("$open", format!("{:?}", res));
        refs.push("$open");
        (res, refs)
    }
}
pub fn explain_invoke_open_and_invoke_range1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range1
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range1!(ctx, world, edict);
                edict.insert("$range1", format!("{:?}", res));
                refs.push("$range1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range2
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                edict.insert("$range2", format!("{:?}", res));
                refs.push("$range2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_open_and_invoke_range2_and_not_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range2 and not ^_doors_opened
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__open!(ctx, world, edict);
                edict.insert("$open", format!("{:?}", res));
                refs.push("$open");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                    edict.insert("$range2", format!("{:?}", res));
                    refs.push("$range2");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.annuna__west_bridge__ctx__doors_opened();
                    edict.insert(
                        "^annuna__west_bridge__ctx__doors_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^annuna__west_bridge__ctx__doors_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_open_and_invoke_range3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and $range3
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range3!(ctx, world, edict);
                edict.insert("$range3", format!("{:?}", res));
                refs.push("$range3");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_open_and_not_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and not ^_doors_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.annuna__west_bridge__ctx__doors_opened();
                    edict.insert(
                        "^annuna__west_bridge__ctx__doors_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^annuna__west_bridge__ctx__doors_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_open_and_not_ebih__vertical_interchange__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and not ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__open!(ctx, world, edict);
            edict.insert("$open", format!("{:?}", res));
            refs.push("$open");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__vertical_interchange__ctx__door_open();
                    edict.insert(
                        "^ebih__vertical_interchange__ctx__door_open",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_open_and_not_ebih__vertical_interchange__ctx__door_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $open and not ^_door_open and $range2
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__open!(ctx, world, edict);
                edict.insert("$open", format!("{:?}", res));
                refs.push("$open");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let val = {
                        let r = ctx.ebih__vertical_interchange__ctx__door_open();
                        edict.insert(
                            "^ebih__vertical_interchange__ctx__door_open",
                            format!("{:?}", r),
                        );
                        (r, vec!["^ebih__vertical_interchange__ctx__door_open"])
                    };
                    (!val.0, val.1)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                edict.insert("$range2", format!("{:?}", res));
                refs.push("$range2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_overheat(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $overheat
    {
        let (res, mut refs) = hexplain__overheat!(ctx, world, edict);
        edict.insert("$overheat", format!("{:?}", res));
        refs.push("$overheat");
        (res, refs)
    }
}
pub fn explain_invoke_overheat_and_invoke_can_damage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $overheat and $can_damage
    {
        let mut left = {
            let (res, mut refs) = hexplain__overheat!(ctx, world, edict);
            edict.insert("$overheat", format!("{:?}", res));
            refs.push("$overheat");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_damage!(ctx, world, edict);
                edict.insert("$can_damage", format!("{:?}", res));
                refs.push("$can_damage");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_platform_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $platform and $hook and $hover
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__platform!(ctx, world, edict);
                edict.insert("$platform", format!("{:?}", res));
                refs.push("$platform");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_platform_and_invoke_hook_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $platform and $hook and not ^_left_platform_moved
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__platform!(ctx, world, edict);
                edict.insert("$platform", format!("{:?}", res));
                refs.push("$platform");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.ebih__base_camp__ctx__left_platform_moved();
                    edict.insert(
                        "^ebih__base_camp__ctx__left_platform_moved",
                        format!("{:?}", r),
                    );
                    (r, vec!["^ebih__base_camp__ctx__left_platform_moved"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_remote_boomerang(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $remote_boomerang
    {
        let (res, mut refs) = hexplain__remote_boomerang!(ctx, world, edict);
        edict.insert("$remote_boomerang", format!("{:?}", res));
        refs.push("$remote_boomerang");
        (res, refs)
    }
}
pub fn explain_invoke_shockwave(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave
    {
        let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
        edict.insert("$shockwave", format!("{:?}", res));
        refs.push("$shockwave");
        (res, refs)
    }
}
pub fn explain_invoke_shockwave_and_not_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave and not ^_dur_esla
    {
        let mut left = {
            let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
            edict.insert("$shockwave", format!("{:?}", res));
            refs.push("$shockwave");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.amagi__gated_community__ctx__dur_esla();
                    edict.insert("^amagi__gated_community__ctx__dur_esla", format!("{:?}", r));
                    (r, vec!["^amagi__gated_community__ctx__dur_esla"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_shockwave_and_not_amagi__secret_chamber__ctx__east_dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave and not ^_east_dur_esla
    {
        let mut left = {
            let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
            edict.insert("$shockwave", format!("{:?}", res));
            refs.push("$shockwave");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.amagi__secret_chamber__ctx__east_dur_esla();
                    edict.insert(
                        "^amagi__secret_chamber__ctx__east_dur_esla",
                        format!("{:?}", r),
                    );
                    (r, vec!["^amagi__secret_chamber__ctx__east_dur_esla"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_shockwave_and_not_amagi__secret_chamber__ctx__west_dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave and not ^_west_dur_esla
    {
        let mut left = {
            let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
            edict.insert("$shockwave", format!("{:?}", res));
            refs.push("$shockwave");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.amagi__secret_chamber__ctx__west_dur_esla();
                    edict.insert(
                        "^amagi__secret_chamber__ctx__west_dur_esla",
                        format!("{:?}", r),
                    );
                    (r, vec!["^amagi__secret_chamber__ctx__west_dur_esla"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_shockwave_and_not_defeat_mus_a_m20(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $shockwave and not Defeat_MUS_A_M20
    {
        let mut left = {
            let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
            edict.insert("$shockwave", format!("{:?}", res));
            refs.push("$shockwave");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Defeat_MUS_A_M20);
                edict.insert("Defeat_MUS_A_M20", format!("{}", h));
                (!h, vec!["Defeat_MUS_A_M20"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_slow(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $slow
    {
        let (res, mut refs) = hexplain__slow!(ctx, world, edict);
        edict.insert("$slow", format!("{:?}", res));
        refs.push("$slow");
        (res, refs)
    }
}
pub fn explain_invoke_spin(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $spin
    {
        let (res, mut refs) = hexplain__spin!(ctx, world, edict);
        edict.insert("$spin", format!("{:?}", res));
        refs.push("$spin");
        (res, refs)
    }
}
pub fn explain_invoke_spinhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $spinhover
    {
        let (res, mut refs) = hexplain__spinhover!(ctx, world, edict);
        edict.insert("$spinhover", format!("{:?}", res));
        refs.push("$spinhover");
        (res, refs)
    }
}
pub fn explain_invoke_sync(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $sync
    {
        let (res, mut refs) = hexplain__sync!(ctx, world, edict);
        edict.insert("$sync", format!("{:?}", res));
        refs.push("$sync");
        (res, refs)
    }
}
pub fn explain_invoke_sync_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $sync and $hook
    {
        let mut left = {
            let (res, mut refs) = hexplain__sync!(ctx, world, edict);
            edict.insert("$sync", format!("{:?}", res));
            refs.push("$sync");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock3_and_invoke_range2_and_not_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and $range2 and not ^_door_opened
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
                edict.insert("$unlock3", format!("{:?}", res));
                refs.push("$unlock3");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                    edict.insert("$range2", format!("{:?}", res));
                    refs.push("$range2");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.giguna__giguna_northeast__ctx__door_opened();
                    edict.insert(
                        "^giguna__giguna_northeast__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock3_and_not_giguna__carnelian__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and not ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
            edict.insert("$unlock3", format!("{:?}", res));
            refs.push("$unlock3");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.giguna__carnelian__ctx__door_opened();
                    edict.insert("^giguna__carnelian__ctx__door_opened", format!("{:?}", r));
                    (r, vec!["^giguna__carnelian__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock3_and_not_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and not ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
            edict.insert("$unlock3", format!("{:?}", res));
            refs.push("$unlock3");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.giguna__giguna_northeast__ctx__door_opened();
                    edict.insert(
                        "^giguna__giguna_northeast__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__giguna_northeast__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock3_and_not_glacier__lonely_bull__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock3 and not ^_door
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock3!(ctx, world, edict);
            edict.insert("$unlock3", format!("{:?}", res));
            refs.push("$unlock3");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.glacier__lonely_bull__ctx__door();
                    edict.insert("^glacier__lonely_bull__ctx__door", format!("{:?}", r));
                    (r, vec!["^glacier__lonely_bull__ctx__door"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock4_and_invoke_range2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and $range2
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
            edict.insert("$unlock4", format!("{:?}", res));
            refs.push("$unlock4");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                edict.insert("$range2", format!("{:?}", res));
                refs.push("$range2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock4_and_invoke_range2_and_not_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and $range2 and not ^_door_open
    {
        let mut left = {
            let mut left = {
                let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
                edict.insert("$unlock4", format!("{:?}", res));
                refs.push("$unlock4");
                (res, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                    edict.insert("$range2", format!("{:?}", res));
                    refs.push("$range2");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.emergence__storage__ctx__door_open();
                    edict.insert("^emergence__storage__ctx__door_open", format!("{:?}", r));
                    (r, vec!["^emergence__storage__ctx__door_open"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock4_and_not_annuna__boss_gate__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and not ^_door
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
            edict.insert("$unlock4", format!("{:?}", res));
            refs.push("$unlock4");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.annuna__boss_gate__ctx__door();
                    edict.insert("^annuna__boss_gate__ctx__door", format!("{:?}", r));
                    (r, vec!["^annuna__boss_gate__ctx__door"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock4_and_not_annuna__udug_gate__ctx__door(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and not ^_door
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
            edict.insert("$unlock4", format!("{:?}", res));
            refs.push("$unlock4");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.annuna__udug_gate__ctx__door();
                    edict.insert("^annuna__udug_gate__ctx__door", format!("{:?}", r));
                    (r, vec!["^annuna__udug_gate__ctx__door"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock4_and_not_annuna__west_climb__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and not ^_door_opened
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
            edict.insert("$unlock4", format!("{:?}", res));
            refs.push("$unlock4");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.annuna__west_climb__ctx__door_opened();
                    edict.insert("^annuna__west_climb__ctx__door_opened", format!("{:?}", r));
                    (r, vec!["^annuna__west_climb__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_invoke_unlock4_and_not_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // $unlock4 and not ^_door_open
    {
        let mut left = {
            let (res, mut refs) = hexplain__unlock4!(ctx, world, edict);
            edict.insert("$unlock4", format!("{:?}", res));
            refs.push("$unlock4");
            (res, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.emergence__storage__ctx__door_open();
                    edict.insert("^emergence__storage__ctx__door_open", format!("{:?}", r));
                    (r, vec!["^emergence__storage__ctx__door_open"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_irikar__basement_portal__ctx__platform_moved_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^_platform_moved and $hook
    {
        let mut left = {
            let r = ctx.irikar__basement_portal__ctx__platform_moved();
            edict.insert(
                "^irikar__basement_portal__ctx__platform_moved",
                format!("{:?}", r),
            );
            (r, vec!["^irikar__basement_portal__ctx__platform_moved"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_irikar_breach_buried_treasure_pillar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Breach_Buried_Treasure_Pillar
    {
        let h = ctx.has(Item::Irikar_Breach_Buried_Treasure_Pillar);
        edict.insert("Irikar_Breach_Buried_Treasure_Pillar", format!("{}", h));
        (h, vec!["Irikar_Breach_Buried_Treasure_Pillar"])
    }
}
pub fn explain_irikar_breach_uhrum_connector_wall_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Breach_Uhrum_Connector_Wall and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Irikar_Breach_Uhrum_Connector_Wall);
                edict.insert("Irikar_Breach_Uhrum_Connector_Wall", format!("{}", h));
                (h, vec!["Irikar_Breach_Uhrum_Connector_Wall"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_irikar_gudam(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Gudam
    {
        let h = ctx.has(Item::Irikar_Gudam);
        edict.insert("Irikar_Gudam", format!("{}", h));
        (h, vec!["Irikar_Gudam"])
    }
}
pub fn explain_irikar_gudam_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Gudam and $shockwave
    {
        let mut left = {
            let h = ctx.has(Item::Irikar_Gudam);
            edict.insert("Irikar_Gudam", format!("{}", h));
            (h, vec!["Irikar_Gudam"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_irikar_royal_storage_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Irikar_Royal_Storage_Wall
    {
        let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
        edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
        (h, vec!["Irikar_Royal_Storage_Wall"])
    }
}
pub fn explain_map__amagi__east_lake__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi__east_lake__save
    {
        let r = ctx.map__amagi__east_lake__save();
        edict.insert("^map__amagi__east_lake__save", format!("{:?}", r));
        (r, vec!["^map__amagi__east_lake__save"])
    }
}
pub fn explain_map__amagi__main_area__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi__main_area__save
    {
        let r = ctx.map__amagi__main_area__save();
        edict.insert("^map__amagi__main_area__save", format!("{:?}", r));
        (r, vec!["^map__amagi__main_area__save"])
    }
}
pub fn explain_map__amagi_breach__divided__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi_breach__divided__save
    {
        let r = ctx.map__amagi_breach__divided__save();
        edict.insert("^map__amagi_breach__divided__save", format!("{:?}", r));
        (r, vec!["^map__amagi_breach__divided__save"])
    }
}
pub fn explain_map__amagi_breach__east_entrance__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi_breach__east_entrance__save
    {
        let r = ctx.map__amagi_breach__east_entrance__save();
        edict.insert(
            "^map__amagi_breach__east_entrance__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__amagi_breach__east_entrance__save"])
    }
}
pub fn explain_map__amagi_breach__east_ruins__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi_breach__east_ruins__save
    {
        let r = ctx.map__amagi_breach__east_ruins__save();
        edict.insert("^map__amagi_breach__east_ruins__save", format!("{:?}", r));
        (r, vec!["^map__amagi_breach__east_ruins__save"])
    }
}
pub fn explain_map__amagi_breach__upper_lake__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__amagi_breach__upper_lake__save
    {
        let r = ctx.map__amagi_breach__upper_lake__save();
        edict.insert("^map__amagi_breach__upper_lake__save", format!("{:?}", r));
        (r, vec!["^map__amagi_breach__upper_lake__save"])
    }
}
pub fn explain_map__annuna__center_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__center_save__save
    {
        let r = ctx.map__annuna__center_save__save();
        edict.insert("^map__annuna__center_save__save", format!("{:?}", r));
        (r, vec!["^map__annuna__center_save__save"])
    }
}
pub fn explain_map__annuna__factory_entrance__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__factory_entrance__save
    {
        let r = ctx.map__annuna__factory_entrance__save();
        edict.insert("^map__annuna__factory_entrance__save", format!("{:?}", r));
        (r, vec!["^map__annuna__factory_entrance__save"])
    }
}
pub fn explain_map__annuna__mirror_match__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__mirror_match__save
    {
        let r = ctx.map__annuna__mirror_match__save();
        edict.insert("^map__annuna__mirror_match__save", format!("{:?}", r));
        (r, vec!["^map__annuna__mirror_match__save"])
    }
}
pub fn explain_map__annuna__upper_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__upper_save__save
    {
        let r = ctx.map__annuna__upper_save__save();
        edict.insert("^map__annuna__upper_save__save", format!("{:?}", r));
        (r, vec!["^map__annuna__upper_save__save"])
    }
}
pub fn explain_map__annuna__vertical_room__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna__vertical_room__save
    {
        let r = ctx.map__annuna__vertical_room__save();
        edict.insert("^map__annuna__vertical_room__save", format!("{:?}", r));
        (r, vec!["^map__annuna__vertical_room__save"])
    }
}
pub fn explain_map__annuna_breach__bottom__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna_breach__bottom__save
    {
        let r = ctx.map__annuna_breach__bottom__save();
        edict.insert("^map__annuna_breach__bottom__save", format!("{:?}", r));
        (r, vec!["^map__annuna_breach__bottom__save"])
    }
}
pub fn explain_map__annuna_breach__bridge__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna_breach__bridge__save
    {
        let r = ctx.map__annuna_breach__bridge__save();
        edict.insert("^map__annuna_breach__bridge__save", format!("{:?}", r));
        (r, vec!["^map__annuna_breach__bridge__save"])
    }
}
pub fn explain_map__annuna_breach__double_corridor__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna_breach__double_corridor__save
    {
        let r = ctx.map__annuna_breach__double_corridor__save();
        edict.insert(
            "^map__annuna_breach__double_corridor__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__annuna_breach__double_corridor__save"])
    }
}
pub fn explain_map__annuna_breach__enclosed__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna_breach__enclosed__save
    {
        let r = ctx.map__annuna_breach__enclosed__save();
        edict.insert("^map__annuna_breach__enclosed__save", format!("{:?}", r));
        (r, vec!["^map__annuna_breach__enclosed__save"])
    }
}
pub fn explain_map__annuna_breach__north_hallway__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna_breach__north_hallway__save
    {
        let r = ctx.map__annuna_breach__north_hallway__save();
        edict.insert(
            "^map__annuna_breach__north_hallway__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__annuna_breach__north_hallway__save"])
    }
}
pub fn explain_map__annuna_breach__rear_entrance__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__annuna_breach__rear_entrance__save
    {
        let r = ctx.map__annuna_breach__rear_entrance__save();
        edict.insert(
            "^map__annuna_breach__rear_entrance__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__annuna_breach__rear_entrance__save"])
    }
}
pub fn explain_map__ebih__base_camp__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__base_camp__save
    {
        let r = ctx.map__ebih__base_camp__save();
        edict.insert("^map__ebih__base_camp__save", format!("{:?}", r));
        (r, vec!["^map__ebih__base_camp__save"])
    }
}
pub fn explain_map__ebih__ebih_west__lower_save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__ebih_west__lower_save
    {
        let r = ctx.map__ebih__ebih_west__lower_save();
        edict.insert("^map__ebih__ebih_west__lower_save", format!("{:?}", r));
        (r, vec!["^map__ebih__ebih_west__lower_save"])
    }
}
pub fn explain_map__ebih__ebih_west__mid_save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__ebih_west__mid_save
    {
        let r = ctx.map__ebih__ebih_west__mid_save();
        edict.insert("^map__ebih__ebih_west__mid_save", format!("{:?}", r));
        (r, vec!["^map__ebih__ebih_west__mid_save"])
    }
}
pub fn explain_map__ebih__ebih_west__upper_save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__ebih_west__upper_save
    {
        let r = ctx.map__ebih__ebih_west__upper_save();
        edict.insert("^map__ebih__ebih_west__upper_save", format!("{:?}", r));
        (r, vec!["^map__ebih__ebih_west__upper_save"])
    }
}
pub fn explain_map__ebih__hidden_portal__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih__hidden_portal__save
    {
        let r = ctx.map__ebih__hidden_portal__save();
        edict.insert("^map__ebih__hidden_portal__save", format!("{:?}", r));
        (r, vec!["^map__ebih__hidden_portal__save"])
    }
}
pub fn explain_map__ebih_breach__in_n_out__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih_breach__in_n_out__save
    {
        let r = ctx.map__ebih_breach__in_n_out__save();
        edict.insert("^map__ebih_breach__in_n_out__save", format!("{:?}", r));
        (r, vec!["^map__ebih_breach__in_n_out__save"])
    }
}
pub fn explain_map__ebih_breach__peak__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih_breach__peak__save
    {
        let r = ctx.map__ebih_breach__peak__save();
        edict.insert("^map__ebih_breach__peak__save", format!("{:?}", r));
        (r, vec!["^map__ebih_breach__peak__save"])
    }
}
pub fn explain_map__ebih_breach__portals_101__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih_breach__portals_101__save
    {
        let r = ctx.map__ebih_breach__portals_101__save();
        edict.insert("^map__ebih_breach__portals_101__save", format!("{:?}", r));
        (r, vec!["^map__ebih_breach__portals_101__save"])
    }
}
pub fn explain_map__ebih_breach__rock_block__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__ebih_breach__rock_block__save
    {
        let r = ctx.map__ebih_breach__rock_block__save();
        edict.insert("^map__ebih_breach__rock_block__save", format!("{:?}", r));
        (r, vec!["^map__ebih_breach__rock_block__save"])
    }
}
pub fn explain_map__emergence__camp_exterior__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__emergence__camp_exterior__save
    {
        let r = ctx.map__emergence__camp_exterior__save();
        edict.insert("^map__emergence__camp_exterior__save", format!("{:?}", r));
        (r, vec!["^map__emergence__camp_exterior__save"])
    }
}
pub fn explain_map__giguna__giguna_base__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__giguna_base__save
    {
        let r = ctx.map__giguna__giguna_base__save();
        edict.insert("^map__giguna__giguna_base__save", format!("{:?}", r));
        (r, vec!["^map__giguna__giguna_base__save"])
    }
}
pub fn explain_map__giguna__giguna_northeast__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__giguna_northeast__save
    {
        let r = ctx.map__giguna__giguna_northeast__save();
        edict.insert("^map__giguna__giguna_northeast__save", format!("{:?}", r));
        (r, vec!["^map__giguna__giguna_northeast__save"])
    }
}
pub fn explain_map__giguna__labyrinth__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__labyrinth__save
    {
        let r = ctx.map__giguna__labyrinth__save();
        edict.insert("^map__giguna__labyrinth__save", format!("{:?}", r));
        (r, vec!["^map__giguna__labyrinth__save"])
    }
}
pub fn explain_map__giguna__ruins_top__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__ruins_top__save
    {
        let r = ctx.map__giguna__ruins_top__save();
        edict.insert("^map__giguna__ruins_top__save", format!("{:?}", r));
        (r, vec!["^map__giguna__ruins_top__save"])
    }
}
pub fn explain_map__giguna__ruins_west__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__ruins_west__save
    {
        let r = ctx.map__giguna__ruins_west__save();
        edict.insert("^map__giguna__ruins_west__save", format!("{:?}", r));
        (r, vec!["^map__giguna__ruins_west__save"])
    }
}
pub fn explain_map__giguna__separator__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna__separator__save
    {
        let r = ctx.map__giguna__separator__save();
        edict.insert("^map__giguna__separator__save", format!("{:?}", r));
        (r, vec!["^map__giguna__separator__save"])
    }
}
pub fn explain_map__giguna_breach__east__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__east__save
    {
        let r = ctx.map__giguna_breach__east__save();
        edict.insert("^map__giguna_breach__east__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__east__save"])
    }
}
pub fn explain_map__giguna_breach__labyrinth__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__labyrinth__save
    {
        let r = ctx.map__giguna_breach__labyrinth__save();
        edict.insert("^map__giguna_breach__labyrinth__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__labyrinth__save"])
    }
}
pub fn explain_map__giguna_breach__peak__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__peak__save
    {
        let r = ctx.map__giguna_breach__peak__save();
        edict.insert("^map__giguna_breach__peak__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__peak__save"])
    }
}
pub fn explain_map__giguna_breach__south__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__south__save
    {
        let r = ctx.map__giguna_breach__south__save();
        edict.insert("^map__giguna_breach__south__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__south__save"])
    }
}
pub fn explain_map__giguna_breach__sw_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__giguna_breach__sw_save__save
    {
        let r = ctx.map__giguna_breach__sw_save__save();
        edict.insert("^map__giguna_breach__sw_save__save", format!("{:?}", r));
        (r, vec!["^map__giguna_breach__sw_save__save"])
    }
}
pub fn explain_map__glacier__revival__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier__revival__save
    {
        let r = ctx.map__glacier__revival__save();
        edict.insert("^map__glacier__revival__save", format!("{:?}", r));
        (r, vec!["^map__glacier__revival__save"])
    }
}
pub fn explain_map__glacier_breach__guarded_corridor__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier_breach__guarded_corridor__save
    {
        let r = ctx.map__glacier_breach__guarded_corridor__save();
        edict.insert(
            "^map__glacier_breach__guarded_corridor__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__glacier_breach__guarded_corridor__save"])
    }
}
pub fn explain_map__glacier_breach__hammonds_breach__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier_breach__hammonds_breach__save
    {
        let r = ctx.map__glacier_breach__hammonds_breach__save();
        edict.insert(
            "^map__glacier_breach__hammonds_breach__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__glacier_breach__hammonds_breach__save"])
    }
}
pub fn explain_map__glacier_breach__save_and_exit__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier_breach__save_and_exit__save
    {
        let r = ctx.map__glacier_breach__save_and_exit__save();
        edict.insert(
            "^map__glacier_breach__save_and_exit__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__glacier_breach__save_and_exit__save"])
    }
}
pub fn explain_map__glacier_breach__south_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier_breach__south_save__save
    {
        let r = ctx.map__glacier_breach__south_save__save();
        edict.insert("^map__glacier_breach__south_save__save", format!("{:?}", r));
        (r, vec!["^map__glacier_breach__south_save__save"])
    }
}
pub fn explain_map__glacier_breach__west_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__glacier_breach__west_save__save
    {
        let r = ctx.map__glacier_breach__west_save__save();
        edict.insert("^map__glacier_breach__west_save__save", format!("{:?}", r));
        (r, vec!["^map__glacier_breach__west_save__save"])
    }
}
pub fn explain_map__irikar__beach_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar__beach_save__save
    {
        let r = ctx.map__irikar__beach_save__save();
        edict.insert("^map__irikar__beach_save__save", format!("{:?}", r));
        (r, vec!["^map__irikar__beach_save__save"])
    }
}
pub fn explain_map__irikar__hub__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar__hub__save
    {
        let r = ctx.map__irikar__hub__save();
        edict.insert("^map__irikar__hub__save", format!("{:?}", r));
        (r, vec!["^map__irikar__hub__save"])
    }
}
pub fn explain_map__irikar__midwest__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar__midwest__save
    {
        let r = ctx.map__irikar__midwest__save();
        edict.insert("^map__irikar__midwest__save", format!("{:?}", r));
        (r, vec!["^map__irikar__midwest__save"])
    }
}
pub fn explain_map__irikar_breach__basement_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar_breach__basement_save__save
    {
        let r = ctx.map__irikar_breach__basement_save__save();
        edict.insert(
            "^map__irikar_breach__basement_save__save",
            format!("{:?}", r),
        );
        (r, vec!["^map__irikar_breach__basement_save__save"])
    }
}
pub fn explain_map__irikar_breach__corridor__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar_breach__corridor__save
    {
        let r = ctx.map__irikar_breach__corridor__save();
        edict.insert("^map__irikar_breach__corridor__save", format!("{:?}", r));
        (r, vec!["^map__irikar_breach__corridor__save"])
    }
}
pub fn explain_map__irikar_breach__gauntlet__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar_breach__gauntlet__save
    {
        let r = ctx.map__irikar_breach__gauntlet__save();
        edict.insert("^map__irikar_breach__gauntlet__save", format!("{:?}", r));
        (r, vec!["^map__irikar_breach__gauntlet__save"])
    }
}
pub fn explain_map__irikar_breach__save_room__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__irikar_breach__save_room__save
    {
        let r = ctx.map__irikar_breach__save_room__save();
        edict.insert("^map__irikar_breach__save_room__save", format!("{:?}", r));
        (r, vec!["^map__irikar_breach__save_room__save"])
    }
}
pub fn explain_map__uhrum__annuna_corridor__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__annuna_corridor__save
    {
        let r = ctx.map__uhrum__annuna_corridor__save();
        edict.insert("^map__uhrum__annuna_corridor__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__annuna_corridor__save"])
    }
}
pub fn explain_map__uhrum__emergence_save__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__emergence_save__save
    {
        let r = ctx.map__uhrum__emergence_save__save();
        edict.insert("^map__uhrum__emergence_save__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__emergence_save__save"])
    }
}
pub fn explain_map__uhrum__save_room__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__save_room__save
    {
        let r = ctx.map__uhrum__save_room__save();
        edict.insert("^map__uhrum__save_room__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__save_room__save"])
    }
}
pub fn explain_map__uhrum__west_entrance__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum__west_entrance__save
    {
        let r = ctx.map__uhrum__west_entrance__save();
        edict.insert("^map__uhrum__west_entrance__save", format!("{:?}", r));
        (r, vec!["^map__uhrum__west_entrance__save"])
    }
}
pub fn explain_map__uhrum_breach__annuna_gate__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum_breach__annuna_gate__save
    {
        let r = ctx.map__uhrum_breach__annuna_gate__save();
        edict.insert("^map__uhrum_breach__annuna_gate__save", format!("{:?}", r));
        (r, vec!["^map__uhrum_breach__annuna_gate__save"])
    }
}
pub fn explain_map__uhrum_breach__east_glitch__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum_breach__east_glitch__save
    {
        let r = ctx.map__uhrum_breach__east_glitch__save();
        edict.insert("^map__uhrum_breach__east_glitch__save", format!("{:?}", r));
        (r, vec!["^map__uhrum_breach__east_glitch__save"])
    }
}
pub fn explain_map__uhrum_breach__locked_down__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum_breach__locked_down__save
    {
        let r = ctx.map__uhrum_breach__locked_down__save();
        edict.insert("^map__uhrum_breach__locked_down__save", format!("{:?}", r));
        (r, vec!["^map__uhrum_breach__locked_down__save"])
    }
}
pub fn explain_map__uhrum_breach__save_and_go__save(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^map__uhrum_breach__save_and_go__save
    {
        let r = ctx.map__uhrum_breach__save_and_go__save();
        edict.insert("^map__uhrum_breach__save_and_go__save", format!("{:?}", r));
        (r, vec!["^map__uhrum_breach__save_and_go__save"])
    }
}
pub fn explain_melee_damage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Damage
    {
        let h = ctx.has(Item::Melee_Damage);
        edict.insert("Melee_Damage", format!("{}", h));
        (h, vec!["Melee_Damage"])
    }
}
pub fn explain_melee_damage_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Damage_2
    {
        let h = ctx.has(Item::Melee_Damage_2);
        edict.insert("Melee_Damage_2", format!("{}", h));
        (h, vec!["Melee_Damage_2"])
    }
}
pub fn explain_melee_speed(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Speed
    {
        let h = ctx.has(Item::Melee_Speed);
        edict.insert("Melee_Speed", format!("{}", h));
        (h, vec!["Melee_Speed"])
    }
}
pub fn explain_melee_speed_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Melee_Speed_2
    {
        let h = ctx.has(Item::Melee_Speed_2);
        edict.insert("Melee_Speed_2", format!("{}", h));
        (h, vec!["Melee_Speed_2"])
    }
}
pub fn explain_mode_eq_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone'
    {
        let mut refs = vec!["^mode"];
        let mut left = {
            let r = ctx.mode();
            edict.insert("^mode", format!("{:?}", r));
            (r, vec!["^mode"])
        };
        let right = enums::Mode::Drone;
        edict.insert("^mode", format!("{}", left.0));
        refs.append(&mut left.1);
        (left.0 == right, refs)
    }
}
pub fn explain_mode_eq_drone_and_apocalypse_seals_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Apocalypse_Seals_Wall
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Seals_Wall);
                edict.insert("Apocalypse_Seals_Wall", format!("{}", h));
                (h, vec!["Apocalypse_Seals_Wall"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_drone_melee_damage_3_and_drone_melee_speed_2_and_infect(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Drone_Melee_Damage_3 and Drone_Melee_Speed_2 and Infect
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut refs = vec!["^mode"];
                    let mut left = {
                        let r = ctx.mode();
                        edict.insert("^mode", format!("{:?}", r));
                        (r, vec!["^mode"])
                    };
                    let right = enums::Mode::Drone;
                    edict.insert("^mode", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 == right, refs)
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Drone_Melee_Damage_3);
                        edict.insert("Drone_Melee_Damage_3", format!("{}", h));
                        (h, vec!["Drone_Melee_Damage_3"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Melee_Speed_2);
                    edict.insert("Drone_Melee_Speed_2", format!("{}", h));
                    (h, vec!["Drone_Melee_Speed_2"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Infect);
                edict.insert("Infect", format!("{}", h));
                (h, vec!["Infect"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Left
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Left);
                edict.insert("Ebih_Waterfall_Block_Left", format!("{}", h));
                (h, vec!["Ebih_Waterfall_Block_Left"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Right
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Waterfall_Block_Right);
                edict.insert("Ebih_Waterfall_Block_Right", format!("{}", h));
                (h, vec!["Ebih_Waterfall_Block_Right"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_fast_travel(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Fast_Travel
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Fast_Travel);
                edict.insert("Fast_Travel", format!("{}", h));
                (h, vec!["Fast_Travel"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and ^_combo_entered
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_giguna_dual_path_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Giguna_Dual_Path_Wall
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Dual_Path_Wall);
                edict.insert("Giguna_Dual_Path_Wall", format!("{}", h));
                (h, vec!["Giguna_Dual_Path_Wall"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_giguna_wasteland_passage_h(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Giguna_Wasteland_Passage_H
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Wasteland_Passage_H);
                edict.insert("Giguna_Wasteland_Passage_H", format!("{}", h));
                (h, vec!["Giguna_Wasteland_Passage_H"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_indra_eq_giguna_gt_separator_gt_platform(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and ^indra == `Giguna > Separator > Platform`
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let left = {
                    let r = ctx.indra();
                    edict.insert("^indra", format!("{:?}", r));
                    (r, vec!["^indra"])
                };
                (left.0 == SpotId::Giguna__Separator__Platform, left.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_mist_upgrade_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Mist_Upgrade);
                    edict.insert("Mist_Upgrade", format!("{}", h));
                    (h, vec!["Mist_Upgrade"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Nanite_Mist
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_nanite_mist_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Nanite_Mist and ^_combo_entered
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Nanite_Mist);
                    edict.insert("Nanite_Mist", format!("{}", h));
                    (h, vec!["Nanite_Mist"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.giguna__east_caverns__ctx__combo_entered();
                edict.insert(
                    "^giguna__east_caverns__ctx__combo_entered",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_portal_eq_position_and_flipside_ne_invoke_default_and___not_portal_hidden_or_breach_sight_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and ^portal == ^position and ^flipside != $default and (not ^portal_hidden or Breach_Sight) and not Apocalypse_Bomb
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let mut refs = vec!["^mode"];
                        let mut left = {
                            let r = ctx.mode();
                            edict.insert("^mode", format!("{:?}", r));
                            (r, vec!["^mode"])
                        };
                        let right = enums::Mode::Drone;
                        edict.insert("^mode", format!("{}", left.0));
                        refs.append(&mut left.1);
                        (left.0 == right, refs)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let mut left = {
                                let r = ctx.portal();
                                edict.insert("^portal", format!("{:?}", r));
                                (r, vec!["^portal"])
                            };
                            let mut right = {
                                let r = ctx.position();
                                edict.insert("^position", format!("{:?}", r));
                                (r, vec!["^position"])
                            };
                            left.1.append(&mut right.1);
                            (left.0 == right.0, left.1)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let mut left = {
                            let r = data::flipside(ctx.position());
                            edict.insert("^flipside", format!("{:?}", r));
                            (r, vec!["^flipside"])
                        };
                        let mut right = (Default::default(), vec![]);
                        left.1.append(&mut right.1);
                        (left.0 != right.0, left.1)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = ({
                    let mut left = {
                        let val = {
                            let r = data::portal_hidden(ctx.position());
                            edict.insert("^portal_hidden", format!("{:?}", r));
                            (r, vec!["^portal_hidden"])
                        };
                        (!val.0, val.1)
                    };
                    if left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = ctx.has(Item::Breach_Sight);
                            edict.insert("Breach_Sight", format!("{}", h));
                            (h, vec!["Breach_Sight"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                });
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Apocalypse_Bomb);
                edict.insert("Apocalypse_Bomb", format!("{}", h));
                (!h, vec!["Apocalypse_Bomb"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_sniper_valley_rock_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Sniper_Valley_Rock_2
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Sniper_Valley_Rock_2);
                edict.insert("Sniper_Valley_Rock_2", format!("{}", h));
                (h, vec!["Sniper_Valley_Rock_2"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_eq_drone_and_uhrum_west_glitch(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode == 'drone' and Uhrum_West_Glitch
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 == right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Uhrum_West_Glitch);
                edict.insert("Uhrum_West_Glitch", format!("{}", h));
                (h, vec!["Uhrum_West_Glitch"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_ne_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode != 'drone'
    {
        let mut refs = vec!["^mode"];
        let mut left = {
            let r = ctx.mode();
            edict.insert("^mode", format!("{:?}", r));
            (r, vec!["^mode"])
        };
        let right = enums::Mode::Drone;
        edict.insert("^mode", format!("{}", left.0));
        refs.append(&mut left.1);
        (left.0 != right, refs)
    }
}
pub fn explain_mode_ne_drone_and_ice_axe(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode != 'drone' and Ice_Axe
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 != right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ice_Axe);
                edict.insert("Ice_Axe", format!("{}", h));
                (h, vec!["Ice_Axe"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_mode_ne_drone_and_invoke_infinite_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^mode != 'drone' and $infinite_climb
    {
        let mut left = {
            let mut refs = vec!["^mode"];
            let mut left = {
                let r = ctx.mode();
                edict.insert("^mode", format!("{:?}", r));
                (r, vec!["^mode"])
            };
            let right = enums::Mode::Drone;
            edict.insert("^mode", format!("{}", left.0));
            refs.append(&mut left.1);
            (left.0 != right, refs)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__infinite_climb!(ctx, world, edict);
                edict.insert("$infinite_climb", format!("{:?}", res));
                refs.push("$infinite_climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nanite_Mist
    {
        let h = ctx.has(Item::Nanite_Mist);
        edict.insert("Nanite_Mist", format!("{}", h));
        (h, vec!["Nanite_Mist"])
    }
}
pub fn explain_nanite_mist_and_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nanite_Mist and ^_dur_esla
    {
        let mut left = {
            let h = ctx.has(Item::Nanite_Mist);
            edict.insert("Nanite_Mist", format!("{}", h));
            (h, vec!["Nanite_Mist"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.amagi__gated_community__ctx__dur_esla();
                edict.insert("^amagi__gated_community__ctx__dur_esla", format!("{:?}", r));
                (r, vec!["^amagi__gated_community__ctx__dur_esla"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_nanite_mist_and_not_irikar__midwest__ctx__right_platform(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nanite_Mist and not ^_right_platform
    {
        let mut left = {
            let h = ctx.has(Item::Nanite_Mist);
            edict.insert("Nanite_Mist", format!("{}", h));
            (h, vec!["Nanite_Mist"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let val = {
                    let r = ctx.irikar__midwest__ctx__right_platform();
                    edict.insert("^irikar__midwest__ctx__right_platform", format!("{:?}", r));
                    (r, vec!["^irikar__midwest__ctx__right_platform"])
                };
                (!val.0, val.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_nano_points(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nano_Points
    {
        let h = ctx.has(Item::Nano_Points);
        edict.insert("Nano_Points", format!("{}", h));
        (h, vec!["Nano_Points"])
    }
}
pub fn explain_nano_points_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Nano_Points_2
    {
        let h = ctx.has(Item::Nano_Points_2);
        edict.insert("Nano_Points_2", format!("{}", h));
        (h, vec!["Nano_Points_2"])
    }
}
pub fn explain_not_amagi__main_area__ctx__combo(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo
    {
        let val = {
            let r = ctx.amagi__main_area__ctx__combo();
            edict.insert("^amagi__main_area__ctx__combo", format!("{:?}", r));
            (r, vec!["^amagi__main_area__ctx__combo"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_amashilama(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT Amashilama
    {
        let h = ctx.has(Item::Amashilama);
        edict.insert("Amashilama", format!("{}", h));
        (!h, vec!["Amashilama"])
    }
}
pub fn explain_not_annuna__boss_gate__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door and Nanite_Mist
    {
        let mut left = {
            let val = {
                let r = ctx.annuna__boss_gate__ctx__door();
                edict.insert("^annuna__boss_gate__ctx__door", format!("{:?}", r));
                (r, vec!["^annuna__boss_gate__ctx__door"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_annuna__east_bridge__ctx__combo(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo
    {
        let val = {
            let r = ctx.annuna__east_bridge__ctx__combo();
            edict.insert("^annuna__east_bridge__ctx__combo", format!("{:?}", r));
            (r, vec!["^annuna__east_bridge__ctx__combo"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_annuna__udug_gate__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door and Nanite_Mist
    {
        let mut left = {
            let val = {
                let r = ctx.annuna__udug_gate__ctx__door();
                edict.insert("^annuna__udug_gate__ctx__door", format!("{:?}", r));
                (r, vec!["^annuna__udug_gate__ctx__door"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Apocalypse_Bomb
    {
        let h = ctx.has(Item::Apocalypse_Bomb);
        edict.insert("Apocalypse_Bomb", format!("{}", h));
        (!h, vec!["Apocalypse_Bomb"])
    }
}
pub fn explain_not_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Drone_Hover
    {
        let h = ctx.has(Item::Drone_Hover);
        edict.insert("Drone_Hover", format!("{}", h));
        (!h, vec!["Drone_Hover"])
    }
}
pub fn explain_not_drone_melee_damage_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Drone_Melee_Damage_3
    {
        let h = ctx.has(Item::Drone_Melee_Damage_3);
        edict.insert("Drone_Melee_Damage_3", format!("{}", h));
        (!h, vec!["Drone_Melee_Damage_3"])
    }
}
pub fn explain_not_drone_melee_speed_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Drone_Melee_Speed_3
    {
        let h = ctx.has(Item::Drone_Melee_Speed_3);
        edict.insert("Drone_Melee_Speed_3", format!("{}", h));
        (!h, vec!["Drone_Melee_Speed_3"])
    }
}
pub fn explain_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform2_moved
    {
        let val = {
            let r = ctx.ebih__ebih_east__ctx__platform2_moved();
            edict.insert("^ebih__ebih_east__ctx__platform2_moved", format!("{:?}", r));
            (r, vec!["^ebih__ebih_east__ctx__platform2_moved"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_open
    {
        let val = {
            let r = ctx.ebih__ebih_west__ctx__door_open();
            edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
            (r, vec!["^ebih__ebih_west__ctx__door_open"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_ebih__ebih_west__ctx__door_open_or_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_open or $grab
    {
        let mut left = {
            let val = {
                let r = ctx.ebih__ebih_west__ctx__door_open();
                edict.insert("^ebih__ebih_west__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__ebih_west__ctx__door_open"])
            };
            (!val.0, val.1)
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_ebih__truck_gate__ctx__door_open_and_invoke_open(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_open and $open
    {
        let mut left = {
            let val = {
                let r = ctx.ebih__truck_gate__ctx__door_open();
                edict.insert("^ebih__truck_gate__ctx__door_open", format!("{:?}", r));
                (r, vec!["^ebih__truck_gate__ctx__door_open"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__open!(ctx, world, edict);
                edict.insert("$open", format!("{:?}", res));
                refs.push("$open");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_ebih__truck_gate__ctx__door_open_and_invoke_open_and_invoke_range1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_open and $open and $range1
    {
        let mut left = {
            let mut left = {
                let val = {
                    let r = ctx.ebih__truck_gate__ctx__door_open();
                    edict.insert("^ebih__truck_gate__ctx__door_open", format!("{:?}", r));
                    (r, vec!["^ebih__truck_gate__ctx__door_open"])
                };
                (!val.0, val.1)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__open!(ctx, world, edict);
                    edict.insert("$open", format!("{:?}", res));
                    refs.push("$open");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range1!(ctx, world, edict);
                edict.insert("$range1", format!("{:?}", res));
                refs.push("$range1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_ebih_interchange_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Ebih_Interchange_Block
    {
        let h = ctx.has(Item::Ebih_Interchange_Block);
        edict.insert("Ebih_Interchange_Block", format!("{}", h));
        (!h, vec!["Ebih_Interchange_Block"])
    }
}
pub fn explain_not_giguna__carnelian__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar
    {
        let val = {
            let r = ctx.giguna__carnelian__ctx__lower_susar();
            edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__lower_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__carnelian__ctx__lower_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__carnelian__ctx__lower_susar();
                edict.insert("^giguna__carnelian__ctx__lower_susar", format!("{:?}", r));
                (r, vec!["^giguna__carnelian__ctx__lower_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__carnelian__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar
    {
        let val = {
            let r = ctx.giguna__carnelian__ctx__upper_susar();
            edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
            (r, vec!["^giguna__carnelian__ctx__upper_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__carnelian__ctx__upper_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__carnelian__ctx__upper_susar();
                edict.insert("^giguna__carnelian__ctx__upper_susar", format!("{:?}", r));
                (r, vec!["^giguna__carnelian__ctx__upper_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__clouds__ctx__platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform and $activate
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__clouds__ctx__platform();
                edict.insert("^giguna__clouds__ctx__platform", format!("{:?}", r));
                (r, vec!["^giguna__clouds__ctx__platform"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                edict.insert("$activate", format!("{:?}", res));
                refs.push("$activate");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__clouds__ctx__platform_and_invoke_activate_and_invoke_attract_and_breach_sight_and_remote_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform and $activate and $attract and Breach_Sight and Remote_Drone
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let val = {
                            let r = ctx.giguna__clouds__ctx__platform();
                            edict.insert("^giguna__clouds__ctx__platform", format!("{:?}", r));
                            (r, vec!["^giguna__clouds__ctx__platform"])
                        };
                        (!val.0, val.1)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                            edict.insert("$activate", format!("{:?}", res));
                            refs.push("$activate");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                        edict.insert("$attract", format!("{:?}", res));
                        refs.push("$attract");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Breach_Sight);
                    edict.insert("Breach_Sight", format!("{}", h));
                    (h, vec!["Breach_Sight"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Remote_Drone);
                edict.insert("Remote_Drone", format!("{}", h));
                (h, vec!["Remote_Drone"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__clouds__ctx__platform_and_invoke_activate_and_invoke_can_deploy_and_invoke_attract_and_breach_sight(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform and $activate and $can_deploy and $attract and Breach_Sight
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let val = {
                            let r = ctx.giguna__clouds__ctx__platform();
                            edict.insert("^giguna__clouds__ctx__platform", format!("{:?}", r));
                            (r, vec!["^giguna__clouds__ctx__platform"])
                        };
                        (!val.0, val.1)
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                            edict.insert("$activate", format!("{:?}", res));
                            refs.push("$activate");
                            (res, refs)
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                        edict.insert("$can_deploy", format!("{:?}", res));
                        refs.push("$can_deploy");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                    edict.insert("$attract", format!("{:?}", res));
                    refs.push("$attract");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Breach_Sight);
                edict.insert("Breach_Sight", format!("{}", h));
                (h, vec!["Breach_Sight"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_combo_entered
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__combo_entered();
            edict.insert(
                "^giguna__east_caverns__ctx__combo_entered",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__combo_entered"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__east_caverns__ctx__door_opened_and_invoke_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened and $open and $range2
    {
        let mut left = {
            let mut left = {
                let val = {
                    let r = ctx.giguna__east_caverns__ctx__door_opened();
                    edict.insert(
                        "^giguna__east_caverns__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__east_caverns__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__open!(ctx, world, edict);
                    edict.insert("$open", format!("{:?}", res));
                    refs.push("$open");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range2!(ctx, world, edict);
                edict.insert("$range2", format!("{:?}", res));
                refs.push("$range2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__east_caverns__ctx__door_opened_and_invoke_unlock2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened and $unlock2
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__door_opened();
                edict.insert(
                    "^giguna__east_caverns__ctx__door_opened",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__door_opened"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__unlock2!(ctx, world, edict);
                edict.insert("$unlock2", format!("{:?}", res));
                refs.push("$unlock2");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__east_caverns__ctx__door_opened_and_invoke_unlock2_and_invoke_range1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened and $unlock2 and $range1
    {
        let mut left = {
            let mut left = {
                let val = {
                    let r = ctx.giguna__east_caverns__ctx__door_opened();
                    edict.insert(
                        "^giguna__east_caverns__ctx__door_opened",
                        format!("{:?}", r),
                    );
                    (r, vec!["^giguna__east_caverns__ctx__door_opened"])
                };
                (!val.0, val.1)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__unlock2!(ctx, world, edict);
                    edict.insert("$unlock2", format!("{:?}", res));
                    refs.push("$unlock2");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__range1!(ctx, world, edict);
                edict.insert("$range1", format!("{:?}", res));
                refs.push("$range1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__east_caverns__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__lower_susar();
            edict.insert(
                "^giguna__east_caverns__ctx__lower_susar",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__east_caverns__ctx__lower_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_lower_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__lower_susar();
                edict.insert(
                    "^giguna__east_caverns__ctx__lower_susar",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__lower_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_mid_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__mid_susar();
            edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
            (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__east_caverns__ctx__mid_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_mid_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__mid_susar();
                edict.insert("^giguna__east_caverns__ctx__mid_susar", format!("{:?}", r));
                (r, vec!["^giguna__east_caverns__ctx__mid_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__east_caverns__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar
    {
        let val = {
            let r = ctx.giguna__east_caverns__ctx__upper_susar();
            edict.insert(
                "^giguna__east_caverns__ctx__upper_susar",
                format!("{:?}", r),
            );
            (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__east_caverns__ctx__upper_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_upper_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__east_caverns__ctx__upper_susar();
                edict.insert(
                    "^giguna__east_caverns__ctx__upper_susar",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__east_caverns__ctx__upper_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__ruins_west__ctx__kishib_handled_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_kishib_handled and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__ruins_west__ctx__kishib_handled();
                edict.insert(
                    "^giguna__ruins_west__ctx__kishib_handled",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__ruins_west__ctx__kishib_handled"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__ruins_west__ctx__kishib_handled_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_kishib_handled and $shockwave
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__ruins_west__ctx__kishib_handled();
                edict.insert(
                    "^giguna__ruins_west__ctx__kishib_handled",
                    format!("{:?}", r),
                );
                (r, vec!["^giguna__ruins_west__ctx__kishib_handled"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna__west_caverns__ctx__east_susar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_east_susar
    {
        let val = {
            let r = ctx.giguna__west_caverns__ctx__east_susar();
            edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
            (r, vec!["^giguna__west_caverns__ctx__east_susar"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_giguna__west_caverns__ctx__east_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_east_susar and $allegiance1
    {
        let mut left = {
            let val = {
                let r = ctx.giguna__west_caverns__ctx__east_susar();
                edict.insert("^giguna__west_caverns__ctx__east_susar", format!("{:?}", r));
                (r, vec!["^giguna__west_caverns__ctx__east_susar"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__allegiance1!(ctx, world, edict);
                edict.insert("$allegiance1", format!("{:?}", res));
                refs.push("$allegiance1");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_giguna_breach__sw_save__ctx__door_opened(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door_opened
    {
        let val = {
            let r = ctx.giguna_breach__sw_save__ctx__door_opened();
            edict.insert(
                "^giguna_breach__sw_save__ctx__door_opened",
                format!("{:?}", r),
            );
            (r, vec!["^giguna_breach__sw_save__ctx__door_opened"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_glacier__lonely_bull__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_door and Nanite_Mist
    {
        let mut left = {
            let val = {
                let r = ctx.glacier__lonely_bull__ctx__door();
                edict.insert("^glacier__lonely_bull__ctx__door", format!("{:?}", r));
                (r, vec!["^glacier__lonely_bull__ctx__door"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_hammond_auth(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Hammond_Auth
    {
        let h = ctx.has(Item::Hammond_Auth);
        edict.insert("Hammond_Auth", format!("{}", h));
        (!h, vec!["Hammond_Auth"])
    }
}
pub fn explain_not_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not $hook
    {
        let (res, mut refs) = hexplain__hook!(ctx, world, edict);
        edict.insert("not$hook", format!("{:?}", res));
        refs.push("not$hook");
        (!res, refs)
    }
}
pub fn explain_not_irikar__basement_portal__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_platform_moved
    {
        let val = {
            let r = ctx.irikar__basement_portal__ctx__platform_moved();
            edict.insert(
                "^irikar__basement_portal__ctx__platform_moved",
                format!("{:?}", r),
            );
            (r, vec!["^irikar__basement_portal__ctx__platform_moved"])
        };
        (!val.0, val.1)
    }
}
pub fn explain_not_irikar__midwest__ctx__left_platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_left_platform and $activate
    {
        let mut left = {
            let val = {
                let r = ctx.irikar__midwest__ctx__left_platform();
                edict.insert("^irikar__midwest__ctx__left_platform", format!("{:?}", r));
                (r, vec!["^irikar__midwest__ctx__left_platform"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                edict.insert("$activate", format!("{:?}", res));
                refs.push("$activate");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar__midwest__ctx__left_platform_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_left_platform and Nanite_Mist
    {
        let mut left = {
            let val = {
                let r = ctx.irikar__midwest__ctx__left_platform();
                edict.insert("^irikar__midwest__ctx__left_platform", format!("{:?}", r));
                (r, vec!["^irikar__midwest__ctx__left_platform"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar__midwest__ctx__right_platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_right_platform and $activate
    {
        let mut left = {
            let val = {
                let r = ctx.irikar__midwest__ctx__right_platform();
                edict.insert("^irikar__midwest__ctx__right_platform", format!("{:?}", r));
                (r, vec!["^irikar__midwest__ctx__right_platform"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__activate!(ctx, world, edict);
                edict.insert("$activate", format!("{:?}", res));
                refs.push("$activate");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar__midwest__ctx__right_platform_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not ^_right_platform and Nanite_Mist
    {
        let mut left = {
            let val = {
                let r = ctx.irikar__midwest__ctx__right_platform();
                edict.insert("^irikar__midwest__ctx__right_platform", format!("{:?}", r));
                (r, vec!["^irikar__midwest__ctx__right_platform"])
            };
            (!val.0, val.1)
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar_royal_storage_wall_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Irikar_Royal_Storage_Wall and $shockwave
    {
        let mut left = {
            let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
            edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
            (!h, vec!["Irikar_Royal_Storage_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                edict.insert("$shockwave", format!("{:?}", res));
                refs.push("$shockwave");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar_royal_storage_wall_and_invoke_shockwave_and_not_invoke_visited__irikar_gt_hub_gt_collapsed_column_gt_shockwave_to_get_item(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Irikar_Royal_Storage_Wall and $shockwave and not $visited(`Irikar > Hub > Collapsed Column > Shockwave to Get Item`)
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
                edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
                (!h, vec!["Irikar_Royal_Storage_Wall"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__shockwave!(ctx, world, edict);
                    edict.insert("$shockwave", format!("{:?}", res));
                    refs.push("$shockwave");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let res =
                    ctx.visited(LocationId::Irikar__Hub__Collapsed_Column__Shockwave_to_Get_Item);
                edict.insert(
                    "not$visited(`Irikar > Hub > Collapsed Column > Shockwave to Get Item`)",
                    format!("{:?}", res),
                );
                (
                    !res,
                    vec!["not$visited(`Irikar > Hub > Collapsed Column > Shockwave to Get Item`)"],
                )
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_irikar_royal_storage_wall_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Irikar_Royal_Storage_Wall and Nanite_Mist
    {
        let mut left = {
            let h = ctx.has(Item::Irikar_Royal_Storage_Wall);
            edict.insert("Irikar_Royal_Storage_Wall", format!("{}", h));
            (!h, vec!["Irikar_Royal_Storage_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_mist_upgrade(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Mist_Upgrade
    {
        let h = ctx.has(Item::Mist_Upgrade);
        edict.insert("Mist_Upgrade", format!("{}", h));
        (!h, vec!["Mist_Upgrade"])
    }
}
pub fn explain_not_separation_or_defeat_indra(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT Separation or Defeat_Indra
    {
        let mut left = {
            let h = ctx.has(Item::Separation);
            edict.insert("Separation", format!("{}", h));
            (!h, vec!["Separation"])
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Defeat_Indra);
                edict.insert("Defeat_Indra", format!("{}", h));
                (h, vec!["Defeat_Indra"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Slingshot_Hook
    {
        let h = ctx.has(Item::Slingshot_Hook);
        edict.insert("Slingshot_Hook", format!("{}", h));
        (!h, vec!["Slingshot_Hook"])
    }
}
pub fn explain_not_slingshot_weapon(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // not Slingshot_Weapon
    {
        let h = ctx.has(Item::Slingshot_Weapon);
        edict.insert("Slingshot_Weapon", format!("{}", h));
        (!h, vec!["Slingshot_Weapon"])
    }
}
pub fn explain_not_within_menu_and_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and Anuman and ^mode != 'drone'
    {
        let mut left = {
            let mut left = {
                let r = ctx.position();
                edict.insert("^position", format!("{:?}", r));
                (
                    match get_region(r) {
                        RegionId::Menu => false,
                        _ => true,
                    },
                    vec!["^position"],
                )
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 != right, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_flasks_gt_0(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and ^flasks > 0
    {
        let mut left = {
            let r = ctx.position();
            edict.insert("^position", format!("{:?}", r));
            (
                match get_region(r) {
                    RegionId::Menu => false,
                    _ => true,
                },
                vec!["^position"],
            )
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^flasks", "0"];
                let mut left = {
                    let r = ctx.flasks();
                    edict.insert("^flasks", format!("{:?}", r));
                    (r, vec!["^flasks"])
                };
                let mut right = (0, vec![]);
                edict.insert("^flasks", format!("{:?}", left.0));
                edict.insert("0", format!("{:?}", right.0));
                refs.append(&mut left.1);
                refs.append(&mut right.1);
                (Into::<i32>::into(left.0) > right.0.into(), refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_invoke_attract_and_portal_ne_invoke_default_and_portal_ne_position(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and $attract and ^portal != $default and ^portal != ^position
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let r = ctx.position();
                    edict.insert("^position", format!("{:?}", r));
                    (
                        match get_region(r) {
                            RegionId::Menu => false,
                            _ => true,
                        },
                        vec!["^position"],
                    )
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__attract!(ctx, world, edict);
                        edict.insert("$attract", format!("{:?}", res));
                        refs.push("$attract");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut left = {
                        let r = ctx.portal();
                        edict.insert("^portal", format!("{:?}", r));
                        (r, vec!["^portal"])
                    };
                    let mut right = (Default::default(), vec![]);
                    left.1.append(&mut right.1);
                    (left.0 != right.0, left.1)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut left = {
                    let r = ctx.portal();
                    edict.insert("^portal", format!("{:?}", r));
                    (r, vec!["^portal"])
                };
                let mut right = {
                    let r = ctx.position();
                    edict.insert("^position", format!("{:?}", r));
                    (r, vec!["^position"])
                };
                left.1.append(&mut right.1);
                (left.0 != right.0, left.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_invoke_can_deploy(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and $can_deploy
    {
        let mut left = {
            let r = ctx.position();
            edict.insert("^position", format!("{:?}", r));
            (
                match get_region(r) {
                    RegionId::Menu => false,
                    _ => true,
                },
                vec!["^position"],
            )
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_deploy!(ctx, world, edict);
                edict.insert("$can_deploy", format!("{:?}", res));
                refs.push("$can_deploy");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_realm_ne_breach_and_anuman_and_mode_eq_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and ^realm != 'breach' and Anuman and ^mode == 'drone'
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let r = ctx.position();
                    edict.insert("^position", format!("{:?}", r));
                    (
                        match get_region(r) {
                            RegionId::Menu => false,
                            _ => true,
                        },
                        vec!["^position"],
                    )
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let mut refs = vec!["^realm"];
                        let mut left = {
                            let r = data::realm(ctx.position());
                            edict.insert("^realm", format!("{:?}", r));
                            (r, vec!["^realm"])
                        };
                        let right = enums::Realm::Breach;
                        edict.insert("^realm", format!("{}", left.0));
                        refs.append(&mut left.1);
                        (left.0 != right, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Anuman);
                    edict.insert("Anuman", format!("{}", h));
                    (h, vec!["Anuman"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut refs = vec!["^mode"];
                let mut left = {
                    let r = ctx.mode();
                    edict.insert("^mode", format!("{:?}", r));
                    (r, vec!["^mode"])
                };
                let right = enums::Mode::Drone;
                edict.insert("^mode", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_not_within_menu_and_realm_ne_breach_and_invoke_can_recall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // NOT WITHIN `Menu` and ^realm != 'breach' and $can_recall
    {
        let mut left = {
            let mut left = {
                let r = ctx.position();
                edict.insert("^position", format!("{:?}", r));
                (
                    match get_region(r) {
                        RegionId::Menu => false,
                        _ => true,
                    },
                    vec!["^position"],
                )
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let mut refs = vec!["^realm"];
                    let mut left = {
                        let r = data::realm(ctx.position());
                        edict.insert("^realm", format!("{:?}", r));
                        (r, vec!["^realm"])
                    };
                    let right = enums::Realm::Breach;
                    edict.insert("^realm", format!("{}", left.0));
                    refs.append(&mut left.1);
                    (left.0 != right, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__can_recall!(ctx, world, edict);
                edict.insert("$can_recall", format!("{:?}", res));
                refs.push("$can_recall");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_portal_eq_position(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^portal == ^position
    {
        let mut left = {
            let r = ctx.portal();
            edict.insert("^portal", format!("{:?}", r));
            (r, vec!["^portal"])
        };
        let mut right = {
            let r = ctx.position();
            edict.insert("^position", format!("{:?}", r));
            (r, vec!["^position"])
        };
        left.1.append(&mut right.1);
        (left.0 == right.0, left.1)
    }
}
pub fn explain_portal_hidden(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^portal_hidden
    {
        let r = data::portal_hidden(ctx.position());
        edict.insert("^portal_hidden", format!("{:?}", r));
        (r, vec!["^portal_hidden"])
    }
}
pub fn explain_ranged_damage(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Damage
    {
        let h = ctx.has(Item::Ranged_Damage);
        edict.insert("Ranged_Damage", format!("{}", h));
        (h, vec!["Ranged_Damage"])
    }
}
pub fn explain_ranged_damage_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Damage_2
    {
        let h = ctx.has(Item::Ranged_Damage_2);
        edict.insert("Ranged_Damage_2", format!("{}", h));
        (h, vec!["Ranged_Damage_2"])
    }
}
pub fn explain_ranged_speed(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Speed
    {
        let h = ctx.has(Item::Ranged_Speed);
        edict.insert("Ranged_Speed", format!("{}", h));
        (h, vec!["Ranged_Speed"])
    }
}
pub fn explain_ranged_speed_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Ranged_Speed_2
    {
        let h = ctx.has(Item::Ranged_Speed_2);
        edict.insert("Ranged_Speed_2", format!("{}", h));
        (h, vec!["Ranged_Speed_2"])
    }
}
pub fn explain_realm_eq_breach_and_exit_breach_and_flipside_ne_invoke_default(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // ^realm == 'breach' and Exit_Breach and ^flipside != $default
    {
        let mut left = {
            let mut left = {
                let mut refs = vec!["^realm"];
                let mut left = {
                    let r = data::realm(ctx.position());
                    edict.insert("^realm", format!("{:?}", r));
                    (r, vec!["^realm"])
                };
                let right = enums::Realm::Breach;
                edict.insert("^realm", format!("{}", left.0));
                refs.append(&mut left.1);
                (left.0 == right, refs)
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Exit_Breach);
                    edict.insert("Exit_Breach", format!("{}", h));
                    (h, vec!["Exit_Breach"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let mut left = {
                    let r = data::flipside(ctx.position());
                    edict.insert("^flipside", format!("{:?}", r));
                    (r, vec!["^flipside"])
                };
                let mut right = (Default::default(), vec![]);
                left.1.append(&mut right.1);
                (left.0 != right.0, left.1)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_remote_drone(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Remote_Drone
    {
        let h = ctx.has(Item::Remote_Drone);
        edict.insert("Remote_Drone", format!("{}", h));
        (h, vec!["Remote_Drone"])
    }
}
pub fn explain_robopede(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Robopede
    {
        let h = ctx.has(Item::Robopede);
        edict.insert("Robopede", format!("{}", h));
        (h, vec!["Robopede"])
    }
}
pub fn explain_separation(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Separation
    {
        let h = ctx.has(Item::Separation);
        edict.insert("Separation", format!("{}", h));
        (h, vec!["Separation"])
    }
}
pub fn explain_separation_and_not_defeat_indra_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Separation and NOT Defeat_Indra and Nanite_Mist
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Separation);
                edict.insert("Separation", format!("{}", h));
                (h, vec!["Separation"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Defeat_Indra);
                    edict.insert("Defeat_Indra", format!("{}", h));
                    (!h, vec!["Defeat_Indra"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_siuna_storage_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Siuna_Storage_Wall
    {
        let h = ctx.has(Item::Siuna_Storage_Wall);
        edict.insert("Siuna_Storage_Wall", format!("{}", h));
        (h, vec!["Siuna_Storage_Wall"])
    }
}
pub fn explain_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook
    {
        let h = ctx.has(Item::Slingshot_Hook);
        edict.insert("Slingshot_Hook", format!("{}", h));
        (h, vec!["Slingshot_Hook"])
    }
}
pub fn explain_slingshot_hook_and___not_slingshot_weapon_or_invoke_visited__irikar_breach_gt_gauntlet_gt_hidden_path_reward_gt_item(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and (not Slingshot_Weapon or $visited(`Irikar Breach > Gauntlet > Hidden Path Reward > Item`))
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Slingshot_Weapon);
                    edict.insert("Slingshot_Weapon", format!("{}", h));
                    (!h, vec!["Slingshot_Weapon"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let res = ctx
                            .visited(LocationId::Irikar_Breach__Gauntlet__Hidden_Path_Reward__Item);
                        edict.insert(
                            "$visited(`Irikar Breach > Gauntlet > Hidden Path Reward > Item`)",
                            format!("{:?}", res),
                        );
                        (
                            res,
                            vec![
                                "$visited(`Irikar Breach > Gauntlet > Hidden Path Reward > Item`)",
                            ],
                        )
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and___slingshot_weapon_or_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and (Slingshot_Weapon or Drone_Hover)
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Slingshot_Weapon);
                    edict.insert("Slingshot_Weapon", format!("{}", h));
                    (h, vec!["Slingshot_Weapon"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Drone_Hover);
                        edict.insert("Drone_Hover", format!("{}", h));
                        (h, vec!["Drone_Hover"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover_and_ebih_breach_in_n_out_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover and Ebih_Breach_In_n_Out_Gate
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Breach_In_n_Out_Gate);
                edict.insert("Ebih_Breach_In_n_Out_Gate", format!("{}", h));
                (h, vec!["Ebih_Breach_In_n_Out_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover_and_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover and Ebih_Breach_Rock_Block_Rock
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Breach_Rock_Block_Rock);
                edict.insert("Ebih_Breach_Rock_Block_Rock", format!("{}", h));
                (h, vec!["Ebih_Breach_Rock_Block_Rock"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover and Giguna_Breach_Crab_Rave_Gate
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Breach_Crab_Rave_Gate);
                edict.insert("Giguna_Breach_Crab_Rave_Gate", format!("{}", h));
                (h, vec!["Giguna_Breach_Crab_Rave_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover_and_infect_l1_and_drone_melee_damage_2_and_drone_melee_speed_2(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover and Infect_L1 and Drone_Melee_Damage_2 and Drone_Melee_Speed_2
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let mut left = {
                        let h = ctx.has(Item::Slingshot_Hook);
                        edict.insert("Slingshot_Hook", format!("{}", h));
                        (h, vec!["Slingshot_Hook"])
                    };
                    if !left.0 {
                        left
                    } else {
                        let mut right = {
                            let h = ctx.has(Item::Drone_Hover);
                            edict.insert("Drone_Hover", format!("{}", h));
                            (h, vec!["Drone_Hover"])
                        };
                        left.1.append(&mut right.1);
                        (right.0, left.1)
                    }
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Infect_L1);
                        edict.insert("Infect_L1", format!("{}", h));
                        (h, vec!["Infect_L1"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Melee_Damage_2);
                    edict.insert("Drone_Melee_Damage_2", format!("{}", h));
                    (h, vec!["Drone_Melee_Damage_2"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Melee_Speed_2);
                edict.insert("Drone_Melee_Speed_2", format!("{}", h));
                (h, vec!["Drone_Melee_Speed_2"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover_and_not_irikar_breach_buried_treasure_pillar(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover and not Irikar_Breach_Buried_Treasure_Pillar
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Irikar_Breach_Buried_Treasure_Pillar);
                edict.insert("Irikar_Breach_Buried_Treasure_Pillar", format!("{}", h));
                (!h, vec!["Irikar_Breach_Buried_Treasure_Pillar"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_hover_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Hover and Slingshot_Weapon
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Weapon);
                edict.insert("Slingshot_Weapon", format!("{}", h));
                (h, vec!["Slingshot_Weapon"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_drone_melee_damage_3(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Drone_Melee_Damage_3
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Melee_Damage_3);
                edict.insert("Drone_Melee_Damage_3", format!("{}", h));
                (h, vec!["Drone_Melee_Damage_3"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_ebih_breach_lake_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Ebih_Breach_Lake_Gate
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Breach_Lake_Gate);
                edict.insert("Ebih_Breach_Lake_Gate", format!("{}", h));
                (h, vec!["Ebih_Breach_Lake_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Ebih_Breach_Rock_Block_Rock
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Ebih_Breach_Rock_Block_Rock);
                edict.insert("Ebih_Breach_Rock_Block_Rock", format!("{}", h));
                (h, vec!["Ebih_Breach_Rock_Block_Rock"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Giguna_Breach_Crab_Rave_Gate
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Breach_Crab_Rave_Gate);
                edict.insert("Giguna_Breach_Crab_Rave_Gate", format!("{}", h));
                (h, vec!["Giguna_Breach_Crab_Rave_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_giguna_breach_gate_and_wall_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Giguna_Breach_Gate_and_Wall_Gate
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Breach_Gate_and_Wall_Gate);
                edict.insert("Giguna_Breach_Gate_and_Wall_Gate", format!("{}", h));
                (h, vec!["Giguna_Breach_Gate_and_Wall_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_slingshot_charge(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Slingshot_Charge
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Charge);
                edict.insert("Slingshot_Charge", format!("{}", h));
                (h, vec!["Slingshot_Charge"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_slingshot_charge_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Slingshot_Charge and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Charge);
                    edict.insert("Slingshot_Charge", format!("{}", h));
                    (h, vec!["Slingshot_Charge"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Slingshot_Weapon
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Weapon);
                edict.insert("Slingshot_Weapon", format!("{}", h));
                (h, vec!["Slingshot_Weapon"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_slingshot_weapon_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Slingshot_Weapon and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Weapon);
                    edict.insert("Slingshot_Weapon", format!("{}", h));
                    (h, vec!["Slingshot_Weapon"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_and_slingshot_weapon_and_drone_hover_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook and Slingshot_Weapon and Drone_Hover and Giguna_Breach_Crab_Rave_Gate
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Slingshot_Weapon);
                        edict.insert("Slingshot_Weapon", format!("{}", h));
                        (h, vec!["Slingshot_Weapon"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Giguna_Breach_Crab_Rave_Gate);
                edict.insert("Giguna_Breach_Crab_Rave_Gate", format!("{}", h));
                (h, vec!["Giguna_Breach_Crab_Rave_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_slingshot_hook_or_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Slingshot_Hook or Drone_Hover
    {
        let mut left = {
            let h = ctx.has(Item::Slingshot_Hook);
            edict.insert("Slingshot_Hook", format!("{}", h));
            (h, vec!["Slingshot_Hook"])
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_sniper_valley_rock_1(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Sniper_Valley_Rock_1
    {
        let h = ctx.has(Item::Sniper_Valley_Rock_1);
        edict.insert("Sniper_Valley_Rock_1", format!("{}", h));
        (h, vec!["Sniper_Valley_Rock_1"])
    }
}
pub fn explain_station_power(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Station_Power
    {
        let h = ctx.has(Item::Station_Power);
        edict.insert("Station_Power", format!("{}", h));
        (h, vec!["Station_Power"])
    }
}
pub fn explain_switch_36_11(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Switch_36_11
    {
        let h = ctx.has(Item::Switch_36_11);
        edict.insert("Switch_36_11", format!("{}", h));
        (h, vec!["Switch_36_11"])
    }
}
pub fn explain_switch_40_12(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Switch_40_12
    {
        let h = ctx.has(Item::Switch_40_12);
        edict.insert("Switch_40_12", format!("{}", h));
        (h, vec!["Switch_40_12"])
    }
}
pub fn explain_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Annuna_Corridor_Block
    {
        let h = ctx.has(Item::Uhrum_Annuna_Corridor_Block);
        edict.insert("Uhrum_Annuna_Corridor_Block", format!("{}", h));
        (h, vec!["Uhrum_Annuna_Corridor_Block"])
    }
}
pub fn explain_uhrum_breach_annuna_gate_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Annuna_Gate_Gate
    {
        let h = ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate);
        edict.insert("Uhrum_Breach_Annuna_Gate_Gate", format!("{}", h));
        (h, vec!["Uhrum_Breach_Annuna_Gate_Gate"])
    }
}
pub fn explain_uhrum_breach_annuna_gate_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Annuna_Gate_Gate and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate);
            edict.insert("Uhrum_Breach_Annuna_Gate_Gate", format!("{}", h));
            (h, vec!["Uhrum_Breach_Annuna_Gate_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_breach_annuna_gate_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Annuna_Gate_Gate and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate);
                edict.insert("Uhrum_Breach_Annuna_Gate_Gate", format!("{}", h));
                (h, vec!["Uhrum_Breach_Annuna_Gate_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_breach_locked_down_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Locked_Down_Gate
    {
        let h = ctx.has(Item::Uhrum_Breach_Locked_Down_Gate);
        edict.insert("Uhrum_Breach_Locked_Down_Gate", format!("{}", h));
        (h, vec!["Uhrum_Breach_Locked_Down_Gate"])
    }
}
pub fn explain_uhrum_breach_locked_down_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Locked_Down_Gate and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Breach_Locked_Down_Gate);
            edict.insert("Uhrum_Breach_Locked_Down_Gate", format!("{}", h));
            (h, vec!["Uhrum_Breach_Locked_Down_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_breach_overgrown_ruins_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Overgrown_Ruins_Wall
    {
        let h = ctx.has(Item::Uhrum_Breach_Overgrown_Ruins_Wall);
        edict.insert("Uhrum_Breach_Overgrown_Ruins_Wall", format!("{}", h));
        (h, vec!["Uhrum_Breach_Overgrown_Ruins_Wall"])
    }
}
pub fn explain_uhrum_breach_rock_and_gate_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Rock_and_Gate_Gate
    {
        let h = ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Gate);
        edict.insert("Uhrum_Breach_Rock_and_Gate_Gate", format!("{}", h));
        (h, vec!["Uhrum_Breach_Rock_and_Gate_Gate"])
    }
}
pub fn explain_uhrum_breach_rock_and_gate_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Rock_and_Gate_Gate and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Gate);
                edict.insert("Uhrum_Breach_Rock_and_Gate_Gate", format!("{}", h));
                (h, vec!["Uhrum_Breach_Rock_and_Gate_Gate"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_breach_rock_and_gate_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Rock_and_Gate_Rock
    {
        let h = ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Rock);
        edict.insert("Uhrum_Breach_Rock_and_Gate_Rock", format!("{}", h));
        (h, vec!["Uhrum_Breach_Rock_and_Gate_Rock"])
    }
}
pub fn explain_uhrum_breach_rock_and_gate_rock_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Breach_Rock_and_Gate_Rock and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Rock);
            edict.insert("Uhrum_Breach_Rock_and_Gate_Rock", format!("{}", h));
            (h, vec!["Uhrum_Breach_Rock_and_Gate_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_cavern_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Cavern_Wall
    {
        let h = ctx.has(Item::Uhrum_Cavern_Wall);
        edict.insert("Uhrum_Cavern_Wall", format!("{}", h));
        (h, vec!["Uhrum_Cavern_Wall"])
    }
}
pub fn explain_uhrum_cavern_wall_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Cavern_Wall and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Cavern_Wall);
            edict.insert("Uhrum_Cavern_Wall", format!("{}", h));
            (h, vec!["Uhrum_Cavern_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_east_glitch(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_East_Glitch
    {
        let h = ctx.has(Item::Uhrum_East_Glitch);
        edict.insert("Uhrum_East_Glitch", format!("{}", h));
        (h, vec!["Uhrum_East_Glitch"])
    }
}
pub fn explain_uhrum_east_lake_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_East_Lake_Block
    {
        let h = ctx.has(Item::Uhrum_East_Lake_Block);
        edict.insert("Uhrum_East_Lake_Block", format!("{}", h));
        (h, vec!["Uhrum_East_Lake_Block"])
    }
}
pub fn explain_uhrum_east_lake_block_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_East_Lake_Block and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_East_Lake_Block);
            edict.insert("Uhrum_East_Lake_Block", format!("{}", h));
            (h, vec!["Uhrum_East_Lake_Block"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_emergence_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Emergence_Wall
    {
        let h = ctx.has(Item::Uhrum_Emergence_Wall);
        edict.insert("Uhrum_Emergence_Wall", format!("{}", h));
        (h, vec!["Uhrum_Emergence_Wall"])
    }
}
pub fn explain_uhrum_emergence_wall_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Emergence_Wall and $hook and $hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Uhrum_Emergence_Wall);
                edict.insert("Uhrum_Emergence_Wall", format!("{}", h));
                (h, vec!["Uhrum_Emergence_Wall"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_emergence_wall_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Emergence_Wall and $hover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Emergence_Wall);
            edict.insert("Uhrum_Emergence_Wall", format!("{}", h));
            (h, vec!["Uhrum_Emergence_Wall"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_glitchy_corridor_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Glitchy_Corridor_Rock
    {
        let h = ctx.has(Item::Uhrum_Glitchy_Corridor_Rock);
        edict.insert("Uhrum_Glitchy_Corridor_Rock", format!("{}", h));
        (h, vec!["Uhrum_Glitchy_Corridor_Rock"])
    }
}
pub fn explain_uhrum_glitchy_corridor_rock_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Glitchy_Corridor_Rock and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Glitchy_Corridor_Rock);
            edict.insert("Uhrum_Glitchy_Corridor_Rock", format!("{}", h));
            (h, vec!["Uhrum_Glitchy_Corridor_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_glitchy_corridor_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Glitchy_Corridor_Rock and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Glitchy_Corridor_Rock);
            edict.insert("Uhrum_Glitchy_Corridor_Rock", format!("{}", h));
            (h, vec!["Uhrum_Glitchy_Corridor_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_rocky_gate_rock(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Rocky_Gate_Rock
    {
        let h = ctx.has(Item::Uhrum_Rocky_Gate_Rock);
        edict.insert("Uhrum_Rocky_Gate_Rock", format!("{}", h));
        (h, vec!["Uhrum_Rocky_Gate_Rock"])
    }
}
pub fn explain_uhrum_rocky_gate_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Rocky_Gate_Rock and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Rocky_Gate_Rock);
            edict.insert("Uhrum_Rocky_Gate_Rock", format!("{}", h));
            (h, vec!["Uhrum_Rocky_Gate_Rock"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_waterfall_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfall_Wall
    {
        let h = ctx.has(Item::Uhrum_Waterfall_Wall);
        edict.insert("Uhrum_Waterfall_Wall", format!("{}", h));
        (h, vec!["Uhrum_Waterfall_Wall"])
    }
}
pub fn explain_uhrum_waterfalls_block(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfalls_Block
    {
        let h = ctx.has(Item::Uhrum_Waterfalls_Block);
        edict.insert("Uhrum_Waterfalls_Block", format!("{}", h));
        (h, vec!["Uhrum_Waterfalls_Block"])
    }
}
pub fn explain_uhrum_waterfalls_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfalls_Block and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Waterfalls_Block);
            edict.insert("Uhrum_Waterfalls_Block", format!("{}", h));
            (h, vec!["Uhrum_Waterfalls_Block"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_waterfalls_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_Waterfalls_Block and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_Waterfalls_Block);
            edict.insert("Uhrum_Waterfalls_Block", format!("{}", h));
            (h, vec!["Uhrum_Waterfalls_Block"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_west_entrance_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Gate
    {
        let h = ctx.has(Item::Uhrum_West_Entrance_Gate);
        edict.insert("Uhrum_West_Entrance_Gate", format!("{}", h));
        (h, vec!["Uhrum_West_Entrance_Gate"])
    }
}
pub fn explain_uhrum_west_entrance_gate_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Gate and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_West_Entrance_Gate);
            edict.insert("Uhrum_West_Entrance_Gate", format!("{}", h));
            (h, vec!["Uhrum_West_Entrance_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_west_entrance_gate_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Gate and $hover
    {
        let mut left = {
            let h = ctx.has(Item::Uhrum_West_Entrance_Gate);
            edict.insert("Uhrum_West_Entrance_Gate", format!("{}", h));
            (h, vec!["Uhrum_West_Entrance_Gate"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_uhrum_west_entrance_lower_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Lower_Wall
    {
        let h = ctx.has(Item::Uhrum_West_Entrance_Lower_Wall);
        edict.insert("Uhrum_West_Entrance_Lower_Wall", format!("{}", h));
        (h, vec!["Uhrum_West_Entrance_Lower_Wall"])
    }
}
pub fn explain_uhrum_west_entrance_upper_wall(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Entrance_Upper_Wall
    {
        let h = ctx.has(Item::Uhrum_West_Entrance_Upper_Wall);
        edict.insert("Uhrum_West_Entrance_Upper_Wall", format!("{}", h));
        (h, vec!["Uhrum_West_Entrance_Upper_Wall"])
    }
}
pub fn explain_uhrum_west_glitch(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Uhrum_West_Glitch
    {
        let h = ctx.has(Item::Uhrum_West_Glitch);
        edict.insert("Uhrum_West_Glitch", format!("{}", h));
        (h, vec!["Uhrum_West_Glitch"])
    }
}
pub fn explain_underwater_movement(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement
    {
        let h = ctx.has(Item::Underwater_Movement);
        edict.insert("Underwater_Movement", format!("{}", h));
        (h, vec!["Underwater_Movement"])
    }
}
pub fn explain_underwater_movement_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and ($grab or $climb)
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                        edict.insert("$climb", format!("{:?}", res));
                        refs.push("$climb");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and___invoke_hook_or_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and ($hook or $hover)
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                        edict.insert("$hover", format!("{:?}", res));
                        refs.push("$hover");
                        (res, refs)
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and___slingshot_hook_or_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and (Slingshot_Hook or Drone_Hover)
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = ({
                let mut left = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                if left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Drone_Hover);
                        edict.insert("Drone_Hover", format!("{}", h));
                        (h, vec!["Drone_Hover"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            });
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_amagi_breach_center_ruins_blocks(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Amagi_Breach_Center_Ruins_Blocks
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Amagi_Breach_Center_Ruins_Blocks);
                edict.insert("Amagi_Breach_Center_Ruins_Blocks", format!("{}", h));
                (h, vec!["Amagi_Breach_Center_Ruins_Blocks"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_amagi_breach_lower_hallway_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate);
                edict.insert("Amagi_Breach_Lower_Hallway_Gate", format!("{}", h));
                (h, vec!["Amagi_Breach_Lower_Hallway_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_amagi_breach_lower_hallway_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate and Slingshot_Hook
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate);
                    edict.insert("Amagi_Breach_Lower_Hallway_Gate", format!("{}", h));
                    (h, vec!["Amagi_Breach_Lower_Hallway_Gate"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_amagi_breach_lower_hallway_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let mut left = {
                    let h = ctx.has(Item::Underwater_Movement);
                    edict.insert("Underwater_Movement", format!("{}", h));
                    (h, vec!["Underwater_Movement"])
                };
                if !left.0 {
                    left
                } else {
                    let mut right = {
                        let h = ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate);
                        edict.insert("Amagi_Breach_Lower_Hallway_Gate", format!("{}", h));
                        (h, vec!["Amagi_Breach_Lower_Hallway_Gate"])
                    };
                    left.1.append(&mut right.1);
                    (right.0, left.1)
                }
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_amagi_breach_split_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Amagi_Breach_Split_Gate
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Amagi_Breach_Split_Gate);
                edict.insert("Amagi_Breach_Split_Gate", format!("{}", h));
                (h, vec!["Amagi_Breach_Split_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_amagi_wiggly_room_gate(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Amagi_Wiggly_Room_Gate
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Amagi_Wiggly_Room_Gate);
                edict.insert("Amagi_Wiggly_Room_Gate", format!("{}", h));
                (h, vec!["Amagi_Wiggly_Room_Gate"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Drone_Hover
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Drone_Hover and Slingshot_Hook
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Drone_Hover);
                    edict.insert("Drone_Hover", format!("{}", h));
                    (h, vec!["Drone_Hover"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and ^_lower_gatestones
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.glacier__vertical_room__ctx__lower_gatestones();
                edict.insert(
                    "^glacier__vertical_room__ctx__lower_gatestones",
                    format!("{:?}", r),
                );
                (r, vec!["^glacier__vertical_room__ctx__lower_gatestones"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $climb
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_grab(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $grab
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                edict.insert("$grab", format!("{:?}", res));
                refs.push("$grab");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $grab and $climb
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__grab!(ctx, world, edict);
                    edict.insert("$grab", format!("{:?}", res));
                    refs.push("$grab");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__climb!(ctx, world, edict);
                edict.insert("$climb", format!("{:?}", res));
                refs.push("$climb");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $hook
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                edict.insert("$hook", format!("{:?}", res));
                refs.push("$hook");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_hook_and_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $hook and ^_lower_gatestones
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let r = ctx.glacier__vertical_room__ctx__lower_gatestones();
                edict.insert(
                    "^glacier__vertical_room__ctx__lower_gatestones",
                    format!("{:?}", r),
                );
                (r, vec!["^glacier__vertical_room__ctx__lower_gatestones"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $hook and $hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let (res, mut refs) = hexplain__hook!(ctx, world, edict);
                    edict.insert("$hook", format!("{:?}", res));
                    refs.push("$hook");
                    (res, refs)
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $hookhover
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hookhover!(ctx, world, edict);
                edict.insert("$hookhover", format!("{:?}", res));
                refs.push("$hookhover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_invoke_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and $hover
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let (res, mut refs) = hexplain__hover!(ctx, world, edict);
                edict.insert("$hover", format!("{:?}", res));
                refs.push("$hover");
                (res, refs)
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_nanite_mist(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Nanite_Mist
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Nanite_Mist);
                edict.insert("Nanite_Mist", format!("{}", h));
                (h, vec!["Nanite_Mist"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement and Slingshot_Hook and Drone_Hover
    {
        let mut left = {
            let mut left = {
                let h = ctx.has(Item::Underwater_Movement);
                edict.insert("Underwater_Movement", format!("{}", h));
                (h, vec!["Underwater_Movement"])
            };
            if !left.0 {
                left
            } else {
                let mut right = {
                    let h = ctx.has(Item::Slingshot_Hook);
                    edict.insert("Slingshot_Hook", format!("{}", h));
                    (h, vec!["Slingshot_Hook"])
                };
                left.1.append(&mut right.1);
                (right.0, left.1)
            }
        };
        if !left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Drone_Hover);
                edict.insert("Drone_Hover", format!("{}", h));
                (h, vec!["Drone_Hover"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_underwater_movement_or_slingshot_hook(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // Underwater_Movement or Slingshot_Hook
    {
        let mut left = {
            let h = ctx.has(Item::Underwater_Movement);
            edict.insert("Underwater_Movement", format!("{}", h));
            (h, vec!["Underwater_Movement"])
        };
        if left.0 {
            left
        } else {
            let mut right = {
                let h = ctx.has(Item::Slingshot_Hook);
                edict.insert("Slingshot_Hook", format!("{}", h));
                (h, vec!["Slingshot_Hook"])
            };
            left.1.append(&mut right.1);
            (right.0, left.1)
        }
    }
}
pub fn explain_within_menu_gt_upgrade_menu(
    ctx: &Context,
    world: &World,
    edict: &mut FxHashMap<&'static str, String>,
) -> (bool, Vec<&'static str>) {
    // WITHIN `Menu > Upgrade Menu`
    {
        let r = ctx.position();
        edict.insert("^position", format!("{:?}", r));
        (
            match get_area(r) {
                AreaId::Menu__Upgrade_Menu => true,
                _ => false,
            },
            vec!["^position"],
        )
    }
}
pub fn observe_access___bridge_hover_or_slingshot_charge_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // (bridge_hover or Slingshot_Charge) and $hookhover
    ((world.bridge_hover || {
        full_obs.observe_slingshot_charge();
        ctx.has(Item::Slingshot_Charge)
    }) && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access___escape_apocalypse_bomb_invoke_objective(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Escape, Apocalypse_Bomb, $objective]
    ({
        full_obs.observe_escape();
        ctx.has(Item::Escape)
    }) && ({
        full_obs.observe_apocalypse_bomb();
        ctx.has(Item::Apocalypse_Bomb)
    }) && robserve__objective!(ctx, world, full_obs)
}
pub fn observe_access___infect_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Infect, Nanite_Mist]
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    }) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    })
}
pub fn observe_access___invoke_all_urns(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // [$all_urns]
    hobserve__all_urns!(ctx, world, full_obs)
}
pub fn observe_access___invoke_all_urns_invoke_all_weapons_invoke_other_items_invoke_all_notes_invoke_all_health_invoke_all_flasks(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // [$all_urns, $all_weapons, $other_items, $all_notes, $all_health, $all_flasks]
    hobserve__all_urns!(ctx, world, full_obs)
        && hobserve__all_weapons!(ctx, world, full_obs)
        && hobserve__other_items!(ctx, world, full_obs)
        && hobserve__all_notes!(ctx, world, full_obs)
        && hobserve__all_health!(ctx, world, full_obs)
        && hobserve__all_flasks!(ctx, world, full_obs)
}
pub fn observe_access___invoke_grab_and_anuman_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ($grab and Anuman) or $climb
    ((hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
        || hobserve__climb!(ctx, world, full_obs))
}
pub fn observe_access___invoke_grab_or_invoke_climb_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ($grab or $climb) and Underwater_Movement
    ((hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access___invoke_grab_or_invoke_climb_or_invoke_hook_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ($grab or $climb or $hook) and Underwater_Movement
    (((hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))
        || hobserve__hook!(ctx, world, full_obs))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access___invoke_hook_or_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ($hook or $hover) and Underwater_Movement
    ((hobserve__hook!(ctx, world, full_obs) || hobserve__hover!(ctx, world, full_obs))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access___invoke_objective(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // [$objective]
    robserve__objective!(ctx, world, full_obs)
}
pub fn observe_access___remote_drone_flask__6(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // [Remote_Drone, Flask{6}]
    ({
        full_obs.observe_remote_drone();
        ctx.has(Item::Remote_Drone)
    }) && ({
        full_obs.observe_flask(IntegerObservation::Ge(6));
        ctx.count(Item::Flask) >= 6
    })
}
pub fn observe_access_allow_warps_and_invoke_ft_breach_and___map_spot_within_menu_gt_breach_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // allow_warps and $ft_breach and (^map_spot WITHIN `Menu > Breach Map`) and not Apocalypse_Bomb
    (((world.allow_warps && (hobserve__ft_breach!(ctx, world, full_obs)))
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Breach_Map))
        && ({
            full_obs.observe_apocalypse_bomb();
            !ctx.has(Item::Apocalypse_Bomb)
        }))
}
pub fn observe_access_allow_warps_and_invoke_ft_main_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // allow_warps and $ft_main and (^map_spot WITHIN `Menu > Kiengir Map`) and not Apocalypse_Bomb
    (((world.allow_warps && (hobserve__ft_main!(ctx, world, full_obs)))
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Kiengir_Map))
        && ({
            full_obs.observe_apocalypse_bomb();
            !ctx.has(Item::Apocalypse_Bomb)
        }))
}
pub fn observe_access_allow_warps_and_not_within_menu_and_invoke_ft_main_and_invoke_can_recall_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // allow_warps and NOT WITHIN `Menu` and $ft_main and $can_recall and (^map_spot WITHIN `Menu > Kiengir Map`) and not Apocalypse_Bomb
    (((((world.allow_warps
        && (match get_region(ctx.position()) {
            RegionId::Menu => false,
            _ => true,
        }))
        && (hobserve__ft_main!(ctx, world, full_obs)))
        && (hobserve__can_recall!(ctx, world, full_obs)))
        && (data::map_spot(ctx.position()) != SpotId::None
            && get_area(data::map_spot(ctx.position())) == AreaId::Menu__Kiengir_Map))
        && ({
            full_obs.observe_apocalypse_bomb();
            !ctx.has(Item::Apocalypse_Bomb)
        }))
}
pub fn observe_access_allow_warps_and_realm_eq_breach_and_breach_save_ne_invoke_default_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // allow_warps and ^realm == 'breach' and ^breach_save != $default and not Apocalypse_Bomb
    (((world.allow_warps
        && ({
            let v = data::realm(ctx.position());
            v == enums::Realm::Breach
        }))
        && ({
            let left = {
                full_obs.observe_breach_save();
                ctx.breach_save()
            };
            let right = Default::default();
            left != right
        }))
        && ({
            full_obs.observe_apocalypse_bomb();
            !ctx.has(Item::Apocalypse_Bomb)
        }))
}
pub fn observe_access_allow_warps_and_realm_in___main_interior_emergence_and_amashilama_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // allow_warps and ^realm IN ['main', 'interior', 'emergence'] and Amashilama and not Apocalypse_Bomb
    (((world.allow_warps
        && (matches!(
            data::realm(ctx.position()),
            enums::Realm::Main | enums::Realm::Interior | enums::Realm::Emergence
        )))
        && ({
            full_obs.observe_amashilama();
            ctx.has(Item::Amashilama)
        }))
        && ({
            full_obs.observe_apocalypse_bomb();
            !ctx.has(Item::Apocalypse_Bomb)
        }))
}
pub fn observe_access_allow_warps_and_within_antarctica(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // allow_warps and WITHIN `Antarctica`
    (world.allow_warps
        && (match get_region(ctx.position()) {
            RegionId::Antarctica => true,
            _ => false,
        }))
}
pub fn observe_access_amagi__main_area__ctx__combo_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and ($grab or $climb)
    ({
        full_obs.observe_amagi__main_area__ctx__combo();
        ctx.amagi__main_area__ctx__combo()
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_amagi__main_area__ctx__combo_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and $hook
    ({
        full_obs.observe_amagi__main_area__ctx__combo();
        ctx.amagi__main_area__ctx__combo()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_amagi__secret_chamber__ctx__east_dur_esla_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_dur_esla and Nanite_Mist
    ({
        full_obs.observe_amagi__secret_chamber__ctx__east_dur_esla();
        ctx.amagi__secret_chamber__ctx__east_dur_esla()
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_amagi__secret_chamber__ctx__east_dur_esla_and_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_dur_esla and Underwater_Movement and $hookhover
    (({
        full_obs.observe_amagi__secret_chamber__ctx__east_dur_esla();
        ctx.amagi__secret_chamber__ctx__east_dur_esla()
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })) && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_amagi__secret_chamber__ctx__west_dur_esla_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_dur_esla and Nanite_Mist
    ({
        full_obs.observe_amagi__secret_chamber__ctx__west_dur_esla();
        ctx.amagi__secret_chamber__ctx__west_dur_esla()
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_amagi__secret_chamber__ctx__west_dur_esla_and_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_dur_esla and Underwater_Movement and $hookhover
    (({
        full_obs.observe_amagi__secret_chamber__ctx__west_dur_esla();
        ctx.amagi__secret_chamber__ctx__west_dur_esla()
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })) && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_amagi_breach_lower_hallway_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Breach_Lower_Hallway_Gate
    {
        full_obs.observe_amagi_breach_lower_hallway_gate();
        ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate)
    }
}
pub fn observe_access_amagi_breach_lower_hallway_gate_and_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Breach_Lower_Hallway_Gate and Underwater_Movement and Slingshot_Hook and Drone_Hover
    ((({
        full_obs.observe_amagi_breach_lower_hallway_gate();
        ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })) && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_amagi_breach_split_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Breach_Split_Gate
    {
        full_obs.observe_amagi_breach_split_gate();
        ctx.has(Item::Amagi_Breach_Split_Gate)
    }
}
pub fn observe_access_amagi_breach_west_ruins_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Breach_West_Ruins_Gate
    {
        full_obs.observe_amagi_breach_west_ruins_gate();
        ctx.has(Item::Amagi_Breach_West_Ruins_Gate)
    }
}
pub fn observe_access_amagi_breach_west_ruins_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Breach_West_Ruins_Gate and Underwater_Movement
    ({
        full_obs.observe_amagi_breach_west_ruins_gate();
        ctx.has(Item::Amagi_Breach_West_Ruins_Gate)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }))
}
pub fn observe_access_amagi_breach_west_ruins_gate_and_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Breach_West_Ruins_Gate and Underwater_Movement and Slingshot_Hook and Drone_Hover
    ((({
        full_obs.observe_amagi_breach_west_ruins_gate();
        ctx.has(Item::Amagi_Breach_West_Ruins_Gate)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })) && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_amagi_dragon_eye_passage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Dragon_Eye_Passage
    {
        full_obs.observe_amagi_dragon_eye_passage();
        ctx.has(Item::Amagi_Dragon_Eye_Passage)
    }
}
pub fn observe_access_amagi_gated_community_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Gated_Community_Gate
    {
        full_obs.observe_amagi_gated_community_gate();
        ctx.has(Item::Amagi_Gated_Community_Gate)
    }
}
pub fn observe_access_amagi_gated_community_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Gated_Community_Gate and Underwater_Movement
    ({
        full_obs.observe_amagi_gated_community_gate();
        ctx.has(Item::Amagi_Gated_Community_Gate)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }))
}
pub fn observe_access_amagi_stronghold_boulder_1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_1
    {
        full_obs.observe_amagi_stronghold_boulder_1();
        ctx.has(Item::Amagi_Stronghold_Boulder_1)
    }
}
pub fn observe_access_amagi_stronghold_boulder_1_and_underwater_movement_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_1 and Underwater_Movement and ($grab or $climb)
    (({
        full_obs.observe_amagi_stronghold_boulder_1();
        ctx.has(Item::Amagi_Stronghold_Boulder_1)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })) && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_amagi_stronghold_boulder_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_2
    {
        full_obs.observe_amagi_stronghold_boulder_2();
        ctx.has(Item::Amagi_Stronghold_Boulder_2)
    }
}
pub fn observe_access_amagi_stronghold_boulder_2_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Boulder_2 and $grab
    ({
        full_obs.observe_amagi_stronghold_boulder_2();
        ctx.has(Item::Amagi_Stronghold_Boulder_2)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_amagi_stronghold_left_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Left_Wall
    {
        full_obs.observe_amagi_stronghold_left_wall();
        ctx.has(Item::Amagi_Stronghold_Left_Wall)
    }
}
pub fn observe_access_amagi_stronghold_left_wall_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Left_Wall and Underwater_Movement
    ({
        full_obs.observe_amagi_stronghold_left_wall();
        ctx.has(Item::Amagi_Stronghold_Left_Wall)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }))
}
pub fn observe_access_amagi_stronghold_wall_1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Wall_1
    {
        full_obs.observe_amagi_stronghold_wall_1();
        ctx.has(Item::Amagi_Stronghold_Wall_1)
    }
}
pub fn observe_access_amagi_stronghold_wall_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Stronghold_Wall_2
    {
        full_obs.observe_amagi_stronghold_wall_2();
        ctx.has(Item::Amagi_Stronghold_Wall_2)
    }
}
pub fn observe_access_amagi_west_lake_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_West_Lake_Gate
    {
        full_obs.observe_amagi_west_lake_gate();
        ctx.has(Item::Amagi_West_Lake_Gate)
    }
}
pub fn observe_access_amagi_west_lake_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_West_Lake_Gate and Underwater_Movement
    ({
        full_obs.observe_amagi_west_lake_gate();
        ctx.has(Item::Amagi_West_Lake_Gate)
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }))
}
pub fn observe_access_amagi_west_lake_surface_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_West_Lake_Surface_Wall
    {
        full_obs.observe_amagi_west_lake_surface_wall();
        ctx.has(Item::Amagi_West_Lake_Surface_Wall)
    }
}
pub fn observe_access_amagi_wiggly_room_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Amagi_Wiggly_Room_Gate
    {
        full_obs.observe_amagi_wiggly_room_gate();
        ctx.has(Item::Amagi_Wiggly_Room_Gate)
    }
}
pub fn observe_access_annuna__boss_gate__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door
    {
        full_obs.observe_annuna__boss_gate__ctx__door();
        ctx.annuna__boss_gate__ctx__door()
    }
}
pub fn observe_access_annuna__east_bridge__ctx__combo(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo
    {
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    }
}
pub fn observe_access_annuna__east_bridge__ctx__combo_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and $grab
    ({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__east_bridge__ctx__combo_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_combo and $hook
    ({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__invisible_enemies__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_annuna__invisible_enemies__ctx__door_opened();
        ctx.annuna__invisible_enemies__ctx__door_opened()
    }
}
pub fn observe_access_annuna__invisible_enemies__ctx__door_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened and $hookhover
    ({
        full_obs.observe_annuna__invisible_enemies__ctx__door_opened();
        ctx.annuna__invisible_enemies__ctx__door_opened()
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__invisible_enemies__ctx__nw_utu(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_nw_utu
    {
        full_obs.observe_annuna__invisible_enemies__ctx__nw_utu();
        ctx.annuna__invisible_enemies__ctx__nw_utu()
    }
}
pub fn observe_access_annuna__invisible_enemies__ctx__nw_utu_and_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_nw_utu and $melee_cskip
    ({
        full_obs.observe_annuna__invisible_enemies__ctx__nw_utu();
        ctx.annuna__invisible_enemies__ctx__nw_utu()
    } && (hobserve__melee_cskip!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__invisible_enemies__ctx__nw_utu_and_invoke_melee_cskip_and_fast_travel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_nw_utu and $melee_cskip and Fast_Travel
    (({
        full_obs.observe_annuna__invisible_enemies__ctx__nw_utu();
        ctx.annuna__invisible_enemies__ctx__nw_utu()
    } && (hobserve__melee_cskip!(ctx, world, full_obs)))
        && ({
            full_obs.observe_fast_travel();
            ctx.has(Item::Fast_Travel)
        }))
}
pub fn observe_access_annuna__udug_gate__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door
    {
        full_obs.observe_annuna__udug_gate__ctx__door();
        ctx.annuna__udug_gate__ctx__door()
    }
}
pub fn observe_access_annuna__vertical_room__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_annuna__vertical_room__ctx__door_opened();
        ctx.annuna__vertical_room__ctx__door_opened()
    }
}
pub fn observe_access_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_opened
    {
        full_obs.observe_annuna__west_bridge__ctx__doors_opened();
        ctx.annuna__west_bridge__ctx__doors_opened()
    }
}
pub fn observe_access_annuna__west_bridge__ctx__doors_opened_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_opened and $grab
    ({
        full_obs.observe_annuna__west_bridge__ctx__doors_opened();
        ctx.annuna__west_bridge__ctx__doors_opened()
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__west_bridge__ctx__doors_opened_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_opened and $hook
    ({
        full_obs.observe_annuna__west_bridge__ctx__doors_opened();
        ctx.annuna__west_bridge__ctx__doors_opened()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__west_bridge__ctx__doors_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_opened and $hookhover
    ({
        full_obs.observe_annuna__west_bridge__ctx__doors_opened();
        ctx.annuna__west_bridge__ctx__doors_opened()
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_annuna__west_climb__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_annuna__west_climb__ctx__door_opened();
        ctx.annuna__west_climb__ctx__door_opened()
    }
}
pub fn observe_access_annuna_breach_factory_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Breach_Factory_Gate
    {
        full_obs.observe_annuna_breach_factory_gate();
        ctx.has(Item::Annuna_Breach_Factory_Gate)
    }
}
pub fn observe_access_annuna_breach_upper_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Breach_Upper_Gate
    {
        full_obs.observe_annuna_breach_upper_gate();
        ctx.has(Item::Annuna_Breach_Upper_Gate)
    }
}
pub fn observe_access_annuna_breach_upper_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Breach_Upper_Gate and Slingshot_Hook
    ({
        full_obs.observe_annuna_breach_upper_gate();
        ctx.has(Item::Annuna_Breach_Upper_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_annuna_double_trouble_bosses_and_invoke_can_damage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Double_Trouble_Bosses and $can_damage
    ({
        full_obs.observe_annuna_double_trouble_bosses();
        ctx.has(Item::Annuna_Double_Trouble_Bosses)
    } && (hobserve__can_damage!(ctx, world, full_obs)))
}
pub fn observe_access_annuna_double_trouble_bosses_and_invoke_shockwave_and___boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Double_Trouble_Bosses and $shockwave and (Boomerang or Boomerang_Upgrade)
    (({
        full_obs.observe_annuna_double_trouble_bosses();
        ctx.has(Item::Annuna_Double_Trouble_Bosses)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
        && ({
            full_obs.observe_boomerang();
            ctx.has(Item::Boomerang)
        } || {
            full_obs.observe_boomerang_upgrade();
            ctx.has(Item::Boomerang_Upgrade)
        }))
}
pub fn observe_access_annuna_double_trouble_bosses_and_invoke_shockwave_and___invoke_weapon_or_anuman_or_boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Double_Trouble_Bosses and $shockwave and ($weapon or Anuman or Boomerang or Boomerang_Upgrade)
    (({
        full_obs.observe_annuna_double_trouble_bosses();
        ctx.has(Item::Annuna_Double_Trouble_Bosses)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
        && (((hobserve__weapon!(ctx, world, full_obs) || {
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }) || {
            full_obs.observe_boomerang();
            ctx.has(Item::Boomerang)
        }) || {
            full_obs.observe_boomerang_upgrade();
            ctx.has(Item::Boomerang_Upgrade)
        }))
}
pub fn observe_access_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_East_Bridge_Gate
    {
        full_obs.observe_annuna_east_bridge_gate();
        ctx.has(Item::Annuna_East_Bridge_Gate)
    }
}
pub fn observe_access_annuna_east_bridge_gate_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_East_Bridge_Gate and $hookhover
    ({
        full_obs.observe_annuna_east_bridge_gate();
        ctx.has(Item::Annuna_East_Bridge_Gate)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_annuna_lower_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Lower_Gate
    {
        full_obs.observe_annuna_lower_gate();
        ctx.has(Item::Annuna_Lower_Gate)
    }
}
pub fn observe_access_annuna_lower_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Lower_Gate and Slingshot_Hook
    ({
        full_obs.observe_annuna_lower_gate();
        ctx.has(Item::Annuna_Lower_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_annuna_mirror_match_switch(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Mirror_Match_Switch
    {
        full_obs.observe_annuna_mirror_match_switch();
        ctx.has(Item::Annuna_Mirror_Match_Switch)
    }
}
pub fn observe_access_annuna_remote_training_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Remote_Training_Gate
    {
        full_obs.observe_annuna_remote_training_gate();
        ctx.has(Item::Annuna_Remote_Training_Gate)
    }
}
pub fn observe_access_annuna_remote_training_gate_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Remote_Training_Gate and $hookhover
    ({
        full_obs.observe_annuna_remote_training_gate();
        ctx.has(Item::Annuna_Remote_Training_Gate)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_annuna_vertical_room_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Annuna_Vertical_Room_Gate
    {
        full_obs.observe_annuna_vertical_room_gate();
        ctx.has(Item::Annuna_Vertical_Room_Gate)
    }
}
pub fn observe_access_anuman(ctx: &Context, world: &World, full_obs: &mut FullObservation) -> bool {
    // Anuman
    {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }
}
pub fn observe_access_anuman_and_invoke_boomerang(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and $boomerang
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && (hobserve__boomerang!(ctx, world, full_obs)))
}
pub fn observe_access_anuman_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and $climb
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_anuman_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and $grab
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_anuman_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and $shockwave
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_anuman_and_mode_eq_indra_and___ledge_grab_or_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and ^mode == 'Indra' and (Ledge_Grab or Slingshot_Hook)
    (({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Indra
    })) && ({
        full_obs.observe_ledge_grab();
        ctx.has(Item::Ledge_Grab)
    } || {
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and ^mode != 'drone'
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    }))
}
pub fn observe_access_anuman_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_anuman_or___invoke_hook_and___not_slingshot_weapon_or_invoke_visited__annuna_gt_invisible_enemies_gt_corner_cache_gt_flask(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Anuman or ($hook and (not Slingshot_Weapon or $visited(`Annuna > Invisible Enemies > Corner Cache > Flask`)))
    ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    } || (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_weapon();
            !ctx.has(Item::Slingshot_Weapon)
        } || ctx.visited(LocationId::Annuna__Invisible_Enemies__Corner_Cache__Flask))))
}
pub fn observe_access_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Apocalypse_Bomb
    {
        full_obs.observe_apocalypse_bomb();
        ctx.has(Item::Apocalypse_Bomb)
    }
}
pub fn observe_access_apocalypse_bomb_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Apocalypse_Bomb and $hook
    ({
        full_obs.observe_apocalypse_bomb();
        ctx.has(Item::Apocalypse_Bomb)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_block_fast_travel_and_invoke_shockwave_and_fast_travel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // block_fast_travel and $shockwave and Fast_Travel
    ((world.block_fast_travel && (hobserve__shockwave!(ctx, world, full_obs)))
        && ({
            full_obs.observe_fast_travel();
            ctx.has(Item::Fast_Travel)
        }))
}
pub fn observe_access_boomerang(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Boomerang
    {
        full_obs.observe_boomerang();
        ctx.has(Item::Boomerang)
    }
}
pub fn observe_access_breach_attractor(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Breach_Attractor
    {
        full_obs.observe_breach_attractor();
        ctx.has(Item::Breach_Attractor)
    }
}
pub fn observe_access_breach_attractor_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Breach_Attractor and Anuman
    ({
        full_obs.observe_breach_attractor();
        ctx.has(Item::Breach_Attractor)
    } && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }))
}
pub fn observe_access_breach_attractor_and_mode_eq_drone_and_indra_within___glacier_gt_grid_39sub40_7sub9_glacier_gt_revival_glacier_gt_dock_outside_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Breach_Attractor and ^mode == 'drone' and ^indra WITHIN (`Glacier > Grid 39-40,7-9`, `Glacier > Revival`, `Glacier > Dock Outside`) and ^portal == ^portal_start
    ((({
        full_obs.observe_breach_attractor();
        ctx.has(Item::Breach_Attractor)
    } && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    })) && ({
        full_obs.observe_indra();
        ctx.indra()
    } != SpotId::None
        && matches!(
            get_area({
                full_obs.observe_indra();
                ctx.indra()
            }),
            AreaId::Glacier__Grid_39_40_7_9
                | AreaId::Glacier__Revival
                | AreaId::Glacier__Dock_Outside
        )))
        && ({
            let left = {
                full_obs.observe_portal();
                ctx.portal()
            };
            let right = data::portal_start(ctx.position());
            left == right
        }))
}
pub fn observe_access_breach_attractor_and_mode_eq_drone_and_indra_within_annuna_gt_filter_teleporter_gt_shaft_top(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Breach_Attractor and ^mode == 'drone' and ^indra WITHIN `Annuna > Filter Teleporter > Shaft Top`
    (({
        full_obs.observe_breach_attractor();
        ctx.has(Item::Breach_Attractor)
    } && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    })) && ({
        full_obs.observe_indra();
        ctx.indra()
    } == SpotId::Annuna__Filter_Teleporter__Shaft_Top))
}
pub fn observe_access_defeat_indra(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Defeat_Indra
    {
        full_obs.observe_defeat_indra();
        ctx.has(Item::Defeat_Indra)
    }
}
pub fn observe_access_defeat_mus_a_m20(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Defeat_MUS_A_M20
    {
        full_obs.observe_defeat_mus_a_m20();
        ctx.has(Item::Defeat_MUS_A_M20)
    }
}
pub fn observe_access_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Hover
    {
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }
}
pub fn observe_access_drone_hover_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Hover and Nanite_Mist
    ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_drone_melee_damage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Damage
    {
        full_obs.observe_drone_melee_damage();
        ctx.has(Item::Drone_Melee_Damage)
    }
}
pub fn observe_access_drone_melee_damage_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Damage_2
    {
        full_obs.observe_drone_melee_damage_2();
        ctx.has(Item::Drone_Melee_Damage_2)
    }
}
pub fn observe_access_drone_melee_damage_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Damage_3
    {
        full_obs.observe_drone_melee_damage_3();
        ctx.has(Item::Drone_Melee_Damage_3)
    }
}
pub fn observe_access_drone_melee_speed(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Speed
    {
        full_obs.observe_drone_melee_speed();
        ctx.has(Item::Drone_Melee_Speed)
    }
}
pub fn observe_access_drone_melee_speed_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Drone_Melee_Speed_2
    {
        full_obs.observe_drone_melee_speed_2();
        ctx.has(Item::Drone_Melee_Speed_2)
    }
}
pub fn observe_access_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_left_platform_moved
    {
        full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
        ctx.ebih__base_camp__ctx__left_platform_moved()
    }
}
pub fn observe_access_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__ebih_west__ctx__door_open();
        ctx.ebih__ebih_west__ctx__door_open()
    }
}
pub fn observe_access_ebih__grid_25_10_12__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__grid_25_10_12__ctx__door_open();
        ctx.ebih__grid_25_10_12__ctx__door_open()
    }
}
pub fn observe_access_ebih__truck_gate__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__truck_gate__ctx__door_open();
        ctx.ebih__truck_gate__ctx__door_open()
    }
}
pub fn observe_access_ebih__vertical_interchange__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_ebih__vertical_interchange__ctx__door_open();
        ctx.ebih__vertical_interchange__ctx__door_open()
    }
}
pub fn observe_access_ebih__waterfall__ctx__east_door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_door_open
    {
        full_obs.observe_ebih__waterfall__ctx__east_door_open();
        ctx.ebih__waterfall__ctx__east_door_open()
    }
}
pub fn observe_access_ebih__waterfall__ctx__east_door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_door_open and $hook
    ({
        full_obs.observe_ebih__waterfall__ctx__east_door_open();
        ctx.ebih__waterfall__ctx__east_door_open()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_ebih__waterfall__ctx__west_door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_west_door_open
    {
        full_obs.observe_ebih__waterfall__ctx__west_door_open();
        ctx.ebih__waterfall__ctx__west_door_open()
    }
}
pub fn observe_access_ebih_alu(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Alu
    {
        full_obs.observe_ebih_alu();
        ctx.has(Item::Ebih_Alu)
    }
}
pub fn observe_access_ebih_breach_double_gate_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Double_Gate_Gate
    {
        full_obs.observe_ebih_breach_double_gate_gate();
        ctx.has(Item::Ebih_Breach_Double_Gate_Gate)
    }
}
pub fn observe_access_ebih_breach_double_gate_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Double_Gate_Gate and Slingshot_Hook
    ({
        full_obs.observe_ebih_breach_double_gate_gate();
        ctx.has(Item::Ebih_Breach_Double_Gate_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_ebih_breach_in_n_out_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_In_n_Out_Gate
    {
        full_obs.observe_ebih_breach_in_n_out_gate();
        ctx.has(Item::Ebih_Breach_In_n_Out_Gate)
    }
}
pub fn observe_access_ebih_breach_lake_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Lake_Gate
    {
        full_obs.observe_ebih_breach_lake_gate();
        ctx.has(Item::Ebih_Breach_Lake_Gate)
    }
}
pub fn observe_access_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Rock_Block_Rock
    {
        full_obs.observe_ebih_breach_rock_block_rock();
        ctx.has(Item::Ebih_Breach_Rock_Block_Rock)
    }
}
pub fn observe_access_ebih_breach_rocky_cages_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Rocky_Cages_Gate
    {
        full_obs.observe_ebih_breach_rocky_cages_gate();
        ctx.has(Item::Ebih_Breach_Rocky_Cages_Gate)
    }
}
pub fn observe_access_ebih_breach_rocky_cages_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Rocky_Cages_Gate and Slingshot_Hook
    ({
        full_obs.observe_ebih_breach_rocky_cages_gate();
        ctx.has(Item::Ebih_Breach_Rocky_Cages_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_ebih_breach_spider_guards_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Spider_Guards_Gate
    {
        full_obs.observe_ebih_breach_spider_guards_gate();
        ctx.has(Item::Ebih_Breach_Spider_Guards_Gate)
    }
}
pub fn observe_access_ebih_breach_spider_guards_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Breach_Spider_Guards_Gate and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_ebih_breach_spider_guards_gate();
        ctx.has(Item::Ebih_Breach_Spider_Guards_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_ebih_east_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_East_Wall
    {
        full_obs.observe_ebih_east_wall();
        ctx.has(Item::Ebih_East_Wall)
    }
}
pub fn observe_access_ebih_gem_room_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Gem_Room_Gate
    {
        full_obs.observe_ebih_gem_room_gate();
        ctx.has(Item::Ebih_Gem_Room_Gate)
    }
}
pub fn observe_access_ebih_hidden_portal_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Hidden_Portal_Gate
    {
        full_obs.observe_ebih_hidden_portal_gate();
        ctx.has(Item::Ebih_Hidden_Portal_Gate)
    }
}
pub fn observe_access_ebih_interchange_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Block
    {
        full_obs.observe_ebih_interchange_block();
        ctx.has(Item::Ebih_Interchange_Block)
    }
}
pub fn observe_access_ebih_interchange_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate
    {
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    }
}
pub fn observe_access_ebih_interchange_gate_and_ebih_interchange_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $grab
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_interchange_gate_and_ebih_interchange_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and Ebih_Interchange_Block and $hook
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_interchange_gate_and_not_ebih_interchange_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $grab
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        !ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_interchange_gate_and_not_ebih_interchange_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Interchange_Gate and not Ebih_Interchange_Block and $hook
    (({
        full_obs.observe_ebih_interchange_gate();
        ctx.has(Item::Ebih_Interchange_Gate)
    } && ({
        full_obs.observe_ebih_interchange_block();
        !ctx.has(Item::Ebih_Interchange_Block)
    })) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_ebih_walled_off_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Walled_Off_Wall
    {
        full_obs.observe_ebih_walled_off_wall();
        ctx.has(Item::Ebih_Walled_Off_Wall)
    }
}
pub fn observe_access_ebih_waterfall_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_Waterfall_Wall
    {
        full_obs.observe_ebih_waterfall_wall();
        ctx.has(Item::Ebih_Waterfall_Wall)
    }
}
pub fn observe_access_ebih_west_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ebih_West_Block
    {
        full_obs.observe_ebih_west_block();
        ctx.has(Item::Ebih_West_Block)
    }
}
pub fn observe_access_ellag(ctx: &Context, world: &World, full_obs: &mut FullObservation) -> bool {
    // Ellag
    {
        full_obs.observe_ellag();
        ctx.has(Item::Ellag)
    }
}
pub fn observe_access_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_emergence__storage__ctx__door_open();
        ctx.emergence__storage__ctx__door_open()
    }
}
pub fn observe_access_emergence__storage__ctx__door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $hook
    ({
        full_obs.observe_emergence__storage__ctx__door_open();
        ctx.emergence__storage__ctx__door_open()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_emergence_dropoff_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Dropoff_Wall
    {
        full_obs.observe_emergence_dropoff_wall();
        ctx.has(Item::Emergence_Dropoff_Wall)
    }
}
pub fn observe_access_emergence_dropoff_wall_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Dropoff_Wall and Anuman
    ({
        full_obs.observe_emergence_dropoff_wall();
        ctx.has(Item::Emergence_Dropoff_Wall)
    } && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }))
}
pub fn observe_access_emergence_dropoff_wall_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Dropoff_Wall and $hook
    ({
        full_obs.observe_emergence_dropoff_wall();
        ctx.has(Item::Emergence_Dropoff_Wall)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_emergence_dropoff_wall_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Dropoff_Wall and Nanite_Mist
    ({
        full_obs.observe_emergence_dropoff_wall();
        ctx.has(Item::Emergence_Dropoff_Wall)
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_emergence_rocks_fall_rock_1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Rocks_Fall_Rock_1
    {
        full_obs.observe_emergence_rocks_fall_rock_1();
        ctx.has(Item::Emergence_Rocks_Fall_Rock_1)
    }
}
pub fn observe_access_emergence_rocks_fall_rock_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Rocks_Fall_Rock_2
    {
        full_obs.observe_emergence_rocks_fall_rock_2();
        ctx.has(Item::Emergence_Rocks_Fall_Rock_2)
    }
}
pub fn observe_access_emergence_rocks_fall_rock_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Rocks_Fall_Rock_3
    {
        full_obs.observe_emergence_rocks_fall_rock_3();
        ctx.has(Item::Emergence_Rocks_Fall_Rock_3)
    }
}
pub fn observe_access_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Rocks_Fall_Rock_4
    {
        full_obs.observe_emergence_rocks_fall_rock_4();
        ctx.has(Item::Emergence_Rocks_Fall_Rock_4)
    }
}
pub fn observe_access_emergence_storage_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Storage_Rock
    {
        full_obs.observe_emergence_storage_rock();
        ctx.has(Item::Emergence_Storage_Rock)
    }
}
pub fn observe_access_emergence_storage_tunnel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Emergence_Storage_Tunnel
    {
        full_obs.observe_emergence_storage_tunnel();
        ctx.has(Item::Emergence_Storage_Tunnel)
    }
}
pub fn observe_access_fast_travel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Fast_Travel
    {
        full_obs.observe_fast_travel();
        ctx.has(Item::Fast_Travel)
    }
}
pub fn observe_access_fast_travel_and_invoke_boomerang(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Fast_Travel and $boomerang
    ({
        full_obs.observe_fast_travel();
        ctx.has(Item::Fast_Travel)
    } && (hobserve__boomerang!(ctx, world, full_obs)))
}
pub fn observe_access_fast_travel_and_invoke_boomerang2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Fast_Travel and $boomerang2
    ({
        full_obs.observe_fast_travel();
        ctx.has(Item::Fast_Travel)
    } && (hobserve__boomerang2!(ctx, world, full_obs)))
}
pub fn observe_access_fast_travel_and_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Fast_Travel and $melee_cskip
    ({
        full_obs.observe_fast_travel();
        ctx.has(Item::Fast_Travel)
    } && (hobserve__melee_cskip!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__carnelian__ctx__door_opened();
        ctx.giguna__carnelian__ctx__door_opened()
    }
}
pub fn observe_access_giguna__carnelian__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar
    {
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    }
}
pub fn observe_access_giguna__carnelian__ctx__lower_susar_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar and $grab
    ({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__ctx__lower_susar_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar and $hook
    ({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__carnelian__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__clouds__ctx__platform_and_invoke_attract_and_breach_sight_and_remote_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_platform and $attract and Breach_Sight and Remote_Drone
    ((({
        full_obs.observe_giguna__clouds__ctx__platform();
        ctx.giguna__clouds__ctx__platform()
    } && (hobserve__attract!(ctx, world, full_obs)))
        && ({
            full_obs.observe_breach_sight();
            ctx.has(Item::Breach_Sight)
        }))
        && ({
            full_obs.observe_remote_drone();
            ctx.has(Item::Remote_Drone)
        }))
}
pub fn observe_access_giguna__clouds__ctx__platform_and_invoke_attract_and_invoke_can_deploy_and_breach_sight(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_platform and $attract and $can_deploy and Breach_Sight
    ((({
        full_obs.observe_giguna__clouds__ctx__platform();
        ctx.giguna__clouds__ctx__platform()
    } && (hobserve__attract!(ctx, world, full_obs)))
        && (hobserve__can_deploy!(ctx, world, full_obs)))
        && ({
            full_obs.observe_breach_sight();
            ctx.has(Item::Breach_Sight)
        }))
}
pub fn observe_access_giguna__east_caverns__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }
}
pub fn observe_access_giguna__east_caverns__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    }
}
pub fn observe_access_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_mid_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__mid_susar();
        ctx.giguna__east_caverns__ctx__mid_susar()
    }
}
pub fn observe_access_giguna__east_caverns__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_susar
    {
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }
}
pub fn observe_access_giguna__gateway__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__gateway__ctx__door_opened();
        ctx.giguna__gateway__ctx__door_opened()
    }
}
pub fn observe_access_giguna__giguna_base__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open
    {
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    }
}
pub fn observe_access_giguna__giguna_base__ctx__door_open_and_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $grab and $climb
    (({
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_base__ctx__door_open_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_open and $hook
    ({
        full_obs.observe_giguna__giguna_base__ctx__door_open();
        ctx.giguna__giguna_base__ctx__door_open()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    }
}
pub fn observe_access_giguna__giguna_northeast__ctx__door_opened_and___invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened and ($grab or $hook)
    ({
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_northeast__ctx__door_opened_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened and $hook
    ({
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__giguna_northeast__ctx__door_opened_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened and $hookhover
    ({
        full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
        ctx.giguna__giguna_northeast__ctx__door_opened()
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_giguna__labyrinth__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door
    {
        full_obs.observe_giguna__labyrinth__ctx__door();
        ctx.giguna__labyrinth__ctx__door()
    }
}
pub fn observe_access_giguna__ruins_top__ctx__doors_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_doors_open
    {
        full_obs.observe_giguna__ruins_top__ctx__doors_open();
        ctx.giguna__ruins_top__ctx__doors_open()
    }
}
pub fn observe_access_giguna__west_caverns__ctx__east_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_east_susar
    {
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    }
}
pub fn observe_access_giguna_boulder(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Boulder
    {
        full_obs.observe_giguna_boulder();
        ctx.has(Item::Giguna_Boulder)
    }
}
pub fn observe_access_giguna_breach__sw_save__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door_opened
    {
        full_obs.observe_giguna_breach__sw_save__ctx__door_opened();
        ctx.giguna_breach__sw_save__ctx__door_opened()
    }
}
pub fn observe_access_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Breach_Crab_Rave_Gate
    {
        full_obs.observe_giguna_breach_crab_rave_gate();
        ctx.has(Item::Giguna_Breach_Crab_Rave_Gate)
    }
}
pub fn observe_access_giguna_breach_gate_and_wall_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Breach_Gate_and_Wall_Gate
    {
        full_obs.observe_giguna_breach_gate_and_wall_gate();
        ctx.has(Item::Giguna_Breach_Gate_and_Wall_Gate)
    }
}
pub fn observe_access_giguna_breach_lower_machinery_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Breach_Lower_Machinery_Gate
    {
        full_obs.observe_giguna_breach_lower_machinery_gate();
        ctx.has(Item::Giguna_Breach_Lower_Machinery_Gate)
    }
}
pub fn observe_access_giguna_breach_pinkness_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Breach_Pinkness_Rock
    {
        full_obs.observe_giguna_breach_pinkness_rock();
        ctx.has(Item::Giguna_Breach_Pinkness_Rock)
    }
}
pub fn observe_access_giguna_dual_path_switch(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch
    {
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    }
}
pub fn observe_access_giguna_dual_path_switch_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch and ($grab or $climb)
    ({
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_dual_path_switch_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch and $climb
    ({
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    } && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_dual_path_switch_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Dual_Path_Switch and $hook
    ({
        full_obs.observe_giguna_dual_path_switch();
        ctx.has(Item::Giguna_Dual_Path_Switch)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_gateway_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gateway_Block
    {
        full_obs.observe_giguna_gateway_block();
        ctx.has(Item::Giguna_Gateway_Block)
    }
}
pub fn observe_access_giguna_gateway_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gateway_Gate
    {
        full_obs.observe_giguna_gateway_gate();
        ctx.has(Item::Giguna_Gateway_Gate)
    }
}
pub fn observe_access_giguna_gubi_and_invoke_boomerang(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gubi and $boomerang
    ({
        full_obs.observe_giguna_gubi();
        ctx.has(Item::Giguna_Gubi)
    } && (hobserve__boomerang!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_gubi_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Gubi and $hover
    ({
        full_obs.observe_giguna_gubi();
        ctx.has(Item::Giguna_Gubi)
    } && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_labyrinth_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Labyrinth_Gate
    {
        full_obs.observe_giguna_labyrinth_gate();
        ctx.has(Item::Giguna_Labyrinth_Gate)
    }
}
pub fn observe_access_giguna_northeast_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Northeast_Gate
    {
        full_obs.observe_giguna_northeast_gate();
        ctx.has(Item::Giguna_Northeast_Gate)
    }
}
pub fn observe_access_giguna_separator_bricks(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Separator_Bricks
    {
        full_obs.observe_giguna_separator_bricks();
        ctx.has(Item::Giguna_Separator_Bricks)
    }
}
pub fn observe_access_giguna_separator_bricks_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Separator_Bricks and $hook
    ({
        full_obs.observe_giguna_separator_bricks();
        ctx.has(Item::Giguna_Separator_Bricks)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_vertical_interchange_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Vertical_Interchange_Gate
    {
        full_obs.observe_giguna_vertical_interchange_gate();
        ctx.has(Item::Giguna_Vertical_Interchange_Gate)
    }
}
pub fn observe_access_giguna_vertical_interchange_gate_and___invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Vertical_Interchange_Gate and ($hook or Anuman)
    ({
        full_obs.observe_giguna_vertical_interchange_gate();
        ctx.has(Item::Giguna_Vertical_Interchange_Gate)
    } && (hobserve__hook!(ctx, world, full_obs) || {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }))
}
pub fn observe_access_giguna_vertical_interchange_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Vertical_Interchange_Rock
    {
        full_obs.observe_giguna_vertical_interchange_rock();
        ctx.has(Item::Giguna_Vertical_Interchange_Rock)
    }
}
pub fn observe_access_giguna_vertical_interchange_rock_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Vertical_Interchange_Rock and $grab
    ({
        full_obs.observe_giguna_vertical_interchange_rock();
        ctx.has(Item::Giguna_Vertical_Interchange_Rock)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_vertical_interchange_rock_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Vertical_Interchange_Rock and $hook
    ({
        full_obs.observe_giguna_vertical_interchange_rock();
        ctx.has(Item::Giguna_Vertical_Interchange_Rock)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_vertical_interchange_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Vertical_Interchange_Rock and $hookhover
    ({
        full_obs.observe_giguna_vertical_interchange_rock();
        ctx.has(Item::Giguna_Vertical_Interchange_Rock)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_giguna_wasteland_door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Giguna_Wasteland_Door
    {
        full_obs.observe_giguna_wasteland_door();
        ctx.has(Item::Giguna_Wasteland_Door)
    }
}
pub fn observe_access_glacier__ctx__hammonds_doors(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_hammonds_doors
    {
        full_obs.observe_glacier__ctx__hammonds_doors();
        ctx.glacier__ctx__hammonds_doors()
    }
}
pub fn observe_access_glacier__ctx__hammonds_doors_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_hammonds_doors and $hook
    ({
        full_obs.observe_glacier__ctx__hammonds_doors();
        ctx.glacier__ctx__hammonds_doors()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_glacier__ctx__hammonds_doors_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_hammonds_doors and $hookhover
    ({
        full_obs.observe_glacier__ctx__hammonds_doors();
        ctx.glacier__ctx__hammonds_doors()
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_glacier__lonely_bull__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_door
    {
        full_obs.observe_glacier__lonely_bull__ctx__door();
        ctx.glacier__lonely_bull__ctx__door()
    }
}
pub fn observe_access_glacier__the_big_drop__ctx__bridge_open_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_bridge_open and Nanite_Mist
    ({
        full_obs.observe_glacier__the_big_drop__ctx__bridge_open();
        ctx.glacier__the_big_drop__ctx__bridge_open()
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_gatestones
    {
        full_obs.observe_glacier__vertical_room__ctx__lower_gatestones();
        ctx.glacier__vertical_room__ctx__lower_gatestones()
    }
}
pub fn observe_access_glacier__vertical_room__ctx__lower_gatestones_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_lower_gatestones and Underwater_Movement
    ({
        full_obs.observe_glacier__vertical_room__ctx__lower_gatestones();
        ctx.glacier__vertical_room__ctx__lower_gatestones()
    } && ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }))
}
pub fn observe_access_glacier__vertical_room__ctx__upper_gatestone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_upper_gatestone
    {
        full_obs.observe_glacier__vertical_room__ctx__upper_gatestone();
        ctx.glacier__vertical_room__ctx__upper_gatestone()
    }
}
pub fn observe_access_glacier_big_drop_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Big_Drop_Rock
    {
        full_obs.observe_glacier_big_drop_rock();
        ctx.has(Item::Glacier_Big_Drop_Rock)
    }
}
pub fn observe_access_glacier_breach_spidery_connector_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Breach_Spidery_Connector_Gate
    {
        full_obs.observe_glacier_breach_spidery_connector_gate();
        ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate)
    }
}
pub fn observe_access_glacier_breach_spidery_connector_gate_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Breach_Spidery_Connector_Gate and Drone_Hover
    ({
        full_obs.observe_glacier_breach_spidery_connector_gate();
        ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_glacier_breach_spidery_connector_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Breach_Spidery_Connector_Gate and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_glacier_breach_spidery_connector_gate();
        ctx.has(Item::Glacier_Breach_Spidery_Connector_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_glacier_fortress_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Fortress_Gate
    {
        full_obs.observe_glacier_fortress_gate();
        ctx.has(Item::Glacier_Fortress_Gate)
    }
}
pub fn observe_access_glacier_fortress_gate_and___invoke_grab_or_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Fortress_Gate and ($grab or $hover)
    ({
        full_obs.observe_glacier_fortress_gate();
        ctx.has(Item::Glacier_Fortress_Gate)
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_glacier_fortress_gate_and___invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Fortress_Gate and ($hook or Anuman)
    ({
        full_obs.observe_glacier_fortress_gate();
        ctx.has(Item::Glacier_Fortress_Gate)
    } && (hobserve__hook!(ctx, world, full_obs) || {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    }))
}
pub fn observe_access_glacier_gudam(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Gudam
    {
        full_obs.observe_glacier_gudam();
        ctx.has(Item::Glacier_Gudam)
    }
}
pub fn observe_access_glacier_gudam_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Gudam and $shockwave
    ({
        full_obs.observe_glacier_gudam();
        ctx.has(Item::Glacier_Gudam)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_glacier_sea_burial_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Glacier_Sea_Burial_Rock
    {
        full_obs.observe_glacier_sea_burial_rock();
        ctx.has(Item::Glacier_Sea_Burial_Rock)
    }
}
pub fn observe_access_hammond_auth(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Hammond_Auth
    {
        full_obs.observe_hammond_auth();
        ctx.has(Item::Hammond_Auth)
    }
}
pub fn observe_access_health_upgrade(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade
    {
        full_obs.observe_health_upgrade();
        ctx.has(Item::Health_Upgrade)
    }
}
pub fn observe_access_health_upgrade_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade_2
    {
        full_obs.observe_health_upgrade_2();
        ctx.has(Item::Health_Upgrade_2)
    }
}
pub fn observe_access_health_upgrade_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade_3
    {
        full_obs.observe_health_upgrade_3();
        ctx.has(Item::Health_Upgrade_3)
    }
}
pub fn observe_access_health_upgrade_4(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Health_Upgrade_4
    {
        full_obs.observe_health_upgrade_4();
        ctx.has(Item::Health_Upgrade_4)
    }
}
pub fn observe_access_if___mode_eq_drone____drone_melee_damage_3_and_drone_hover__else____invoke_weapon_and_melee_damage_3_and___boomerang_or_boomerang_upgrade_(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // IF (^mode == 'drone') { Drone_Melee_Damage_3 and Drone_Hover } ELSE { $weapon and Melee_Damage_3 and (Boomerang or Boomerang_Upgrade) }
    if {
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } {
        ({
            full_obs.observe_drone_melee_damage_3();
            ctx.has(Item::Drone_Melee_Damage_3)
        } && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
    } else {
        ((hobserve__weapon!(ctx, world, full_obs)
            && ({
                full_obs.observe_melee_damage_3();
                ctx.has(Item::Melee_Damage_3)
            }))
            && ({
                full_obs.observe_boomerang();
                ctx.has(Item::Boomerang)
            } || {
                full_obs.observe_boomerang_upgrade();
                ctx.has(Item::Boomerang_Upgrade)
            }))
    }
}
pub fn observe_access_infect(ctx: &Context, world: &World, full_obs: &mut FullObservation) -> bool {
    // Infect
    {
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    }
}
pub fn observe_access_infect_and_anuman_and_invoke_objective(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and Anuman and $objective
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })) && (robserve__objective!(ctx, world, full_obs)))
}
pub fn observe_access_infect_and_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and ^_platform_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_ebih__drone_room__ctx__platform_moved();
        ctx.ebih__drone_room__ctx__platform_moved()
    }))
}
pub fn observe_access_infect_and_ebih__ebih_east__ctx__platform2_moved_and___invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and ^_platform2_moved and ($grab or $hook)
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
        ctx.ebih__ebih_east__ctx__platform2_moved()
    })) && (hobserve__grab!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_infect_and_invoke_grab_and_not_ebih__ebih_east__ctx__platform1_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and $grab and not ^_platform1_moved
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_ebih__ebih_east__ctx__platform1_moved();
            ctx.ebih__ebih_east__ctx__platform1_moved()
        })))
}
pub fn observe_access_infect_and_invoke_grab_and_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and $grab and not ^_platform2_moved
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
            ctx.ebih__ebih_east__ctx__platform2_moved()
        })))
}
pub fn observe_access_infect_and_not_anuman_and_invoke_objective(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not Anuman and $objective
    (({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && ({
        full_obs.observe_anuman();
        !ctx.has(Item::Anuman)
    })) && (robserve__objective!(ctx, world, full_obs)))
}
pub fn observe_access_infect_and_not_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not ^_platform_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (!({
        full_obs.observe_ebih__drone_room__ctx__platform_moved();
        ctx.ebih__drone_room__ctx__platform_moved()
    })))
}
pub fn observe_access_infect_and_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect and not ^_platform2_moved
    ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    } && (!({
        full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
        ctx.ebih__ebih_east__ctx__platform2_moved()
    })))
}
pub fn observe_access_infect_l1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect_L1
    {
        full_obs.observe_infect_l1();
        ctx.has(Item::Infect_L1)
    }
}
pub fn observe_access_infect_l2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infect_L2
    {
        full_obs.observe_infect_l2();
        ctx.has(Item::Infect_L2)
    }
}
pub fn observe_access_infection_range(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infection_Range
    {
        full_obs.observe_infection_range();
        ctx.has(Item::Infection_Range)
    }
}
pub fn observe_access_infection_range_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infection_Range_2
    {
        full_obs.observe_infection_range_2();
        ctx.has(Item::Infection_Range_2)
    }
}
pub fn observe_access_infection_speed(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Infection_Speed
    {
        full_obs.observe_infection_speed();
        ctx.has(Item::Infection_Speed)
    }
}
pub fn observe_access_invoke_activate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $activate
    hobserve__activate!(ctx, world, full_obs)
}
pub fn observe_access_invoke_activate_and_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $activate and ^_left_platform_moved
    (hobserve__activate!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        }))
}
pub fn observe_access_invoke_activate_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $activate and not ^_left_platform_moved
    (hobserve__activate!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_invoke_allegiance4(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $allegiance4
    hobserve__allegiance4!(ctx, world, full_obs)
}
pub fn observe_access_invoke_block_clip_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Left
    (hobserve__block_clip!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_left();
            !ctx.has(Item::Ebih_Waterfall_Block_Left)
        }))
}
pub fn observe_access_invoke_block_clip_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip and not Ebih_Waterfall_Block_Right
    (hobserve__block_clip!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_right();
            !ctx.has(Item::Ebih_Waterfall_Block_Right)
        }))
}
pub fn observe_access_invoke_block_clip_and_slingshot_hook_and_not_uhrum_east_lake_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip and Slingshot_Hook and not Uhrum_East_Lake_Block
    ((hobserve__block_clip!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
        && ({
            full_obs.observe_uhrum_east_lake_block();
            !ctx.has(Item::Uhrum_East_Lake_Block)
        }))
}
pub fn observe_access_invoke_block_clip_escape_and_not_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $block_clip_escape and not Uhrum_Annuna_Corridor_Block
    (hobserve__block_clip_escape!(ctx, world, full_obs)
        && ({
            full_obs.observe_uhrum_annuna_corridor_block();
            !ctx.has(Item::Uhrum_Annuna_Corridor_Block)
        }))
}
pub fn observe_access_invoke_bomberang_and_anuman_and_not_invoke_visited__glacier_gt_fortress_gt_inner_center_gt_shockwave_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $bomberang and Anuman and not $visited(`Glacier > Fortress > Inner Center > Shockwave Block`)
    ((hobserve__bomberang!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
        && (ctx.visited(LocationId::Glacier__Fortress__Inner_Center__Shockwave_Block)))
}
pub fn observe_access_invoke_boomerang(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $boomerang
    hobserve__boomerang!(ctx, world, full_obs)
}
pub fn observe_access_invoke_boomerang2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $boomerang2
    hobserve__boomerang2!(ctx, world, full_obs)
}
pub fn observe_access_invoke_boomerang2_and_ranged_damage_3_and_invoke_weapon_and_melee_damage_3_and_melee_speed_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $boomerang2 and Ranged_Damage_3 and $weapon and Melee_Damage_3 and Melee_Speed_3
    ((((hobserve__boomerang2!(ctx, world, full_obs)
        && ({
            full_obs.observe_ranged_damage_3();
            ctx.has(Item::Ranged_Damage_3)
        }))
        && (hobserve__weapon!(ctx, world, full_obs)))
        && ({
            full_obs.observe_melee_damage_3();
            ctx.has(Item::Melee_Damage_3)
        }))
        && ({
            full_obs.observe_melee_speed_3();
            ctx.has(Item::Melee_Speed_3)
        }))
}
pub fn observe_access_invoke_boomerang_and_fast_travel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $boomerang and Fast_Travel
    (hobserve__boomerang!(ctx, world, full_obs)
        && ({
            full_obs.observe_fast_travel();
            ctx.has(Item::Fast_Travel)
        }))
}
pub fn observe_access_invoke_bs(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $bs
    hobserve__bs!(ctx, world, full_obs)
}
pub fn observe_access_invoke_can_damage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_damage
    hobserve__can_damage!(ctx, world, full_obs)
}
pub fn observe_access_invoke_can_deploy(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy
    hobserve__can_deploy!(ctx, world, full_obs)
}
pub fn observe_access_invoke_can_deploy_and___drone_hover_or_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and (Drone_Hover or Slingshot_Hook)
    (hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        } || {
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_invoke_can_deploy_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Drone_Hover
    (hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
}
pub fn observe_access_invoke_can_deploy_and_drone_hover_and_ebih_walled_off_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Drone_Hover and Ebih_Walled_Off_Wall
    ((hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
        && ({
            full_obs.observe_ebih_walled_off_wall();
            ctx.has(Item::Ebih_Walled_Off_Wall)
        }))
}
pub fn observe_access_invoke_can_deploy_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Drone_Hover and Slingshot_Hook
    ((hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_invoke_can_deploy_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Slingshot_Hook
    (hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_invoke_can_deploy_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $can_deploy and Slingshot_Hook and Drone_Hover
    ((hobserve__can_deploy!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
}
pub fn observe_access_invoke_charge(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $charge
    hobserve__charge!(ctx, world, full_obs)
}
pub fn observe_access_invoke_chargehover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $chargehover
    hobserve__chargehover!(ctx, world, full_obs)
}
pub fn observe_access_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb
    hobserve__climb!(ctx, world, full_obs)
}
pub fn observe_access_invoke_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and Annuna_East_Bridge_Gate
    (hobserve__climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_climb_and_invoke_can_deploy_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and $can_deploy and Drone_Hover and Slingshot_Hook
    (((hobserve__climb!(ctx, world, full_obs) && (hobserve__can_deploy!(ctx, world, full_obs)))
        && ({
            full_obs.observe_drone_hover();
            ctx.has(Item::Drone_Hover)
        }))
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_invoke_climb_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and $grab
    (hobserve__climb!(ctx, world, full_obs) && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_climb_and_invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and $grab and Anuman
    ((hobserve__climb!(ctx, world, full_obs) && (hobserve__grab!(ctx, world, full_obs)))
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
}
pub fn observe_access_invoke_climb_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb and Underwater_Movement
    (hobserve__climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_climb_or___invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb or ($grab and Anuman)
    (hobserve__climb!(ctx, world, full_obs)
        || (hobserve__grab!(ctx, world, full_obs)
            && ({
                full_obs.observe_anuman();
                ctx.has(Item::Anuman)
            })))
}
pub fn observe_access_invoke_climb_or_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $climb or $hook
    (hobserve__climb!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab
    hobserve__grab!(ctx, world, full_obs)
}
pub fn observe_access_invoke_grab_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Annuna_East_Bridge_Gate
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Anuman
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
}
pub fn observe_access_invoke_grab_and_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and ^_door_open
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih__ebih_west__ctx__door_open();
            ctx.ebih__ebih_west__ctx__door_open()
        }))
}
pub fn observe_access_invoke_grab_and_ebih_hidden_portal_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Ebih_Hidden_Portal_Gate
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_hidden_portal_gate();
            ctx.has(Item::Ebih_Hidden_Portal_Gate)
        }))
}
pub fn observe_access_invoke_grab_and_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and ^_mid_susar
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__east_caverns__ctx__mid_susar();
            ctx.giguna__east_caverns__ctx__mid_susar()
        }))
}
pub fn observe_access_invoke_grab_and_giguna__ruins_west__ctx__kishib_handled(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and ^_kishib_handled
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__ruins_west__ctx__kishib_handled();
            ctx.giguna__ruins_west__ctx__kishib_handled()
        }))
}
pub fn observe_access_invoke_grab_and_giguna_gateway_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Giguna_Gateway_Block
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna_gateway_block();
            ctx.has(Item::Giguna_Gateway_Block)
        }))
}
pub fn observe_access_invoke_grab_and_invoke_can_deploy(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and $can_deploy
    (hobserve__grab!(ctx, world, full_obs) && (hobserve__can_deploy!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and $climb
    (hobserve__grab!(ctx, world, full_obs) && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_grab_and_switch_40_12(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Switch_40_12
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_switch_40_12();
            ctx.has(Item::Switch_40_12)
        }))
}
pub fn observe_access_invoke_grab_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab and Underwater_Movement
    (hobserve__grab!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_grab_or_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or Anuman
    (hobserve__grab!(ctx, world, full_obs) || {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })
}
pub fn observe_access_invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $climb
    (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))
}
pub fn observe_access_invoke_grab_or_invoke_climb_or_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $climb or $hook
    ((hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))
        || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_invoke_grab_or_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $hook
    (hobserve__grab!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_invoke_grab_or_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or $hover
    (hobserve__grab!(ctx, world, full_obs) || hobserve__hover!(ctx, world, full_obs))
}
pub fn observe_access_invoke_grab_or_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $grab or Underwater_Movement
    (hobserve__grab!(ctx, world, full_obs) || {
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    })
}
pub fn observe_access_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook
    hobserve__hook!(ctx, world, full_obs)
}
pub fn observe_access_invoke_hook_and_annuna__vertical_room__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_door_opened
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna__vertical_room__ctx__door_opened();
            ctx.annuna__vertical_room__ctx__door_opened()
        }))
}
pub fn observe_access_invoke_hook_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Annuna_East_Bridge_Gate
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_hook_and_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_door_open
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih__ebih_west__ctx__door_open();
            ctx.ebih__ebih_west__ctx__door_open()
        }))
}
pub fn observe_access_invoke_hook_and_ebih_hidden_portal_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Ebih_Hidden_Portal_Gate
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_hidden_portal_gate();
            ctx.has(Item::Ebih_Hidden_Portal_Gate)
        }))
}
pub fn observe_access_invoke_hook_and_emergence_rocks_fall_rock_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Emergence_Rocks_Fall_Rock_2
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_emergence_rocks_fall_rock_2();
            ctx.has(Item::Emergence_Rocks_Fall_Rock_2)
        }))
}
pub fn observe_access_invoke_hook_and_emergence_rocks_fall_rock_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Emergence_Rocks_Fall_Rock_3
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_emergence_rocks_fall_rock_3();
            ctx.has(Item::Emergence_Rocks_Fall_Rock_3)
        }))
}
pub fn observe_access_invoke_hook_and_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Emergence_Rocks_Fall_Rock_4
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_emergence_rocks_fall_rock_4();
            ctx.has(Item::Emergence_Rocks_Fall_Rock_4)
        }))
}
pub fn observe_access_invoke_hook_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_combo_entered
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__east_caverns__ctx__combo_entered();
            ctx.giguna__east_caverns__ctx__combo_entered()
        }))
}
pub fn observe_access_invoke_hook_and_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and ^_mid_susar
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__east_caverns__ctx__mid_susar();
            ctx.giguna__east_caverns__ctx__mid_susar()
        }))
}
pub fn observe_access_invoke_hook_and_giguna_gateway_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Giguna_Gateway_Block
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna_gateway_block();
            ctx.has(Item::Giguna_Gateway_Block)
        }))
}
pub fn observe_access_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover
    (hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_hook_and_invoke_hover_and_emergence_rocks_fall_rock_4(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and Emergence_Rocks_Fall_Rock_4
    ((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_emergence_rocks_fall_rock_4();
            ctx.has(Item::Emergence_Rocks_Fall_Rock_4)
        }))
}
pub fn observe_access_invoke_hook_and_invoke_hover_and_glacier__vertical_room__ctx__upper_gatestone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and ^_upper_gatestone
    ((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_glacier__vertical_room__ctx__upper_gatestone();
            ctx.glacier__vertical_room__ctx__upper_gatestone()
        }))
}
pub fn observe_access_invoke_hook_and_invoke_hover_and_slingshot_charge(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and Slingshot_Charge
    ((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_slingshot_charge();
            ctx.has(Item::Slingshot_Charge)
        }))
}
pub fn observe_access_invoke_hook_and_invoke_hover_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and Slingshot_Weapon
    ((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_slingshot_weapon();
            ctx.has(Item::Slingshot_Weapon)
        }))
}
pub fn observe_access_invoke_hook_and_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and Underwater_Movement
    ((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_hook_and_invoke_hover_and_underwater_movement_and_breach_attractor_and_anuman_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and $hover and Underwater_Movement and Breach_Attractor and Anuman and ^portal == ^portal_start
    (((((hobserve__hook!(ctx, world, full_obs) && (hobserve__hover!(ctx, world, full_obs)))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
        && ({
            full_obs.observe_breach_attractor();
            ctx.has(Item::Breach_Attractor)
        }))
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
        && ({
            let left = {
                full_obs.observe_portal();
                ctx.portal()
            };
            let right = data::portal_start(ctx.position());
            left == right
        }))
}
pub fn observe_access_invoke_hook_and_not_ebih__drone_room__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not ^_platform_moved
    (hobserve__hook!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__drone_room__ctx__platform_moved();
            ctx.ebih__drone_room__ctx__platform_moved()
        })))
}
pub fn observe_access_invoke_hook_and_not_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not Ebih_Waterfall_Block_Left
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_left();
            !ctx.has(Item::Ebih_Waterfall_Block_Left)
        }))
}
pub fn observe_access_invoke_hook_and_not_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and not Ebih_Waterfall_Block_Right
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_ebih_waterfall_block_right();
            !ctx.has(Item::Ebih_Waterfall_Block_Right)
        }))
}
pub fn observe_access_invoke_hook_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook and Underwater_Movement
    (hobserve__hook!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_hook_or___anuman_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or (Anuman and ($grab or $climb))
    (hobserve__hook!(ctx, world, full_obs)
        || ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs))))
}
pub fn observe_access_invoke_hook_or___anuman_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or (Anuman and $climb)
    (hobserve__hook!(ctx, world, full_obs)
        || ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        } && (hobserve__climb!(ctx, world, full_obs))))
}
pub fn observe_access_invoke_hook_or___anuman_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or (Anuman and $grab)
    (hobserve__hook!(ctx, world, full_obs)
        || ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        } && (hobserve__grab!(ctx, world, full_obs))))
}
pub fn observe_access_invoke_hook_or___invoke_grab_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or ($grab and Anuman)
    (hobserve__hook!(ctx, world, full_obs)
        || (hobserve__grab!(ctx, world, full_obs)
            && ({
                full_obs.observe_anuman();
                ctx.has(Item::Anuman)
            })))
}
pub fn observe_access_invoke_hook_or_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or Anuman
    (hobserve__hook!(ctx, world, full_obs) || {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })
}
pub fn observe_access_invoke_hook_or_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hook or $hover
    (hobserve__hook!(ctx, world, full_obs) || hobserve__hover!(ctx, world, full_obs))
}
pub fn observe_access_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover
    hobserve__hookhover!(ctx, world, full_obs)
}
pub fn observe_access_invoke_hookhover_and_amagi_gated_community_gate_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover and Amagi_Gated_Community_Gate and Underwater_Movement
    ((hobserve__hookhover!(ctx, world, full_obs)
        && ({
            full_obs.observe_amagi_gated_community_gate();
            ctx.has(Item::Amagi_Gated_Community_Gate)
        }))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_hookhover_and_amagi_gated_community_gate_and_underwater_movement_and_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover and Amagi_Gated_Community_Gate and Underwater_Movement and ^_dur_esla
    (((hobserve__hookhover!(ctx, world, full_obs)
        && ({
            full_obs.observe_amagi_gated_community_gate();
            ctx.has(Item::Amagi_Gated_Community_Gate)
        }))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
        && ({
            full_obs.observe_amagi__gated_community__ctx__dur_esla();
            ctx.amagi__gated_community__ctx__dur_esla()
        }))
}
pub fn observe_access_invoke_hookhover_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover and Annuna_East_Bridge_Gate
    (hobserve__hookhover!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_hookhover_and_giguna__gateway__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover and ^_door_opened
    (hobserve__hookhover!(ctx, world, full_obs)
        && ({
            full_obs.observe_giguna__gateway__ctx__door_opened();
            ctx.giguna__gateway__ctx__door_opened()
        }))
}
pub fn observe_access_invoke_hookhover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover and Underwater_Movement
    (hobserve__hookhover!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_hookhover_and_underwater_movement_and_amagi_gated_community_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover and Underwater_Movement and Amagi_Gated_Community_Gate
    ((hobserve__hookhover!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
        && ({
            full_obs.observe_amagi_gated_community_gate();
            ctx.has(Item::Amagi_Gated_Community_Gate)
        }))
}
pub fn observe_access_invoke_hookhover_or_invoke_spin(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hookhover or $spin
    (hobserve__hookhover!(ctx, world, full_obs) || hobserve__spin!(ctx, world, full_obs))
}
pub fn observe_access_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover
    hobserve__hover!(ctx, world, full_obs)
}
pub fn observe_access_invoke_hover_and_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Anuman
    (hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
}
pub fn observe_access_invoke_hover_and_anuman_and_underwater_movement_and___boomerang_or_boomerang_upgrade(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Anuman and Underwater_Movement and (Boomerang or Boomerang_Upgrade)
    (((hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
        && ({
            full_obs.observe_boomerang();
            ctx.has(Item::Boomerang)
        } || {
            full_obs.observe_boomerang_upgrade();
            ctx.has(Item::Boomerang_Upgrade)
        }))
}
pub fn observe_access_invoke_hover_and_anuman_and_wall_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Anuman and Wall_Climb
    ((hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
        && ({
            full_obs.observe_wall_climb();
            ctx.has(Item::Wall_Climb)
        }))
}
pub fn observe_access_invoke_hover_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook
    (hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_hover_and_invoke_hook_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook and ^_combo_entered
    ((hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && ({
            full_obs.observe_giguna__east_caverns__ctx__combo_entered();
            ctx.giguna__east_caverns__ctx__combo_entered()
        }))
}
pub fn observe_access_invoke_hover_and_invoke_hook_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook and Nanite_Mist
    ((hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && ({
            full_obs.observe_nanite_mist();
            ctx.has(Item::Nanite_Mist)
        }))
}
pub fn observe_access_invoke_hover_and_invoke_hook_and_not_irikar__midwest__ctx__left_platform(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and $hook and not ^_left_platform
    ((hobserve__hover!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_irikar__midwest__ctx__left_platform();
            ctx.irikar__midwest__ctx__left_platform()
        })))
}
pub fn observe_access_invoke_hover_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Nanite_Mist
    (hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_nanite_mist();
            ctx.has(Item::Nanite_Mist)
        }))
}
pub fn observe_access_invoke_hover_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and not ^_left_platform_moved
    (hobserve__hover!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_invoke_hover_and_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Underwater_Movement
    (hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
}
pub fn observe_access_invoke_hover_and_underwater_movement_and_breach_attractor_and_anuman_and_portal_eq_portal_start(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover and Underwater_Movement and Breach_Attractor and Anuman and ^portal == ^portal_start
    ((((hobserve__hover!(ctx, world, full_obs)
        && ({
            full_obs.observe_underwater_movement();
            ctx.has(Item::Underwater_Movement)
        }))
        && ({
            full_obs.observe_breach_attractor();
            ctx.has(Item::Breach_Attractor)
        }))
        && ({
            full_obs.observe_anuman();
            ctx.has(Item::Anuman)
        }))
        && ({
            let left = {
                full_obs.observe_portal();
                ctx.portal()
            };
            let right = data::portal_start(ctx.position());
            left == right
        }))
}
pub fn observe_access_invoke_hover_or_anuman(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover or Anuman
    (hobserve__hover!(ctx, world, full_obs) || {
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })
}
pub fn observe_access_invoke_hover_or_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover or $grab
    (hobserve__hover!(ctx, world, full_obs) || hobserve__grab!(ctx, world, full_obs))
}
pub fn observe_access_invoke_hover_or_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover or $hook
    (hobserve__hover!(ctx, world, full_obs) || hobserve__hook!(ctx, world, full_obs))
}
pub fn observe_access_invoke_hover_or_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $hover or Nanite_Mist
    (hobserve__hover!(ctx, world, full_obs) || {
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    })
}
pub fn observe_access_invoke_infinite_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb
    hobserve__infinite_climb!(ctx, world, full_obs)
}
pub fn observe_access_invoke_infinite_climb_and_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and Annuna_East_Bridge_Gate
    (hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_infinite_climb_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and not Annuna_East_Bridge_Gate
    (hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            !ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_infinite_climb_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and Slingshot_Hook
    (hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
}
pub fn observe_access_invoke_infinite_climb_and_slingshot_hook_and_not_annuna_east_bridge_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $infinite_climb and Slingshot_Hook and not Annuna_East_Bridge_Gate
    ((hobserve__infinite_climb!(ctx, world, full_obs)
        && ({
            full_obs.observe_slingshot_hook();
            ctx.has(Item::Slingshot_Hook)
        }))
        && ({
            full_obs.observe_annuna_east_bridge_gate();
            !ctx.has(Item::Annuna_East_Bridge_Gate)
        }))
}
pub fn observe_access_invoke_melee(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $melee
    hobserve__melee!(ctx, world, full_obs)
}
pub fn observe_access_invoke_melee_and_not_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $melee and not ^_dur_esla
    (hobserve__melee!(ctx, world, full_obs)
        && (!({
            full_obs.observe_amagi__gated_community__ctx__dur_esla();
            ctx.amagi__gated_community__ctx__dur_esla()
        })))
}
pub fn observe_access_invoke_melee_and_not_amagi__secret_chamber__ctx__east_dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $melee and not ^_east_dur_esla
    (hobserve__melee!(ctx, world, full_obs)
        && (!({
            full_obs.observe_amagi__secret_chamber__ctx__east_dur_esla();
            ctx.amagi__secret_chamber__ctx__east_dur_esla()
        })))
}
pub fn observe_access_invoke_melee_and_not_amagi__secret_chamber__ctx__west_dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $melee and not ^_west_dur_esla
    (hobserve__melee!(ctx, world, full_obs)
        && (!({
            full_obs.observe_amagi__secret_chamber__ctx__west_dur_esla();
            ctx.amagi__secret_chamber__ctx__west_dur_esla()
        })))
}
pub fn observe_access_invoke_melee_cskip(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $melee_cskip
    hobserve__melee_cskip!(ctx, world, full_obs)
}
pub fn observe_access_invoke_melee_cskip_and_fast_travel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $melee_cskip and Fast_Travel
    (hobserve__melee_cskip!(ctx, world, full_obs)
        && ({
            full_obs.observe_fast_travel();
            ctx.has(Item::Fast_Travel)
        }))
}
pub fn observe_access_invoke_more_refills(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $more_refills
    hobserve__more_refills!(ctx, world, full_obs)
}
pub fn observe_access_invoke_offset(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $offset
    hobserve__offset!(ctx, world, full_obs)
}
pub fn observe_access_invoke_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open
    hobserve__open!(ctx, world, full_obs)
}
pub fn observe_access_invoke_open_and_invoke_range1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range1
    (hobserve__open!(ctx, world, full_obs) && (hobserve__range1!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range2
    (hobserve__open!(ctx, world, full_obs) && (hobserve__range2!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_open_and_invoke_range2_and_not_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range2 and not ^_doors_opened
    ((hobserve__open!(ctx, world, full_obs) && (hobserve__range2!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_annuna__west_bridge__ctx__doors_opened();
            ctx.annuna__west_bridge__ctx__doors_opened()
        })))
}
pub fn observe_access_invoke_open_and_invoke_range3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and $range3
    (hobserve__open!(ctx, world, full_obs) && (hobserve__range3!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_open_and_not_annuna__west_bridge__ctx__doors_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and not ^_doors_opened
    (hobserve__open!(ctx, world, full_obs)
        && (!({
            full_obs.observe_annuna__west_bridge__ctx__doors_opened();
            ctx.annuna__west_bridge__ctx__doors_opened()
        })))
}
pub fn observe_access_invoke_open_and_not_ebih__vertical_interchange__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and not ^_door_open
    (hobserve__open!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__vertical_interchange__ctx__door_open();
            ctx.ebih__vertical_interchange__ctx__door_open()
        })))
}
pub fn observe_access_invoke_open_and_not_ebih__vertical_interchange__ctx__door_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $open and not ^_door_open and $range2
    ((hobserve__open!(ctx, world, full_obs)
        && (!({
            full_obs.observe_ebih__vertical_interchange__ctx__door_open();
            ctx.ebih__vertical_interchange__ctx__door_open()
        })))
        && (hobserve__range2!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_overheat(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $overheat
    hobserve__overheat!(ctx, world, full_obs)
}
pub fn observe_access_invoke_overheat_and_invoke_can_damage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $overheat and $can_damage
    (hobserve__overheat!(ctx, world, full_obs) && (hobserve__can_damage!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_platform_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $platform and $hook and $hover
    ((hobserve__platform!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_platform_and_invoke_hook_and_not_ebih__base_camp__ctx__left_platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $platform and $hook and not ^_left_platform_moved
    ((hobserve__platform!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_ebih__base_camp__ctx__left_platform_moved();
            ctx.ebih__base_camp__ctx__left_platform_moved()
        })))
}
pub fn observe_access_invoke_remote_boomerang(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $remote_boomerang
    hobserve__remote_boomerang!(ctx, world, full_obs)
}
pub fn observe_access_invoke_shockwave(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave
    hobserve__shockwave!(ctx, world, full_obs)
}
pub fn observe_access_invoke_shockwave_and_not_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave and not ^_dur_esla
    (hobserve__shockwave!(ctx, world, full_obs)
        && (!({
            full_obs.observe_amagi__gated_community__ctx__dur_esla();
            ctx.amagi__gated_community__ctx__dur_esla()
        })))
}
pub fn observe_access_invoke_shockwave_and_not_amagi__secret_chamber__ctx__east_dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave and not ^_east_dur_esla
    (hobserve__shockwave!(ctx, world, full_obs)
        && (!({
            full_obs.observe_amagi__secret_chamber__ctx__east_dur_esla();
            ctx.amagi__secret_chamber__ctx__east_dur_esla()
        })))
}
pub fn observe_access_invoke_shockwave_and_not_amagi__secret_chamber__ctx__west_dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave and not ^_west_dur_esla
    (hobserve__shockwave!(ctx, world, full_obs)
        && (!({
            full_obs.observe_amagi__secret_chamber__ctx__west_dur_esla();
            ctx.amagi__secret_chamber__ctx__west_dur_esla()
        })))
}
pub fn observe_access_invoke_shockwave_and_not_defeat_mus_a_m20(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $shockwave and not Defeat_MUS_A_M20
    (hobserve__shockwave!(ctx, world, full_obs)
        && ({
            full_obs.observe_defeat_mus_a_m20();
            !ctx.has(Item::Defeat_MUS_A_M20)
        }))
}
pub fn observe_access_invoke_slow(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $slow
    hobserve__slow!(ctx, world, full_obs)
}
pub fn observe_access_invoke_spin(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $spin
    hobserve__spin!(ctx, world, full_obs)
}
pub fn observe_access_invoke_spinhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $spinhover
    hobserve__spinhover!(ctx, world, full_obs)
}
pub fn observe_access_invoke_sync(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $sync
    hobserve__sync!(ctx, world, full_obs)
}
pub fn observe_access_invoke_sync_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $sync and $hook
    (hobserve__sync!(ctx, world, full_obs) && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_unlock3_and_invoke_range2_and_not_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and $range2 and not ^_door_opened
    ((hobserve__unlock3!(ctx, world, full_obs) && (hobserve__range2!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
            ctx.giguna__giguna_northeast__ctx__door_opened()
        })))
}
pub fn observe_access_invoke_unlock3_and_not_giguna__carnelian__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and not ^_door_opened
    (hobserve__unlock3!(ctx, world, full_obs)
        && (!({
            full_obs.observe_giguna__carnelian__ctx__door_opened();
            ctx.giguna__carnelian__ctx__door_opened()
        })))
}
pub fn observe_access_invoke_unlock3_and_not_giguna__giguna_northeast__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and not ^_door_opened
    (hobserve__unlock3!(ctx, world, full_obs)
        && (!({
            full_obs.observe_giguna__giguna_northeast__ctx__door_opened();
            ctx.giguna__giguna_northeast__ctx__door_opened()
        })))
}
pub fn observe_access_invoke_unlock3_and_not_glacier__lonely_bull__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock3 and not ^_door
    (hobserve__unlock3!(ctx, world, full_obs)
        && (!({
            full_obs.observe_glacier__lonely_bull__ctx__door();
            ctx.glacier__lonely_bull__ctx__door()
        })))
}
pub fn observe_access_invoke_unlock4_and_invoke_range2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and $range2
    (hobserve__unlock4!(ctx, world, full_obs) && (hobserve__range2!(ctx, world, full_obs)))
}
pub fn observe_access_invoke_unlock4_and_invoke_range2_and_not_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and $range2 and not ^_door_open
    ((hobserve__unlock4!(ctx, world, full_obs) && (hobserve__range2!(ctx, world, full_obs)))
        && (!({
            full_obs.observe_emergence__storage__ctx__door_open();
            ctx.emergence__storage__ctx__door_open()
        })))
}
pub fn observe_access_invoke_unlock4_and_not_annuna__boss_gate__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and not ^_door
    (hobserve__unlock4!(ctx, world, full_obs)
        && (!({
            full_obs.observe_annuna__boss_gate__ctx__door();
            ctx.annuna__boss_gate__ctx__door()
        })))
}
pub fn observe_access_invoke_unlock4_and_not_annuna__udug_gate__ctx__door(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and not ^_door
    (hobserve__unlock4!(ctx, world, full_obs)
        && (!({
            full_obs.observe_annuna__udug_gate__ctx__door();
            ctx.annuna__udug_gate__ctx__door()
        })))
}
pub fn observe_access_invoke_unlock4_and_not_annuna__west_climb__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and not ^_door_opened
    (hobserve__unlock4!(ctx, world, full_obs)
        && (!({
            full_obs.observe_annuna__west_climb__ctx__door_opened();
            ctx.annuna__west_climb__ctx__door_opened()
        })))
}
pub fn observe_access_invoke_unlock4_and_not_emergence__storage__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // $unlock4 and not ^_door_open
    (hobserve__unlock4!(ctx, world, full_obs)
        && (!({
            full_obs.observe_emergence__storage__ctx__door_open();
            ctx.emergence__storage__ctx__door_open()
        })))
}
pub fn observe_access_irikar__basement_portal__ctx__platform_moved_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^_platform_moved and $hook
    ({
        full_obs.observe_irikar__basement_portal__ctx__platform_moved();
        ctx.irikar__basement_portal__ctx__platform_moved()
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_irikar_breach_buried_treasure_pillar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Breach_Buried_Treasure_Pillar
    {
        full_obs.observe_irikar_breach_buried_treasure_pillar();
        ctx.has(Item::Irikar_Breach_Buried_Treasure_Pillar)
    }
}
pub fn observe_access_irikar_breach_uhrum_connector_wall_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Breach_Uhrum_Connector_Wall and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_irikar_breach_uhrum_connector_wall();
        ctx.has(Item::Irikar_Breach_Uhrum_Connector_Wall)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_irikar_gudam(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Gudam
    {
        full_obs.observe_irikar_gudam();
        ctx.has(Item::Irikar_Gudam)
    }
}
pub fn observe_access_irikar_gudam_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Gudam and $shockwave
    ({
        full_obs.observe_irikar_gudam();
        ctx.has(Item::Irikar_Gudam)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_irikar_royal_storage_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Irikar_Royal_Storage_Wall
    {
        full_obs.observe_irikar_royal_storage_wall();
        ctx.has(Item::Irikar_Royal_Storage_Wall)
    }
}
pub fn observe_access_map__amagi__east_lake__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi__east_lake__save
    {
        full_obs.observe_map__amagi__east_lake__save();
        ctx.map__amagi__east_lake__save()
    }
}
pub fn observe_access_map__amagi__main_area__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi__main_area__save
    {
        full_obs.observe_map__amagi__main_area__save();
        ctx.map__amagi__main_area__save()
    }
}
pub fn observe_access_map__amagi_breach__divided__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi_breach__divided__save
    {
        full_obs.observe_map__amagi_breach__divided__save();
        ctx.map__amagi_breach__divided__save()
    }
}
pub fn observe_access_map__amagi_breach__east_entrance__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi_breach__east_entrance__save
    {
        full_obs.observe_map__amagi_breach__east_entrance__save();
        ctx.map__amagi_breach__east_entrance__save()
    }
}
pub fn observe_access_map__amagi_breach__east_ruins__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi_breach__east_ruins__save
    {
        full_obs.observe_map__amagi_breach__east_ruins__save();
        ctx.map__amagi_breach__east_ruins__save()
    }
}
pub fn observe_access_map__amagi_breach__upper_lake__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__amagi_breach__upper_lake__save
    {
        full_obs.observe_map__amagi_breach__upper_lake__save();
        ctx.map__amagi_breach__upper_lake__save()
    }
}
pub fn observe_access_map__annuna__center_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__center_save__save
    {
        full_obs.observe_map__annuna__center_save__save();
        ctx.map__annuna__center_save__save()
    }
}
pub fn observe_access_map__annuna__factory_entrance__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__factory_entrance__save
    {
        full_obs.observe_map__annuna__factory_entrance__save();
        ctx.map__annuna__factory_entrance__save()
    }
}
pub fn observe_access_map__annuna__mirror_match__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__mirror_match__save
    {
        full_obs.observe_map__annuna__mirror_match__save();
        ctx.map__annuna__mirror_match__save()
    }
}
pub fn observe_access_map__annuna__upper_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__upper_save__save
    {
        full_obs.observe_map__annuna__upper_save__save();
        ctx.map__annuna__upper_save__save()
    }
}
pub fn observe_access_map__annuna__vertical_room__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna__vertical_room__save
    {
        full_obs.observe_map__annuna__vertical_room__save();
        ctx.map__annuna__vertical_room__save()
    }
}
pub fn observe_access_map__annuna_breach__bottom__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna_breach__bottom__save
    {
        full_obs.observe_map__annuna_breach__bottom__save();
        ctx.map__annuna_breach__bottom__save()
    }
}
pub fn observe_access_map__annuna_breach__bridge__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna_breach__bridge__save
    {
        full_obs.observe_map__annuna_breach__bridge__save();
        ctx.map__annuna_breach__bridge__save()
    }
}
pub fn observe_access_map__annuna_breach__double_corridor__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna_breach__double_corridor__save
    {
        full_obs.observe_map__annuna_breach__double_corridor__save();
        ctx.map__annuna_breach__double_corridor__save()
    }
}
pub fn observe_access_map__annuna_breach__enclosed__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna_breach__enclosed__save
    {
        full_obs.observe_map__annuna_breach__enclosed__save();
        ctx.map__annuna_breach__enclosed__save()
    }
}
pub fn observe_access_map__annuna_breach__north_hallway__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna_breach__north_hallway__save
    {
        full_obs.observe_map__annuna_breach__north_hallway__save();
        ctx.map__annuna_breach__north_hallway__save()
    }
}
pub fn observe_access_map__annuna_breach__rear_entrance__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__annuna_breach__rear_entrance__save
    {
        full_obs.observe_map__annuna_breach__rear_entrance__save();
        ctx.map__annuna_breach__rear_entrance__save()
    }
}
pub fn observe_access_map__ebih__base_camp__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__base_camp__save
    {
        full_obs.observe_map__ebih__base_camp__save();
        ctx.map__ebih__base_camp__save()
    }
}
pub fn observe_access_map__ebih__ebih_west__lower_save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__ebih_west__lower_save
    {
        full_obs.observe_map__ebih__ebih_west__lower_save();
        ctx.map__ebih__ebih_west__lower_save()
    }
}
pub fn observe_access_map__ebih__ebih_west__mid_save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__ebih_west__mid_save
    {
        full_obs.observe_map__ebih__ebih_west__mid_save();
        ctx.map__ebih__ebih_west__mid_save()
    }
}
pub fn observe_access_map__ebih__ebih_west__upper_save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__ebih_west__upper_save
    {
        full_obs.observe_map__ebih__ebih_west__upper_save();
        ctx.map__ebih__ebih_west__upper_save()
    }
}
pub fn observe_access_map__ebih__hidden_portal__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih__hidden_portal__save
    {
        full_obs.observe_map__ebih__hidden_portal__save();
        ctx.map__ebih__hidden_portal__save()
    }
}
pub fn observe_access_map__ebih_breach__in_n_out__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih_breach__in_n_out__save
    {
        full_obs.observe_map__ebih_breach__in_n_out__save();
        ctx.map__ebih_breach__in_n_out__save()
    }
}
pub fn observe_access_map__ebih_breach__peak__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih_breach__peak__save
    {
        full_obs.observe_map__ebih_breach__peak__save();
        ctx.map__ebih_breach__peak__save()
    }
}
pub fn observe_access_map__ebih_breach__portals_101__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih_breach__portals_101__save
    {
        full_obs.observe_map__ebih_breach__portals_101__save();
        ctx.map__ebih_breach__portals_101__save()
    }
}
pub fn observe_access_map__ebih_breach__rock_block__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__ebih_breach__rock_block__save
    {
        full_obs.observe_map__ebih_breach__rock_block__save();
        ctx.map__ebih_breach__rock_block__save()
    }
}
pub fn observe_access_map__emergence__camp_exterior__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__emergence__camp_exterior__save
    {
        full_obs.observe_map__emergence__camp_exterior__save();
        ctx.map__emergence__camp_exterior__save()
    }
}
pub fn observe_access_map__giguna__giguna_base__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__giguna_base__save
    {
        full_obs.observe_map__giguna__giguna_base__save();
        ctx.map__giguna__giguna_base__save()
    }
}
pub fn observe_access_map__giguna__giguna_northeast__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__giguna_northeast__save
    {
        full_obs.observe_map__giguna__giguna_northeast__save();
        ctx.map__giguna__giguna_northeast__save()
    }
}
pub fn observe_access_map__giguna__labyrinth__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__labyrinth__save
    {
        full_obs.observe_map__giguna__labyrinth__save();
        ctx.map__giguna__labyrinth__save()
    }
}
pub fn observe_access_map__giguna__ruins_top__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__ruins_top__save
    {
        full_obs.observe_map__giguna__ruins_top__save();
        ctx.map__giguna__ruins_top__save()
    }
}
pub fn observe_access_map__giguna__ruins_west__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__ruins_west__save
    {
        full_obs.observe_map__giguna__ruins_west__save();
        ctx.map__giguna__ruins_west__save()
    }
}
pub fn observe_access_map__giguna__separator__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna__separator__save
    {
        full_obs.observe_map__giguna__separator__save();
        ctx.map__giguna__separator__save()
    }
}
pub fn observe_access_map__giguna_breach__east__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__east__save
    {
        full_obs.observe_map__giguna_breach__east__save();
        ctx.map__giguna_breach__east__save()
    }
}
pub fn observe_access_map__giguna_breach__labyrinth__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__labyrinth__save
    {
        full_obs.observe_map__giguna_breach__labyrinth__save();
        ctx.map__giguna_breach__labyrinth__save()
    }
}
pub fn observe_access_map__giguna_breach__peak__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__peak__save
    {
        full_obs.observe_map__giguna_breach__peak__save();
        ctx.map__giguna_breach__peak__save()
    }
}
pub fn observe_access_map__giguna_breach__south__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__south__save
    {
        full_obs.observe_map__giguna_breach__south__save();
        ctx.map__giguna_breach__south__save()
    }
}
pub fn observe_access_map__giguna_breach__sw_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__giguna_breach__sw_save__save
    {
        full_obs.observe_map__giguna_breach__sw_save__save();
        ctx.map__giguna_breach__sw_save__save()
    }
}
pub fn observe_access_map__glacier__revival__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier__revival__save
    {
        full_obs.observe_map__glacier__revival__save();
        ctx.map__glacier__revival__save()
    }
}
pub fn observe_access_map__glacier_breach__guarded_corridor__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier_breach__guarded_corridor__save
    {
        full_obs.observe_map__glacier_breach__guarded_corridor__save();
        ctx.map__glacier_breach__guarded_corridor__save()
    }
}
pub fn observe_access_map__glacier_breach__hammonds_breach__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier_breach__hammonds_breach__save
    {
        full_obs.observe_map__glacier_breach__hammonds_breach__save();
        ctx.map__glacier_breach__hammonds_breach__save()
    }
}
pub fn observe_access_map__glacier_breach__save_and_exit__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier_breach__save_and_exit__save
    {
        full_obs.observe_map__glacier_breach__save_and_exit__save();
        ctx.map__glacier_breach__save_and_exit__save()
    }
}
pub fn observe_access_map__glacier_breach__south_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier_breach__south_save__save
    {
        full_obs.observe_map__glacier_breach__south_save__save();
        ctx.map__glacier_breach__south_save__save()
    }
}
pub fn observe_access_map__glacier_breach__west_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__glacier_breach__west_save__save
    {
        full_obs.observe_map__glacier_breach__west_save__save();
        ctx.map__glacier_breach__west_save__save()
    }
}
pub fn observe_access_map__irikar__beach_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar__beach_save__save
    {
        full_obs.observe_map__irikar__beach_save__save();
        ctx.map__irikar__beach_save__save()
    }
}
pub fn observe_access_map__irikar__hub__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar__hub__save
    {
        full_obs.observe_map__irikar__hub__save();
        ctx.map__irikar__hub__save()
    }
}
pub fn observe_access_map__irikar__midwest__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar__midwest__save
    {
        full_obs.observe_map__irikar__midwest__save();
        ctx.map__irikar__midwest__save()
    }
}
pub fn observe_access_map__irikar_breach__basement_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar_breach__basement_save__save
    {
        full_obs.observe_map__irikar_breach__basement_save__save();
        ctx.map__irikar_breach__basement_save__save()
    }
}
pub fn observe_access_map__irikar_breach__corridor__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar_breach__corridor__save
    {
        full_obs.observe_map__irikar_breach__corridor__save();
        ctx.map__irikar_breach__corridor__save()
    }
}
pub fn observe_access_map__irikar_breach__gauntlet__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar_breach__gauntlet__save
    {
        full_obs.observe_map__irikar_breach__gauntlet__save();
        ctx.map__irikar_breach__gauntlet__save()
    }
}
pub fn observe_access_map__irikar_breach__save_room__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__irikar_breach__save_room__save
    {
        full_obs.observe_map__irikar_breach__save_room__save();
        ctx.map__irikar_breach__save_room__save()
    }
}
pub fn observe_access_map__uhrum__annuna_corridor__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__annuna_corridor__save
    {
        full_obs.observe_map__uhrum__annuna_corridor__save();
        ctx.map__uhrum__annuna_corridor__save()
    }
}
pub fn observe_access_map__uhrum__emergence_save__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__emergence_save__save
    {
        full_obs.observe_map__uhrum__emergence_save__save();
        ctx.map__uhrum__emergence_save__save()
    }
}
pub fn observe_access_map__uhrum__save_room__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__save_room__save
    {
        full_obs.observe_map__uhrum__save_room__save();
        ctx.map__uhrum__save_room__save()
    }
}
pub fn observe_access_map__uhrum__west_entrance__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum__west_entrance__save
    {
        full_obs.observe_map__uhrum__west_entrance__save();
        ctx.map__uhrum__west_entrance__save()
    }
}
pub fn observe_access_map__uhrum_breach__annuna_gate__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum_breach__annuna_gate__save
    {
        full_obs.observe_map__uhrum_breach__annuna_gate__save();
        ctx.map__uhrum_breach__annuna_gate__save()
    }
}
pub fn observe_access_map__uhrum_breach__east_glitch__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum_breach__east_glitch__save
    {
        full_obs.observe_map__uhrum_breach__east_glitch__save();
        ctx.map__uhrum_breach__east_glitch__save()
    }
}
pub fn observe_access_map__uhrum_breach__locked_down__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum_breach__locked_down__save
    {
        full_obs.observe_map__uhrum_breach__locked_down__save();
        ctx.map__uhrum_breach__locked_down__save()
    }
}
pub fn observe_access_map__uhrum_breach__save_and_go__save(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^map__uhrum_breach__save_and_go__save
    {
        full_obs.observe_map__uhrum_breach__save_and_go__save();
        ctx.map__uhrum_breach__save_and_go__save()
    }
}
pub fn observe_access_melee_damage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Damage
    {
        full_obs.observe_melee_damage();
        ctx.has(Item::Melee_Damage)
    }
}
pub fn observe_access_melee_damage_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Damage_2
    {
        full_obs.observe_melee_damage_2();
        ctx.has(Item::Melee_Damage_2)
    }
}
pub fn observe_access_melee_speed(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Speed
    {
        full_obs.observe_melee_speed();
        ctx.has(Item::Melee_Speed)
    }
}
pub fn observe_access_melee_speed_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Melee_Speed_2
    {
        full_obs.observe_melee_speed_2();
        ctx.has(Item::Melee_Speed_2)
    }
}
pub fn observe_access_mode_eq_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone'
    {
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    }
}
pub fn observe_access_mode_eq_drone_and_apocalypse_seals_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Apocalypse_Seals_Wall
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_apocalypse_seals_wall();
        ctx.has(Item::Apocalypse_Seals_Wall)
    }))
}
pub fn observe_access_mode_eq_drone_and_drone_melee_damage_3_and_drone_melee_speed_2_and_infect(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Drone_Melee_Damage_3 and Drone_Melee_Speed_2 and Infect
    ((({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_drone_melee_damage_3();
        ctx.has(Item::Drone_Melee_Damage_3)
    })) && ({
        full_obs.observe_drone_melee_speed_2();
        ctx.has(Item::Drone_Melee_Speed_2)
    })) && ({
        full_obs.observe_infect();
        ctx.has(Item::Infect)
    }))
}
pub fn observe_access_mode_eq_drone_and_ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Left
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_ebih_waterfall_block_left();
        ctx.has(Item::Ebih_Waterfall_Block_Left)
    }))
}
pub fn observe_access_mode_eq_drone_and_ebih_waterfall_block_right(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Ebih_Waterfall_Block_Right
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_ebih_waterfall_block_right();
        ctx.has(Item::Ebih_Waterfall_Block_Right)
    }))
}
pub fn observe_access_mode_eq_drone_and_fast_travel(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Fast_Travel
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_fast_travel();
        ctx.has(Item::Fast_Travel)
    }))
}
pub fn observe_access_mode_eq_drone_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and ^_combo_entered
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_mode_eq_drone_and_giguna_dual_path_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Giguna_Dual_Path_Wall
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_giguna_dual_path_wall();
        ctx.has(Item::Giguna_Dual_Path_Wall)
    }))
}
pub fn observe_access_mode_eq_drone_and_giguna_wasteland_passage_h(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Giguna_Wasteland_Passage_H
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_giguna_wasteland_passage_h();
        ctx.has(Item::Giguna_Wasteland_Passage_H)
    }))
}
pub fn observe_access_mode_eq_drone_and_indra_eq_giguna_gt_separator_gt_platform(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and ^indra == `Giguna > Separator > Platform`
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        let left = {
            full_obs.observe_indra();
            ctx.indra()
        };
        left == SpotId::Giguna__Separator__Platform
    }))
}
pub fn observe_access_mode_eq_drone_and_mist_upgrade_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Mist_Upgrade and ^_combo_entered
    (({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_mist_upgrade();
        ctx.has(Item::Mist_Upgrade)
    })) && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_mode_eq_drone_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Nanite_Mist
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_mode_eq_drone_and_nanite_mist_and_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Nanite_Mist and ^_combo_entered
    (({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    })) && ({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    }))
}
pub fn observe_access_mode_eq_drone_and_portal_eq_position_and_flipside_ne_invoke_default_and___not_portal_hidden_or_breach_sight_and_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and ^portal == ^position and ^flipside != $default and (not ^portal_hidden or Breach_Sight) and not Apocalypse_Bomb
    (((({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        let left = {
            full_obs.observe_portal();
            ctx.portal()
        };
        let right = {
            full_obs.observe_position();
            ctx.position()
        };
        left == right
    })) && ({
        let left = data::flipside(ctx.position());
        let right = Default::default();
        left != right
    })) && (!(data::portal_hidden(ctx.position())) || {
        full_obs.observe_breach_sight();
        ctx.has(Item::Breach_Sight)
    })) && ({
        full_obs.observe_apocalypse_bomb();
        !ctx.has(Item::Apocalypse_Bomb)
    }))
}
pub fn observe_access_mode_eq_drone_and_sniper_valley_rock_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Sniper_Valley_Rock_2
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_sniper_valley_rock_2();
        ctx.has(Item::Sniper_Valley_Rock_2)
    }))
}
pub fn observe_access_mode_eq_drone_and_uhrum_west_glitch(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode == 'drone' and Uhrum_West_Glitch
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    } && ({
        full_obs.observe_uhrum_west_glitch();
        ctx.has(Item::Uhrum_West_Glitch)
    }))
}
pub fn observe_access_mode_ne_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode != 'drone'
    {
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    }
}
pub fn observe_access_mode_ne_drone_and_ice_axe(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode != 'drone' and Ice_Axe
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    } && ({
        full_obs.observe_ice_axe();
        ctx.has(Item::Ice_Axe)
    }))
}
pub fn observe_access_mode_ne_drone_and_invoke_infinite_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^mode != 'drone' and $infinite_climb
    ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    } && (hobserve__infinite_climb!(ctx, world, full_obs)))
}
pub fn observe_access_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nanite_Mist
    {
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }
}
pub fn observe_access_nanite_mist_and_amagi__gated_community__ctx__dur_esla(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nanite_Mist and ^_dur_esla
    ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    } && ({
        full_obs.observe_amagi__gated_community__ctx__dur_esla();
        ctx.amagi__gated_community__ctx__dur_esla()
    }))
}
pub fn observe_access_nanite_mist_and_not_irikar__midwest__ctx__right_platform(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nanite_Mist and not ^_right_platform
    ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    } && (!({
        full_obs.observe_irikar__midwest__ctx__right_platform();
        ctx.irikar__midwest__ctx__right_platform()
    })))
}
pub fn observe_access_nano_points(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nano_Points
    {
        full_obs.observe_nano_points();
        ctx.has(Item::Nano_Points)
    }
}
pub fn observe_access_nano_points_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Nano_Points_2
    {
        full_obs.observe_nano_points_2();
        ctx.has(Item::Nano_Points_2)
    }
}
pub fn observe_access_not_amagi__main_area__ctx__combo(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo
    !({
        full_obs.observe_amagi__main_area__ctx__combo();
        ctx.amagi__main_area__ctx__combo()
    })
}
pub fn observe_access_not_amashilama(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT Amashilama
    {
        full_obs.observe_amashilama();
        !ctx.has(Item::Amashilama)
    }
}
pub fn observe_access_not_annuna__boss_gate__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door and Nanite_Mist
    (!({
        full_obs.observe_annuna__boss_gate__ctx__door();
        ctx.annuna__boss_gate__ctx__door()
    }) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_not_annuna__east_bridge__ctx__combo(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo
    !({
        full_obs.observe_annuna__east_bridge__ctx__combo();
        ctx.annuna__east_bridge__ctx__combo()
    })
}
pub fn observe_access_not_annuna__udug_gate__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door and Nanite_Mist
    (!({
        full_obs.observe_annuna__udug_gate__ctx__door();
        ctx.annuna__udug_gate__ctx__door()
    }) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_not_apocalypse_bomb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Apocalypse_Bomb
    {
        full_obs.observe_apocalypse_bomb();
        !ctx.has(Item::Apocalypse_Bomb)
    }
}
pub fn observe_access_not_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Drone_Hover
    {
        full_obs.observe_drone_hover();
        !ctx.has(Item::Drone_Hover)
    }
}
pub fn observe_access_not_drone_melee_damage_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Drone_Melee_Damage_3
    {
        full_obs.observe_drone_melee_damage_3();
        !ctx.has(Item::Drone_Melee_Damage_3)
    }
}
pub fn observe_access_not_drone_melee_speed_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Drone_Melee_Speed_3
    {
        full_obs.observe_drone_melee_speed_3();
        !ctx.has(Item::Drone_Melee_Speed_3)
    }
}
pub fn observe_access_not_ebih__ebih_east__ctx__platform2_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform2_moved
    !({
        full_obs.observe_ebih__ebih_east__ctx__platform2_moved();
        ctx.ebih__ebih_east__ctx__platform2_moved()
    })
}
pub fn observe_access_not_ebih__ebih_west__ctx__door_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_open
    !({
        full_obs.observe_ebih__ebih_west__ctx__door_open();
        ctx.ebih__ebih_west__ctx__door_open()
    })
}
pub fn observe_access_not_ebih__ebih_west__ctx__door_open_or_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_open or $grab
    (!({
        full_obs.observe_ebih__ebih_west__ctx__door_open();
        ctx.ebih__ebih_west__ctx__door_open()
    }) || hobserve__grab!(ctx, world, full_obs))
}
pub fn observe_access_not_ebih__truck_gate__ctx__door_open_and_invoke_open(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_open and $open
    (!({
        full_obs.observe_ebih__truck_gate__ctx__door_open();
        ctx.ebih__truck_gate__ctx__door_open()
    }) && (hobserve__open!(ctx, world, full_obs)))
}
pub fn observe_access_not_ebih__truck_gate__ctx__door_open_and_invoke_open_and_invoke_range1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_open and $open and $range1
    ((!({
        full_obs.observe_ebih__truck_gate__ctx__door_open();
        ctx.ebih__truck_gate__ctx__door_open()
    }) && (hobserve__open!(ctx, world, full_obs)))
        && (hobserve__range1!(ctx, world, full_obs)))
}
pub fn observe_access_not_ebih_interchange_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Ebih_Interchange_Block
    {
        full_obs.observe_ebih_interchange_block();
        !ctx.has(Item::Ebih_Interchange_Block)
    }
}
pub fn observe_access_not_giguna__carnelian__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar
    !({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    })
}
pub fn observe_access_not_giguna__carnelian__ctx__lower_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!({
        full_obs.observe_giguna__carnelian__ctx__lower_susar();
        ctx.giguna__carnelian__ctx__lower_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__carnelian__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar
    !({
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    })
}
pub fn observe_access_not_giguna__carnelian__ctx__upper_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!({
        full_obs.observe_giguna__carnelian__ctx__upper_susar();
        ctx.giguna__carnelian__ctx__upper_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__clouds__ctx__platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform and $activate
    (!({
        full_obs.observe_giguna__clouds__ctx__platform();
        ctx.giguna__clouds__ctx__platform()
    }) && (hobserve__activate!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__clouds__ctx__platform_and_invoke_activate_and_invoke_attract_and_breach_sight_and_remote_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform and $activate and $attract and Breach_Sight and Remote_Drone
    ((((!({
        full_obs.observe_giguna__clouds__ctx__platform();
        ctx.giguna__clouds__ctx__platform()
    }) && (hobserve__activate!(ctx, world, full_obs)))
        && (hobserve__attract!(ctx, world, full_obs)))
        && ({
            full_obs.observe_breach_sight();
            ctx.has(Item::Breach_Sight)
        }))
        && ({
            full_obs.observe_remote_drone();
            ctx.has(Item::Remote_Drone)
        }))
}
pub fn observe_access_not_giguna__clouds__ctx__platform_and_invoke_activate_and_invoke_can_deploy_and_invoke_attract_and_breach_sight(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform and $activate and $can_deploy and $attract and Breach_Sight
    ((((!({
        full_obs.observe_giguna__clouds__ctx__platform();
        ctx.giguna__clouds__ctx__platform()
    }) && (hobserve__activate!(ctx, world, full_obs)))
        && (hobserve__can_deploy!(ctx, world, full_obs)))
        && (hobserve__attract!(ctx, world, full_obs)))
        && ({
            full_obs.observe_breach_sight();
            ctx.has(Item::Breach_Sight)
        }))
}
pub fn observe_access_not_giguna__east_caverns__ctx__combo_entered(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_combo_entered
    !({
        full_obs.observe_giguna__east_caverns__ctx__combo_entered();
        ctx.giguna__east_caverns__ctx__combo_entered()
    })
}
pub fn observe_access_not_giguna__east_caverns__ctx__door_opened_and_invoke_open_and_invoke_range2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened and $open and $range2
    ((!({
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }) && (hobserve__open!(ctx, world, full_obs)))
        && (hobserve__range2!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__east_caverns__ctx__door_opened_and_invoke_unlock2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened and $unlock2
    (!({
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }) && (hobserve__unlock2!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__east_caverns__ctx__door_opened_and_invoke_unlock2_and_invoke_range1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened and $unlock2 and $range1
    ((!({
        full_obs.observe_giguna__east_caverns__ctx__door_opened();
        ctx.giguna__east_caverns__ctx__door_opened()
    }) && (hobserve__unlock2!(ctx, world, full_obs)))
        && (hobserve__range1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__east_caverns__ctx__lower_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    })
}
pub fn observe_access_not_giguna__east_caverns__ctx__lower_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_lower_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__lower_susar();
        ctx.giguna__east_caverns__ctx__lower_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__east_caverns__ctx__mid_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_mid_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__mid_susar();
        ctx.giguna__east_caverns__ctx__mid_susar()
    })
}
pub fn observe_access_not_giguna__east_caverns__ctx__mid_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_mid_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__mid_susar();
        ctx.giguna__east_caverns__ctx__mid_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__east_caverns__ctx__upper_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar
    !({
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    })
}
pub fn observe_access_not_giguna__east_caverns__ctx__upper_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_upper_susar and $allegiance1
    (!({
        full_obs.observe_giguna__east_caverns__ctx__upper_susar();
        ctx.giguna__east_caverns__ctx__upper_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__ruins_west__ctx__kishib_handled_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_kishib_handled and $allegiance1
    (!({
        full_obs.observe_giguna__ruins_west__ctx__kishib_handled();
        ctx.giguna__ruins_west__ctx__kishib_handled()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__ruins_west__ctx__kishib_handled_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_kishib_handled and $shockwave
    (!({
        full_obs.observe_giguna__ruins_west__ctx__kishib_handled();
        ctx.giguna__ruins_west__ctx__kishib_handled()
    }) && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna__west_caverns__ctx__east_susar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_east_susar
    !({
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    })
}
pub fn observe_access_not_giguna__west_caverns__ctx__east_susar_and_invoke_allegiance1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_east_susar and $allegiance1
    (!({
        full_obs.observe_giguna__west_caverns__ctx__east_susar();
        ctx.giguna__west_caverns__ctx__east_susar()
    }) && (hobserve__allegiance1!(ctx, world, full_obs)))
}
pub fn observe_access_not_giguna_breach__sw_save__ctx__door_opened(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door_opened
    !({
        full_obs.observe_giguna_breach__sw_save__ctx__door_opened();
        ctx.giguna_breach__sw_save__ctx__door_opened()
    })
}
pub fn observe_access_not_glacier__lonely_bull__ctx__door_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_door and Nanite_Mist
    (!({
        full_obs.observe_glacier__lonely_bull__ctx__door();
        ctx.glacier__lonely_bull__ctx__door()
    }) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_not_hammond_auth(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Hammond_Auth
    {
        full_obs.observe_hammond_auth();
        !ctx.has(Item::Hammond_Auth)
    }
}
pub fn observe_access_not_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not $hook
    hobserve__hook!(ctx, world, full_obs)
}
pub fn observe_access_not_irikar__basement_portal__ctx__platform_moved(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_platform_moved
    !({
        full_obs.observe_irikar__basement_portal__ctx__platform_moved();
        ctx.irikar__basement_portal__ctx__platform_moved()
    })
}
pub fn observe_access_not_irikar__midwest__ctx__left_platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_left_platform and $activate
    (!({
        full_obs.observe_irikar__midwest__ctx__left_platform();
        ctx.irikar__midwest__ctx__left_platform()
    }) && (hobserve__activate!(ctx, world, full_obs)))
}
pub fn observe_access_not_irikar__midwest__ctx__left_platform_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_left_platform and Nanite_Mist
    (!({
        full_obs.observe_irikar__midwest__ctx__left_platform();
        ctx.irikar__midwest__ctx__left_platform()
    }) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_not_irikar__midwest__ctx__right_platform_and_invoke_activate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_right_platform and $activate
    (!({
        full_obs.observe_irikar__midwest__ctx__right_platform();
        ctx.irikar__midwest__ctx__right_platform()
    }) && (hobserve__activate!(ctx, world, full_obs)))
}
pub fn observe_access_not_irikar__midwest__ctx__right_platform_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not ^_right_platform and Nanite_Mist
    (!({
        full_obs.observe_irikar__midwest__ctx__right_platform();
        ctx.irikar__midwest__ctx__right_platform()
    }) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_not_irikar_royal_storage_wall_and_invoke_shockwave(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Irikar_Royal_Storage_Wall and $shockwave
    ({
        full_obs.observe_irikar_royal_storage_wall();
        !ctx.has(Item::Irikar_Royal_Storage_Wall)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
}
pub fn observe_access_not_irikar_royal_storage_wall_and_invoke_shockwave_and_not_invoke_visited__irikar_gt_hub_gt_collapsed_column_gt_shockwave_to_get_item(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Irikar_Royal_Storage_Wall and $shockwave and not $visited(`Irikar > Hub > Collapsed Column > Shockwave to Get Item`)
    (({
        full_obs.observe_irikar_royal_storage_wall();
        !ctx.has(Item::Irikar_Royal_Storage_Wall)
    } && (hobserve__shockwave!(ctx, world, full_obs)))
        && (ctx.visited(LocationId::Irikar__Hub__Collapsed_Column__Shockwave_to_Get_Item)))
}
pub fn observe_access_not_irikar_royal_storage_wall_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Irikar_Royal_Storage_Wall and Nanite_Mist
    ({
        full_obs.observe_irikar_royal_storage_wall();
        !ctx.has(Item::Irikar_Royal_Storage_Wall)
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_not_mist_upgrade(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Mist_Upgrade
    {
        full_obs.observe_mist_upgrade();
        !ctx.has(Item::Mist_Upgrade)
    }
}
pub fn observe_access_not_separation_or_defeat_indra(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT Separation or Defeat_Indra
    ({
        full_obs.observe_separation();
        !ctx.has(Item::Separation)
    } || {
        full_obs.observe_defeat_indra();
        ctx.has(Item::Defeat_Indra)
    })
}
pub fn observe_access_not_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Slingshot_Hook
    {
        full_obs.observe_slingshot_hook();
        !ctx.has(Item::Slingshot_Hook)
    }
}
pub fn observe_access_not_slingshot_weapon(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // not Slingshot_Weapon
    {
        full_obs.observe_slingshot_weapon();
        !ctx.has(Item::Slingshot_Weapon)
    }
}
pub fn observe_access_not_within_menu_and_anuman_and_mode_ne_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and Anuman and ^mode != 'drone'
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })) && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v != enums::Mode::Drone
    }))
}
pub fn observe_access_not_within_menu_and_flasks_gt_0(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and ^flasks > 0
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        let n: i32 = 0.into();
        full_obs.observe_flasks(IntegerObservation::Le(n as i8));
        i32::from(ctx.flasks()) > n
    }))
}
pub fn observe_access_not_within_menu_and_invoke_attract_and_portal_ne_invoke_default_and_portal_ne_position(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and $attract and ^portal != $default and ^portal != ^position
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && (hobserve__attract!(ctx, world, full_obs)))
        && ({
            let left = {
                full_obs.observe_portal();
                ctx.portal()
            };
            let right = Default::default();
            left != right
        }))
        && ({
            let left = {
                full_obs.observe_portal();
                ctx.portal()
            };
            let right = {
                full_obs.observe_position();
                ctx.position()
            };
            left != right
        }))
}
pub fn observe_access_not_within_menu_and_invoke_can_deploy(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and $can_deploy
    ((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && (hobserve__can_deploy!(ctx, world, full_obs)))
}
pub fn observe_access_not_within_menu_and_realm_ne_breach_and_anuman_and_mode_eq_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and Anuman and ^mode == 'drone'
    ((((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        let v = data::realm(ctx.position());
        v != enums::Realm::Breach
    })) && ({
        full_obs.observe_anuman();
        ctx.has(Item::Anuman)
    })) && ({
        let v = {
            full_obs.observe_mode();
            ctx.mode()
        };
        v == enums::Mode::Drone
    }))
}
pub fn observe_access_not_within_menu_and_realm_ne_breach_and_invoke_can_recall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // NOT WITHIN `Menu` and ^realm != 'breach' and $can_recall
    (((match get_region(ctx.position()) {
        RegionId::Menu => false,
        _ => true,
    }) && ({
        let v = data::realm(ctx.position());
        v != enums::Realm::Breach
    })) && (hobserve__can_recall!(ctx, world, full_obs)))
}
pub fn observe_access_portal_eq_position(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^portal == ^position
    {
        let left = {
            full_obs.observe_portal();
            ctx.portal()
        };
        let right = {
            full_obs.observe_position();
            ctx.position()
        };
        left == right
    }
}
pub fn observe_access_portal_hidden(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^portal_hidden
    data::portal_hidden(ctx.position())
}
pub fn observe_access_ranged_damage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Damage
    {
        full_obs.observe_ranged_damage();
        ctx.has(Item::Ranged_Damage)
    }
}
pub fn observe_access_ranged_damage_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Damage_2
    {
        full_obs.observe_ranged_damage_2();
        ctx.has(Item::Ranged_Damage_2)
    }
}
pub fn observe_access_ranged_speed(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Speed
    {
        full_obs.observe_ranged_speed();
        ctx.has(Item::Ranged_Speed)
    }
}
pub fn observe_access_ranged_speed_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Ranged_Speed_2
    {
        full_obs.observe_ranged_speed_2();
        ctx.has(Item::Ranged_Speed_2)
    }
}
pub fn observe_access_realm_eq_breach_and_exit_breach_and_flipside_ne_invoke_default(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // ^realm == 'breach' and Exit_Breach and ^flipside != $default
    (({
        let v = data::realm(ctx.position());
        v == enums::Realm::Breach
    } && ({
        full_obs.observe_exit_breach();
        ctx.has(Item::Exit_Breach)
    })) && ({
        let left = data::flipside(ctx.position());
        let right = Default::default();
        left != right
    }))
}
pub fn observe_access_remote_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Remote_Drone
    {
        full_obs.observe_remote_drone();
        ctx.has(Item::Remote_Drone)
    }
}
pub fn observe_access_robopede(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Robopede
    {
        full_obs.observe_robopede();
        ctx.has(Item::Robopede)
    }
}
pub fn observe_access_separation(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Separation
    {
        full_obs.observe_separation();
        ctx.has(Item::Separation)
    }
}
pub fn observe_access_separation_and_not_defeat_indra_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Separation and NOT Defeat_Indra and Nanite_Mist
    (({
        full_obs.observe_separation();
        ctx.has(Item::Separation)
    } && ({
        full_obs.observe_defeat_indra();
        !ctx.has(Item::Defeat_Indra)
    })) && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_siuna_storage_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Siuna_Storage_Wall
    {
        full_obs.observe_siuna_storage_wall();
        ctx.has(Item::Siuna_Storage_Wall)
    }
}
pub fn observe_access_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook
    {
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }
}
pub fn observe_access_slingshot_hook_and___not_slingshot_weapon_or_invoke_visited__irikar_breach_gt_gauntlet_gt_hidden_path_reward_gt_item(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and (not Slingshot_Weapon or $visited(`Irikar Breach > Gauntlet > Hidden Path Reward > Item`))
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_weapon();
        !ctx.has(Item::Slingshot_Weapon)
    } || ctx.visited(LocationId::Irikar_Breach__Gauntlet__Hidden_Path_Reward__Item)))
}
pub fn observe_access_slingshot_hook_and___slingshot_weapon_or_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and (Slingshot_Weapon or Drone_Hover)
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_weapon();
        ctx.has(Item::Slingshot_Weapon)
    } || {
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover_and_ebih_breach_in_n_out_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Ebih_Breach_In_n_Out_Gate
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_ebih_breach_in_n_out_gate();
        ctx.has(Item::Ebih_Breach_In_n_Out_Gate)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover_and_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Ebih_Breach_Rock_Block_Rock
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_ebih_breach_rock_block_rock();
        ctx.has(Item::Ebih_Breach_Rock_Block_Rock)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Giguna_Breach_Crab_Rave_Gate
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_giguna_breach_crab_rave_gate();
        ctx.has(Item::Giguna_Breach_Crab_Rave_Gate)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover_and_infect_l1_and_drone_melee_damage_2_and_drone_melee_speed_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Infect_L1 and Drone_Melee_Damage_2 and Drone_Melee_Speed_2
    (((({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_infect_l1();
        ctx.has(Item::Infect_L1)
    })) && ({
        full_obs.observe_drone_melee_damage_2();
        ctx.has(Item::Drone_Melee_Damage_2)
    })) && ({
        full_obs.observe_drone_melee_speed_2();
        ctx.has(Item::Drone_Melee_Speed_2)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover_and_not_irikar_breach_buried_treasure_pillar(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover and not Irikar_Breach_Buried_Treasure_Pillar
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_irikar_breach_buried_treasure_pillar();
        !ctx.has(Item::Irikar_Breach_Buried_Treasure_Pillar)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_hover_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Hover and Slingshot_Weapon
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_slingshot_weapon();
        ctx.has(Item::Slingshot_Weapon)
    }))
}
pub fn observe_access_slingshot_hook_and_drone_melee_damage_3(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Drone_Melee_Damage_3
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_drone_melee_damage_3();
        ctx.has(Item::Drone_Melee_Damage_3)
    }))
}
pub fn observe_access_slingshot_hook_and_ebih_breach_lake_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Ebih_Breach_Lake_Gate
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_ebih_breach_lake_gate();
        ctx.has(Item::Ebih_Breach_Lake_Gate)
    }))
}
pub fn observe_access_slingshot_hook_and_ebih_breach_rock_block_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Ebih_Breach_Rock_Block_Rock
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_ebih_breach_rock_block_rock();
        ctx.has(Item::Ebih_Breach_Rock_Block_Rock)
    }))
}
pub fn observe_access_slingshot_hook_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Giguna_Breach_Crab_Rave_Gate
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_giguna_breach_crab_rave_gate();
        ctx.has(Item::Giguna_Breach_Crab_Rave_Gate)
    }))
}
pub fn observe_access_slingshot_hook_and_giguna_breach_gate_and_wall_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Giguna_Breach_Gate_and_Wall_Gate
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_giguna_breach_gate_and_wall_gate();
        ctx.has(Item::Giguna_Breach_Gate_and_Wall_Gate)
    }))
}
pub fn observe_access_slingshot_hook_and_slingshot_charge(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Slingshot_Charge
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_charge();
        ctx.has(Item::Slingshot_Charge)
    }))
}
pub fn observe_access_slingshot_hook_and_slingshot_charge_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Slingshot_Charge and Drone_Hover
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_charge();
        ctx.has(Item::Slingshot_Charge)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_slingshot_hook_and_slingshot_weapon(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Slingshot_Weapon
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_weapon();
        ctx.has(Item::Slingshot_Weapon)
    }))
}
pub fn observe_access_slingshot_hook_and_slingshot_weapon_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Slingshot_Weapon and Drone_Hover
    (({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_weapon();
        ctx.has(Item::Slingshot_Weapon)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_slingshot_hook_and_slingshot_weapon_and_drone_hover_and_giguna_breach_crab_rave_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook and Slingshot_Weapon and Drone_Hover and Giguna_Breach_Crab_Rave_Gate
    ((({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } && ({
        full_obs.observe_slingshot_weapon();
        ctx.has(Item::Slingshot_Weapon)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_giguna_breach_crab_rave_gate();
        ctx.has(Item::Giguna_Breach_Crab_Rave_Gate)
    }))
}
pub fn observe_access_slingshot_hook_or_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Slingshot_Hook or Drone_Hover
    ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } || {
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })
}
pub fn observe_access_sniper_valley_rock_1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Sniper_Valley_Rock_1
    {
        full_obs.observe_sniper_valley_rock_1();
        ctx.has(Item::Sniper_Valley_Rock_1)
    }
}
pub fn observe_access_station_power(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Station_Power
    {
        full_obs.observe_station_power();
        ctx.has(Item::Station_Power)
    }
}
pub fn observe_access_switch_36_11(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Switch_36_11
    {
        full_obs.observe_switch_36_11();
        ctx.has(Item::Switch_36_11)
    }
}
pub fn observe_access_switch_40_12(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Switch_40_12
    {
        full_obs.observe_switch_40_12();
        ctx.has(Item::Switch_40_12)
    }
}
pub fn observe_access_uhrum_annuna_corridor_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Annuna_Corridor_Block
    {
        full_obs.observe_uhrum_annuna_corridor_block();
        ctx.has(Item::Uhrum_Annuna_Corridor_Block)
    }
}
pub fn observe_access_uhrum_breach_annuna_gate_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Annuna_Gate_Gate
    {
        full_obs.observe_uhrum_breach_annuna_gate_gate();
        ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate)
    }
}
pub fn observe_access_uhrum_breach_annuna_gate_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Annuna_Gate_Gate and Slingshot_Hook
    ({
        full_obs.observe_uhrum_breach_annuna_gate_gate();
        ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_uhrum_breach_annuna_gate_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Annuna_Gate_Gate and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_uhrum_breach_annuna_gate_gate();
        ctx.has(Item::Uhrum_Breach_Annuna_Gate_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_uhrum_breach_locked_down_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Locked_Down_Gate
    {
        full_obs.observe_uhrum_breach_locked_down_gate();
        ctx.has(Item::Uhrum_Breach_Locked_Down_Gate)
    }
}
pub fn observe_access_uhrum_breach_locked_down_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Locked_Down_Gate and Slingshot_Hook
    ({
        full_obs.observe_uhrum_breach_locked_down_gate();
        ctx.has(Item::Uhrum_Breach_Locked_Down_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_uhrum_breach_overgrown_ruins_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Overgrown_Ruins_Wall
    {
        full_obs.observe_uhrum_breach_overgrown_ruins_wall();
        ctx.has(Item::Uhrum_Breach_Overgrown_Ruins_Wall)
    }
}
pub fn observe_access_uhrum_breach_rock_and_gate_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Gate
    {
        full_obs.observe_uhrum_breach_rock_and_gate_gate();
        ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Gate)
    }
}
pub fn observe_access_uhrum_breach_rock_and_gate_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Gate and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_uhrum_breach_rock_and_gate_gate();
        ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Gate)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_uhrum_breach_rock_and_gate_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Rock
    {
        full_obs.observe_uhrum_breach_rock_and_gate_rock();
        ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Rock)
    }
}
pub fn observe_access_uhrum_breach_rock_and_gate_rock_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Breach_Rock_and_Gate_Rock and Slingshot_Hook
    ({
        full_obs.observe_uhrum_breach_rock_and_gate_rock();
        ctx.has(Item::Uhrum_Breach_Rock_and_Gate_Rock)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_uhrum_cavern_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Cavern_Wall
    {
        full_obs.observe_uhrum_cavern_wall();
        ctx.has(Item::Uhrum_Cavern_Wall)
    }
}
pub fn observe_access_uhrum_cavern_wall_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Cavern_Wall and $hookhover
    ({
        full_obs.observe_uhrum_cavern_wall();
        ctx.has(Item::Uhrum_Cavern_Wall)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_east_glitch(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_East_Glitch
    {
        full_obs.observe_uhrum_east_glitch();
        ctx.has(Item::Uhrum_East_Glitch)
    }
}
pub fn observe_access_uhrum_east_lake_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_East_Lake_Block
    {
        full_obs.observe_uhrum_east_lake_block();
        ctx.has(Item::Uhrum_East_Lake_Block)
    }
}
pub fn observe_access_uhrum_east_lake_block_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_East_Lake_Block and $hookhover
    ({
        full_obs.observe_uhrum_east_lake_block();
        ctx.has(Item::Uhrum_East_Lake_Block)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_emergence_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Emergence_Wall
    {
        full_obs.observe_uhrum_emergence_wall();
        ctx.has(Item::Uhrum_Emergence_Wall)
    }
}
pub fn observe_access_uhrum_emergence_wall_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Emergence_Wall and $hook and $hover
    (({
        full_obs.observe_uhrum_emergence_wall();
        ctx.has(Item::Uhrum_Emergence_Wall)
    } && (hobserve__hook!(ctx, world, full_obs)))
        && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_emergence_wall_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Emergence_Wall and $hover
    ({
        full_obs.observe_uhrum_emergence_wall();
        ctx.has(Item::Uhrum_Emergence_Wall)
    } && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_glitchy_corridor_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Glitchy_Corridor_Rock
    {
        full_obs.observe_uhrum_glitchy_corridor_rock();
        ctx.has(Item::Uhrum_Glitchy_Corridor_Rock)
    }
}
pub fn observe_access_uhrum_glitchy_corridor_rock_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Glitchy_Corridor_Rock and $hook
    ({
        full_obs.observe_uhrum_glitchy_corridor_rock();
        ctx.has(Item::Uhrum_Glitchy_Corridor_Rock)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_glitchy_corridor_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Glitchy_Corridor_Rock and $hookhover
    ({
        full_obs.observe_uhrum_glitchy_corridor_rock();
        ctx.has(Item::Uhrum_Glitchy_Corridor_Rock)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_rocky_gate_rock(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Rocky_Gate_Rock
    {
        full_obs.observe_uhrum_rocky_gate_rock();
        ctx.has(Item::Uhrum_Rocky_Gate_Rock)
    }
}
pub fn observe_access_uhrum_rocky_gate_rock_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Rocky_Gate_Rock and $hookhover
    ({
        full_obs.observe_uhrum_rocky_gate_rock();
        ctx.has(Item::Uhrum_Rocky_Gate_Rock)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_waterfall_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfall_Wall
    {
        full_obs.observe_uhrum_waterfall_wall();
        ctx.has(Item::Uhrum_Waterfall_Wall)
    }
}
pub fn observe_access_uhrum_waterfalls_block(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfalls_Block
    {
        full_obs.observe_uhrum_waterfalls_block();
        ctx.has(Item::Uhrum_Waterfalls_Block)
    }
}
pub fn observe_access_uhrum_waterfalls_block_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfalls_Block and $grab
    ({
        full_obs.observe_uhrum_waterfalls_block();
        ctx.has(Item::Uhrum_Waterfalls_Block)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_waterfalls_block_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_Waterfalls_Block and $hook
    ({
        full_obs.observe_uhrum_waterfalls_block();
        ctx.has(Item::Uhrum_Waterfalls_Block)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_west_entrance_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Gate
    {
        full_obs.observe_uhrum_west_entrance_gate();
        ctx.has(Item::Uhrum_West_Entrance_Gate)
    }
}
pub fn observe_access_uhrum_west_entrance_gate_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Gate and $hook
    ({
        full_obs.observe_uhrum_west_entrance_gate();
        ctx.has(Item::Uhrum_West_Entrance_Gate)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_west_entrance_gate_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Gate and $hover
    ({
        full_obs.observe_uhrum_west_entrance_gate();
        ctx.has(Item::Uhrum_West_Entrance_Gate)
    } && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_uhrum_west_entrance_lower_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Lower_Wall
    {
        full_obs.observe_uhrum_west_entrance_lower_wall();
        ctx.has(Item::Uhrum_West_Entrance_Lower_Wall)
    }
}
pub fn observe_access_uhrum_west_entrance_upper_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Entrance_Upper_Wall
    {
        full_obs.observe_uhrum_west_entrance_upper_wall();
        ctx.has(Item::Uhrum_West_Entrance_Upper_Wall)
    }
}
pub fn observe_access_uhrum_west_glitch(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Uhrum_West_Glitch
    {
        full_obs.observe_uhrum_west_glitch();
        ctx.has(Item::Uhrum_West_Glitch)
    }
}
pub fn observe_access_underwater_movement(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement
    {
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    }
}
pub fn observe_access_underwater_movement_and___invoke_grab_or_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and ($grab or $climb)
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__grab!(ctx, world, full_obs) || hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and___invoke_hook_or_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and ($hook or $hover)
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hook!(ctx, world, full_obs) || hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and___slingshot_hook_or_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and (Slingshot_Hook or Drone_Hover)
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    } || {
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_underwater_movement_and_amagi_breach_center_ruins_blocks(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Center_Ruins_Blocks
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_amagi_breach_center_ruins_blocks();
        ctx.has(Item::Amagi_Breach_Center_Ruins_Blocks)
    }))
}
pub fn observe_access_underwater_movement_and_amagi_breach_lower_hallway_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_amagi_breach_lower_hallway_gate();
        ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate)
    }))
}
pub fn observe_access_underwater_movement_and_amagi_breach_lower_hallway_gate_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate and Slingshot_Hook
    (({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_amagi_breach_lower_hallway_gate();
        ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate)
    })) && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_underwater_movement_and_amagi_breach_lower_hallway_gate_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Lower_Hallway_Gate and Slingshot_Hook and Drone_Hover
    ((({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_amagi_breach_lower_hallway_gate();
        ctx.has(Item::Amagi_Breach_Lower_Hallway_Gate)
    })) && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_underwater_movement_and_amagi_breach_split_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Amagi_Breach_Split_Gate
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_amagi_breach_split_gate();
        ctx.has(Item::Amagi_Breach_Split_Gate)
    }))
}
pub fn observe_access_underwater_movement_and_amagi_wiggly_room_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Amagi_Wiggly_Room_Gate
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_amagi_wiggly_room_gate();
        ctx.has(Item::Amagi_Wiggly_Room_Gate)
    }))
}
pub fn observe_access_underwater_movement_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Drone_Hover
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_underwater_movement_and_drone_hover_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Drone_Hover and Slingshot_Hook
    (({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    })) && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_underwater_movement_and_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and ^_lower_gatestones
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_glacier__vertical_room__ctx__lower_gatestones();
        ctx.glacier__vertical_room__ctx__lower_gatestones()
    }))
}
pub fn observe_access_underwater_movement_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $climb
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_invoke_grab(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $grab
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__grab!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_invoke_grab_and_invoke_climb(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $grab and $climb
    (({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__grab!(ctx, world, full_obs)))
        && (hobserve__climb!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_invoke_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $hook
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hook!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_invoke_hook_and_glacier__vertical_room__ctx__lower_gatestones(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $hook and ^_lower_gatestones
    (({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hook!(ctx, world, full_obs)))
        && ({
            full_obs.observe_glacier__vertical_room__ctx__lower_gatestones();
            ctx.glacier__vertical_room__ctx__lower_gatestones()
        }))
}
pub fn observe_access_underwater_movement_and_invoke_hook_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $hook and $hover
    (({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hook!(ctx, world, full_obs)))
        && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_invoke_hookhover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $hookhover
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hookhover!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_invoke_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and $hover
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && (hobserve__hover!(ctx, world, full_obs)))
}
pub fn observe_access_underwater_movement_and_nanite_mist(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Nanite_Mist
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_nanite_mist();
        ctx.has(Item::Nanite_Mist)
    }))
}
pub fn observe_access_underwater_movement_and_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Slingshot_Hook
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    }))
}
pub fn observe_access_underwater_movement_and_slingshot_hook_and_drone_hover(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement and Slingshot_Hook and Drone_Hover
    (({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } && ({
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })) && ({
        full_obs.observe_drone_hover();
        ctx.has(Item::Drone_Hover)
    }))
}
pub fn observe_access_underwater_movement_or_slingshot_hook(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // Underwater_Movement or Slingshot_Hook
    ({
        full_obs.observe_underwater_movement();
        ctx.has(Item::Underwater_Movement)
    } || {
        full_obs.observe_slingshot_hook();
        ctx.has(Item::Slingshot_Hook)
    })
}
pub fn observe_access_within_menu_gt_upgrade_menu(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) -> bool {
    // WITHIN `Menu > Upgrade Menu`
    (match get_area(ctx.position()) {
        AreaId::Menu__Upgrade_Menu => true,
        _ => false,
    })
}
pub fn observe_action_amagi__gated_community__ctx__dur_esla_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_dur_esla = true
}
pub fn observe_action_amagi__main_area__ctx__combo_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_combo = true
}
pub fn observe_action_amagi__secret_chamber__ctx__east_dur_esla_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_east_dur_esla = true
}
pub fn observe_action_amagi__secret_chamber__ctx__west_dur_esla_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_west_dur_esla = true
}
pub fn observe_action_annuna__boss_gate__ctx__door_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door = true
}
pub fn observe_action_annuna__east_bridge__ctx__combo_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_combo = true
}
pub fn observe_action_annuna__invisible_enemies__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_annuna__invisible_enemies__ctx__nw_utu_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_nw_utu = true
}
pub fn observe_action_annuna__udug_gate__ctx__door_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door = true
}
pub fn observe_action_annuna__vertical_room__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_annuna__west_bridge__ctx__doors_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_doors_opened = true
}
pub fn observe_action_annuna__west_climb__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_ebih__base_camp__ctx__left_platform_moved_set_false(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_left_platform_moved = false
}
pub fn observe_action_ebih__base_camp__ctx__left_platform_moved_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_left_platform_moved = true
}
pub fn observe_action_ebih__drone_room__ctx__platform_moved_set_false(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = false
}
pub fn observe_action_ebih__drone_room__ctx__platform_moved_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = true
}
pub fn observe_action_ebih__ebih_east__ctx__platform1_moved_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform1_moved = true
}
pub fn observe_action_ebih__ebih_east__ctx__platform2_moved_set_false(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform2_moved = false
}
pub fn observe_action_ebih__ebih_east__ctx__platform2_moved_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform2_moved = true
}
pub fn observe_action_ebih__ebih_west__ctx__door_open_set_true_if___indra_within_ebih_gt_ebih_west_gt_above_door____indra_set_ebih_gt_ebih_west_gt_below_door_(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true; IF (^indra WITHIN `Ebih > Ebih West > Above Door`) { ^indra = `Ebih > Ebih West > Below Door`; }
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    if {
        full_obs.observe_indra();
        ctx.indra()
    } == SpotId::Ebih__Ebih_West__Above_Door
    {};
    full_obs.strict = old_strict;
}
pub fn observe_action_ebih__grid_25_10_12__ctx__door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_ebih__truck_gate__ctx__door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_ebih__vertical_interchange__ctx__door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_ebih__waterfall__ctx__east_door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_east_door_open = true
}
pub fn observe_action_ebih__waterfall__ctx__west_door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_west_door_open = true
}
pub fn observe_action_emergence__storage__ctx__door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_flasks_incr_1(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // ^flasks += 1
}
pub fn observe_action_flasks_incr_2(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // ^flasks += 2
}
pub fn observe_action_flasks_incr_4(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // ^flasks += 4
}
pub fn observe_action_giguna__carnelian__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__carnelian__ctx__lower_susar_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_susar = true
}
pub fn observe_action_giguna__carnelian__ctx__upper_susar_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__clouds__ctx__platform_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform = true
}
pub fn observe_action_giguna__clouds__ctx__platform_set_true_if___indra_within_position____indra_set_giguna_gt_clouds_gt_platform_stop__portal_set_giguna_gt_clouds_gt_platform_stop(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform = true; if (^indra WITHIN ^position) { ^indra = `Giguna > Clouds > Platform Stop`; }; ^portal = `Giguna > Clouds > Platform Stop`;
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    if {
        full_obs.observe_indra();
        ctx.indra()
    } == {
        full_obs.observe_position();
        ctx.position()
    } {};
    full_obs.strict = old_strict;
}
pub fn observe_action_giguna__clouds__ctx__platform_set_true_portal_set_giguna_gt_clouds_gt_platform_stop_invoke_deploy_drone_and_move__giguna_gt_clouds_gt_platform_stop(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform = true; ^portal = `Giguna > Clouds > Platform Stop`; $deploy_drone_and_move(`Giguna > Clouds > Platform Stop`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Clouds__Platform_Stop, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_giguna__east_caverns__ctx__combo_entered_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_combo_entered = true
}
pub fn observe_action_giguna__east_caverns__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__east_caverns__ctx__lower_susar_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_susar = true
}
pub fn observe_action_giguna__east_caverns__ctx__mid_susar_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_mid_susar = true
}
pub fn observe_action_giguna__east_caverns__ctx__upper_susar_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_susar = true
}
pub fn observe_action_giguna__gateway__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__giguna_base__ctx__door_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_open = true
}
pub fn observe_action_giguna__giguna_northeast__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_giguna__labyrinth__ctx__door_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door = true
}
pub fn observe_action_giguna__ruins_top__ctx__doors_open_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_doors_open = true
}
pub fn observe_action_giguna__ruins_west__ctx__kishib_handled_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_kishib_handled = true
}
pub fn observe_action_giguna__west_caverns__ctx__east_susar_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_east_susar = true
}
pub fn observe_action_giguna_breach__sw_save__ctx__door_opened_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door_opened = true
}
pub fn observe_action_glacier__ctx__hammonds_doors_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_hammonds_doors = true
}
pub fn observe_action_glacier__lonely_bull__ctx__door_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_door = true
}
pub fn observe_action_glacier__vertical_room__ctx__lower_gatestones_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_lower_gatestones = true
}
pub fn observe_action_glacier__vertical_room__ctx__upper_gatestone_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_upper_gatestone = true
}
pub fn observe_action_if___indra_within_position____indra_set_giguna_gt_clouds_gt_platform_early_portal__portal_set_giguna_gt_clouds_gt_platform_early_portal(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // if (^indra WITHIN ^position) { ^indra = `Giguna > Clouds > Platform Early Portal`; }; ^portal = `Giguna > Clouds > Platform Early Portal`;
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    if {
        full_obs.observe_indra();
        ctx.indra()
    } == {
        full_obs.observe_position();
        ctx.position()
    } {};
    full_obs.strict = old_strict;
}
pub fn observe_action_indra_set_invoke_default(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^indra = $default
}
pub fn observe_action_invoke_collect__irikar_royal_storage_wall_invoke_collect__flask_invoke_visit__irikar_gt_hub_gt_royal_storage_in_wall_gt_item_invoke_visit__irikar_gt_hub_gt_royal_storage_by_wall_gt_shockwave_just_the_wall(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $collect(Irikar_Royal_Storage_Wall); $collect(Flask); $visit(`Irikar > Hub > Royal Storage in Wall > Item`); $visit(`Irikar > Hub > Royal Storage By Wall > Shockwave Just The Wall`);
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    rules::observe_action_flasks_incr_1(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__annuna_gt_east_bridge_gt_center_corridor(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Center Corridor`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Annuna__East_Bridge__Center_Corridor,
        full_obs
    );
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__annuna_gt_east_bridge_gt_tower_base_east(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Annuna > East Bridge > Tower Base East`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Annuna__East_Bridge__Tower_Base_East,
        full_obs
    );
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__ebih_gt_base_camp_gt_save_point(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Ebih > Base Camp > Save Point`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Base_Camp__Save_Point, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__ebih_gt_drone_room_gt_tree(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Ebih > Drone Room > Tree`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Ebih__Drone_Room__Tree, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__ebih_gt_ebih_west_gt_alcove_entrance(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Ebih > Ebih West > Alcove Entrance`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Ebih__Ebih_West__Alcove_Entrance,
        full_obs
    );
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__giguna_gt_giguna_base_gt_kari(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Giguna > Giguna Base > Kari`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Giguna_Base__Kari, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__giguna_gt_ruins_top_gt_west_7(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Giguna > Ruins Top > West 7`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Ruins_Top__West_7, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_deploy_drone_and_move__giguna_gt_wasteland_gt_middle_path(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $deploy_drone_and_move(`Giguna > Wasteland > Middle Path`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(ctx, world, SpotId::Giguna__Wasteland__Middle_Path, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_post_portal_save_update(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $post_portal_save_update
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__post_portal_save_update!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_refill_energy(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $refill_energy
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__refill_energy!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_reload(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // $reload
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__reload!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_reset_old_area__newpos(
    ctx: &Context,
    world: &World,
    newpos: SpotId,
    full_obs: &mut FullObservation,
) {
    // $reset_old_area(^newpos)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__reset_old_area!(ctx, world, newpos, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_save(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // $save
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__save!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_save_last(
    ctx: &Context,
    world: &World,
    newpos: SpotId,
    full_obs: &mut FullObservation,
) {
    // $save_last
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__save_last!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_save_last_invoke_refill_energy(
    ctx: &Context,
    world: &World,
    newpos: SpotId,
    full_obs: &mut FullObservation,
) {
    // $save_last; $refill_energy
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__save_last!(ctx, world, full_obs);
    hobserve__refill_energy!(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_invoke_visit__amagi_gt_west_lake_gt_cavern_refill_station_gt_break_wall_invoke_add_item__amagi_dragon_eye_passage(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $visit(`Amagi > West Lake > Cavern Refill Station > Break Wall`); $add_item(Amagi_Dragon_Eye_Passage);
}
pub fn observe_action_invoke_visit__amagi_gt_west_lake_gt_stronghold_ceiling_left_gt_knock_down_left_boulder_invoke_add_item__amagi_stronghold_wall_1_invoke_add_item__amagi_stronghold_boulder_1(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $visit(`Amagi > West Lake > Stronghold Ceiling Left > Knock Down Left Boulder`); $add_item(Amagi_Stronghold_Wall_1); $add_item(Amagi_Stronghold_Boulder_1);
}
pub fn observe_action_invoke_visit__amagi_gt_west_lake_gt_stronghold_ceiling_right_gt_knock_down_right_boulder_invoke_add_item__amagi_stronghold_wall_2_invoke_add_item__amagi_stronghold_boulder_2(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $visit(`Amagi > West Lake > Stronghold Ceiling Right > Knock Down Right Boulder`); $add_item(Amagi_Stronghold_Wall_2); $add_item(Amagi_Stronghold_Boulder_2);
}
pub fn observe_action_invoke_visit__ebih_gt_waterfall_gt_alcove_gt_block_left_invoke_visit__ebih_gt_waterfall_gt_alcove_gt_block_right_invoke_add_item__ebih_waterfall_block_right_invoke_add_item__ebih_waterfall_block_left(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $visit(`Ebih > Waterfall > Alcove > Block Left`); $visit(`Ebih > Waterfall > Alcove > Block Right`); $add_item(Ebih_Waterfall_Block_Right); $add_item(Ebih_Waterfall_Block_Left);
}
pub fn observe_action_invoke_visit__giguna_gt_separator_gt_upper_brick_gt_break_bricks_invoke_add_item__giguna_separator_bricks_indra_set_invoke_default(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $visit(`Giguna > Separator > Upper Brick > Break Bricks`); $add_item(Giguna_Separator_Bricks); ^indra = $default;
}
pub fn observe_action_invoke_visit__glacier_gt_fortress_gt_inner_center_gt_shockwave_block_invoke_visit__glacier_gt_fortress_gt_button_gt_hit_button_invoke_collect__big_flask_invoke_add_item__glacier_fortress_gate(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // $visit(`Glacier > Fortress > Inner Center > Shockwave Block`); $visit(`Glacier > Fortress > Button > Hit Button`); $collect(Big_Flask); $add_item(Glacier_Fortress_Gate);
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    rules::observe_action_flasks_incr_2(ctx, world, full_obs);
    full_obs.strict = old_strict;
}
pub fn observe_action_irikar__basement_portal__ctx__platform_moved_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_platform_moved = true
}
pub fn observe_action_irikar__midwest__ctx__left_platform_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_left_platform = true
}
pub fn observe_action_irikar__midwest__ctx__right_platform_set_true(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^_right_platform = true
}
pub fn observe_action_last_set_invoke_default(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^last = $default
}
pub fn observe_action_last_set_position(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^last = ^position
}
pub fn observe_action_mode_set_drone(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // ^mode = 'drone'
}
pub fn observe_action_mode_set_drone_indra_set_position(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^mode = 'drone'; ^indra = ^position
}
pub fn observe_action_mode_set_indra(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // ^mode = 'Indra'
}
pub fn observe_action_mode_set_indra_last_set_indra(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^mode = 'Indra'; ^last = ^indra
}
pub fn observe_action_portal_set_amagi_gt_east_lake_gt_arch_east(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Amagi > East Lake > Arch East`
}
pub fn observe_action_portal_set_amagi_gt_east_lake_gt_arch_west(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Amagi > East Lake > Arch West`
}
pub fn observe_action_portal_set_giguna_gt_clouds_gt_platform_early_portal_invoke_deploy_drone_and_move__giguna_gt_clouds_gt_platform_early_portal(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Giguna > Clouds > Platform Early Portal`; $deploy_drone_and_move(`Giguna > Clouds > Platform Early Portal`)
    let old_strict = full_obs.strict;
    full_obs.strict = true;
    hobserve__deploy_drone_and_move!(
        ctx,
        world,
        SpotId::Giguna__Clouds__Platform_Early_Portal,
        full_obs
    );
    full_obs.strict = old_strict;
}
pub fn observe_action_portal_set_glacier_breach_gt_angry_lions_gt_second_platform(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Glacier Breach > Angry Lions > Second Platform`
}
pub fn observe_action_portal_set_glacier_breach_gt_angry_lions_gt_top_platform(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Glacier Breach > Angry Lions > Top Platform`
}
pub fn observe_action_portal_set_glacier_gt_hammonds_end_gt_corner(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Glacier > Hammond's End > Corner`
}
pub fn observe_action_portal_set_glacier_gt_hammonds_end_gt_hammond(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Glacier > Hammond's End > Hammond`
}
pub fn observe_action_portal_set_glacier_gt_hammonds_end_gt_lower_pedestal_west(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = `Glacier > Hammond's End > Lower Pedestal West`
}
pub fn observe_action_portal_set_position(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^portal = ^position
}
pub fn observe_action_refills_incr_1(ctx: &Context, world: &World, full_obs: &mut FullObservation) {
    // ^refills += 1
}
pub fn observe_action_save_set_emergence_gt_camp_exterior_gt_save_point(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^save = `Emergence > Camp Exterior > Save Point`
}
pub fn observe_action_save_set_glacier_gt_revival_gt_save_point(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^save = `Glacier > Revival > Save Point`
}
pub fn observe_action_save_set_uhrum_gt_emergence_save_gt_save_point(
    ctx: &Context,
    world: &World,
    full_obs: &mut FullObservation,
) {
    // ^save = `Uhrum > Emergence Save > Save Point`
}
pub fn num_invoke_diagonal_speed_spots__position_portal_0_55_1_0_mul_0_5(
    ctx: &Context,
    world: &World,
) -> f32 {
    // $diagonal_speed_spots(^position, ^portal, 0.55, 1.0) * 0.5
    diagonal_speed_spots(ctx.position(), ctx.portal(), 0.55, 1.0) * 0.5
}
pub fn num_invoke_diagonal_speed_spots__position_portal_0_55_1_0_mul_if___indra_eq_position____0_5__else____1_0_(
    ctx: &Context,
    world: &World,
) -> f32 {
    // $diagonal_speed_spots(^position, ^portal, 0.55, 1.0) * IF (^indra == ^position) { 0.5 } ELSE { 1.0 }
    diagonal_speed_spots(ctx.position(), ctx.portal(), 0.55, 1.0)
        * if ctx.indra() == ctx.position() {
            0.5
        } else {
            1.0
        }
}
