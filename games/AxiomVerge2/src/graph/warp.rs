//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::*;
use crate::graph::{World, enums::*};
use crate::observe::FullObservation;
use crate::prices::Currency;
use crate::rules;
use analyzer::context::Ctx;
use analyzer::world;
use enum_map::EnumMap;
use rustc_hash::FxHashMap;
use std::option::Option;

#[derive(Copy, Clone, Debug)]
pub struct Warp {
    id: WarpId,
    dest: SpotId,
    time: u32,
    price: Currency,
}
impl world::Accessible for Warp {
    type Context = Context;
    type Currency = Currency;

    fn can_access(&self, ctx: &Context, world: &World) -> bool {
        ctx.can_afford(&self.price) && match self.id {
            WarpId::BreachSave => rules::access_allow_warps_and_realm_eq_breach_and_breach_save_ne_invoke_default_and_not_apocalypse_bomb(ctx, world),
            WarpId::EarthSave => rules::access_allow_warps_and_within_antarctica(ctx, world),
            WarpId::ExitBreach => rules::access_realm_eq_breach_and_exit_breach_and_flipside_ne_invoke_default(ctx, world),
            WarpId::ExitMenu => rules::access_within_menu_gt_upgrade_menu(ctx, world),
            WarpId::FastTravelBreach => rules::access_allow_warps_and_invoke_ft_breach_and___map_spot_within_menu_gt_breach_map_and_not_apocalypse_bomb(ctx, world),
            WarpId::FastTravelKiengir => rules::access_allow_warps_and_invoke_ft_main_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(ctx, world),
            WarpId::MainSave => rules::access_allow_warps_and_realm_in___main_interior_emergence_and_amashilama_and_not_apocalypse_bomb(ctx, world),
            WarpId::Menu => rules::access_not_within_menu_and_flasks_gt_0(ctx, world),
            WarpId::Portal => rules::access_mode_eq_drone_and_portal_eq_position_and_flipside_ne_invoke_default_and___not_portal_hidden_or_breach_sight_and_not_apocalypse_bomb(ctx, world),
        }
    }
    fn observe_access(&self, ctx: &Context, world: &World, full_obs: &mut FullObservation) -> bool {
        ctx.observe_afford(&self.price, full_obs);
        match self.id {
            WarpId::BreachSave => rules::observe_access_allow_warps_and_realm_eq_breach_and_breach_save_ne_invoke_default_and_not_apocalypse_bomb(ctx, world, full_obs),
            WarpId::EarthSave => rules::observe_access_allow_warps_and_within_antarctica(ctx, world, full_obs),
            WarpId::ExitBreach => rules::observe_access_realm_eq_breach_and_exit_breach_and_flipside_ne_invoke_default(ctx, world, full_obs),
            WarpId::ExitMenu => rules::observe_access_within_menu_gt_upgrade_menu(ctx, world, full_obs),
            WarpId::FastTravelBreach => rules::observe_access_allow_warps_and_invoke_ft_breach_and___map_spot_within_menu_gt_breach_map_and_not_apocalypse_bomb(ctx, world, full_obs),
            WarpId::FastTravelKiengir => rules::observe_access_allow_warps_and_invoke_ft_main_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(ctx, world, full_obs),
            WarpId::MainSave => rules::observe_access_allow_warps_and_realm_in___main_interior_emergence_and_amashilama_and_not_apocalypse_bomb(ctx, world, full_obs),
            WarpId::Menu => rules::observe_access_not_within_menu_and_flasks_gt_0(ctx, world, full_obs),
            WarpId::Portal => rules::observe_access_mode_eq_drone_and_portal_eq_position_and_flipside_ne_invoke_default_and___not_portal_hidden_or_breach_sight_and_not_apocalypse_bomb(ctx, world, full_obs),
            _ => true,
        }
    }
    fn base_time(&self) -> u32 { self.time }
    fn time(&self, ctx: &Context, world: &World) -> u32 {
        self.time
            + match self.id {
                WarpId::MainSave => {
                    if rules::access_mode_ne_drone(ctx, world) {
                        2500
                    } else {
                        0
                    }
                }
            _ => 0,
        }
    }
    fn price(&self) -> &Currency { &self.price }

    fn explain_rule(&self, ctx: &Self::Context, world: &World, edict: &mut FxHashMap<&'static str, String>) -> (bool, Vec<&'static str>) {
        match self.id {
            WarpId::BreachSave => {
                let (ret, mut tags) = rules::explain_allow_warps_and_realm_eq_breach_and_breach_save_ne_invoke_default_and_not_apocalypse_bomb(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "ctx.breach_save()"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::EarthSave => {
                let (ret, mut tags) = rules::explain_allow_warps_and_within_antarctica(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "ctx.save()"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::ExitBreach => {
                let (ret, mut tags) = rules::explain_realm_eq_breach_and_exit_breach_and_flipside_ne_invoke_default(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "data::flipside(ctx.position())"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::ExitMenu => {
                let (ret, mut tags) = rules::explain_within_menu_gt_upgrade_menu(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "ctx.last()"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::FastTravelBreach => {
                let (ret, mut tags) = rules::explain_allow_warps_and_invoke_ft_breach_and___map_spot_within_menu_gt_breach_map_and_not_apocalypse_bomb(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "data::map_spot(ctx.position())"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::FastTravelKiengir => {
                let (ret, mut tags) = rules::explain_allow_warps_and_invoke_ft_main_and___map_spot_within_menu_gt_kiengir_map_and_not_apocalypse_bomb(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "data::map_spot(ctx.position())"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::MainSave => {
                let (ret, mut tags) = rules::explain_allow_warps_and_realm_in___main_interior_emergence_and_amashilama_and_not_apocalypse_bomb(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "ctx.save()"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::Menu => {
                let (ret, mut tags) = rules::explain_not_within_menu_and_flasks_gt_0(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "SpotId::Menu__Upgrade_Menu__Physiology"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            WarpId::Portal => {
                let (ret, mut tags) = rules::explain_mode_eq_drone_and_portal_eq_position_and_flipside_ne_invoke_default_and___not_portal_hidden_or_breach_sight_and_not_apocalypse_bomb(ctx, world, edict);
                let dest = world::Warp::dest(self, ctx, world);
                if dest != SpotId::None {
                    edict.insert("dest", format!("{} ({})", dest, "data::flipside(ctx.position())"));
                    tags.push("dest");
                }
                (ret, tags)
            }
            _ => (true, vec![])
        }
    }
}
impl world::Warp for Warp {
    type WarpId = WarpId;
    type SpotId = SpotId;

    fn id(&self) -> WarpId { self.id }
    fn dest(&self, ctx: &Context, world: &World) -> SpotId {
        if self.dest == SpotId::None {
            match self.id {
                WarpId::BreachSave => ctx.breach_save(),
                WarpId::EarthSave => ctx.save(),
                WarpId::ExitBreach => data::flipside(ctx.position()),
                WarpId::ExitMenu => ctx.last(),
                WarpId::FastTravelBreach => data::map_spot(ctx.position()),
                WarpId::FastTravelKiengir => data::map_spot(ctx.position()),
                WarpId::MainSave => ctx.save(),
                WarpId::Menu => SpotId::Menu__Upgrade_Menu__Physiology,
                WarpId::Portal => data::flipside(ctx.position()),
            }
        } else {
            self.dest
        }
    }
    fn connect(&mut self, dest: SpotId) { self.dest = dest; }
    fn prewarp(&self, ctx: &mut Context, world: &World) {
        match self.id {
            WarpId::Menu => rules::action_last_set_position(ctx, world),
            _ => (),
        }
    }
    fn postwarp(&self, ctx: &mut Context, world: &World) {
        match self.id {
            WarpId::BreachSave => rules::action_invoke_refill_energy(ctx, world),
            WarpId::ExitBreach => rules::action_invoke_clear_breach_save(ctx, world),
            WarpId::ExitMenu => rules::action_last_set_invoke_default(ctx, world),
            WarpId::MainSave => rules::action_invoke_refill_energy(ctx, world),
            WarpId::Portal => rules::action_invoke_post_portal_save_update(ctx, world),
            _ => (),
        }
    }
    fn should_reload(&self) -> bool {
        match self.id {
            WarpId::BreachSave => true,
            WarpId::EarthSave => true,
            WarpId::ExitBreach => false,
            WarpId::ExitMenu => false,
            WarpId::FastTravelBreach => false,
            WarpId::FastTravelKiengir => false,
            WarpId::MainSave => true,
            WarpId::Menu => false,
            WarpId::Portal => false,
        }
    }
    fn observe_effects(&self, ctx: &Context, world: &World, full_obs: &mut FullObservation) {
        match self.id {
            WarpId::BreachSave => {
                rules::observe_action_invoke_refill_energy(ctx, world, full_obs);
            }
            WarpId::EarthSave => {
            }
            WarpId::ExitBreach => {
                rules::observe_action_invoke_clear_breach_save(ctx, world, full_obs);
            }
            WarpId::ExitMenu => {
                rules::observe_action_last_set_invoke_default(ctx, world, full_obs);
            }
            WarpId::FastTravelBreach => {
            }
            WarpId::FastTravelKiengir => {
            }
            WarpId::MainSave => {
                rules::observe_action_invoke_refill_energy(ctx, world, full_obs);
            }
            WarpId::Menu => {
                rules::observe_action_last_set_position(ctx, world, full_obs);
            }
            WarpId::Portal => {
                rules::observe_action_invoke_post_portal_save_update(ctx, world, full_obs);
            }
        }
    }
}

pub(super) fn build_warps(warps: &mut EnumMap<WarpId, Warp>) {
    warps[WarpId::BreachSave] = Warp {
        id: WarpId::BreachSave,
        dest: SpotId::None,
        time: 10500,
        price: Currency::Free,
    };
    warps[WarpId::EarthSave] = Warp {
        id: WarpId::EarthSave,
        dest: SpotId::None,
        time: 3000,
        price: Currency::Free,
    };
    warps[WarpId::ExitBreach] = Warp {
        id: WarpId::ExitBreach,
        dest: SpotId::None,
        time: 3000,
        price: Currency::Free,
    };
    warps[WarpId::ExitMenu] = Warp {
        id: WarpId::ExitMenu,
        dest: SpotId::None,
        time: 200,
        price: Currency::Free,
    };
    warps[WarpId::FastTravelBreach] = Warp {
        id: WarpId::FastTravelBreach,
        dest: SpotId::None,
        time: 100,
        price: Currency::Free,
    };
    warps[WarpId::FastTravelKiengir] = Warp {
        id: WarpId::FastTravelKiengir,
        dest: SpotId::None,
        time: 100,
        price: Currency::Free,
    };
    warps[WarpId::MainSave] = Warp {
        id: WarpId::MainSave,
        dest: SpotId::None,
        time: 10500,
        price: Currency::Free,
    };
    warps[WarpId::Menu] = Warp {
        id: WarpId::Menu,
        dest: SpotId::None,
        time: 1000,
        price: Currency::Free,
    };
    warps[WarpId::Portal] = Warp {
        id: WarpId::Portal,
        dest: SpotId::None,
        time: 3600,
        price: Currency::Free,
    };
}