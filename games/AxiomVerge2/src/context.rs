//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_snake_case)]
#![allow(unused)]

use crate::graph::{self, *};
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::context;
use analyzer::world::World;
use enum_map::EnumMap;

pub mod enums {
    use std::fmt;
    #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash, Ord, PartialOrd, Default)]
    pub enum Mode {
        #[default]
        Indra,
        Drone,
    }
    impl fmt::Display for Mode {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Mode::Indra => write!(f, "{}", "Indra"),
                Mode::Drone => write!(f, "{}", "Drone"),
            }
        }
    }
    impl std::str::FromStr for Mode {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Drone" => Ok(Mode::Drone),
                "Indra" => Ok(Mode::Indra),
                _ => Err(format!("Could not recognize as a Mode: {}", s)),
            }
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
pub enum Status {
    #[default]
    None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Context {
    // context vars
    pub position: SpotId,
    pub save: SpotId,
    pub mode: enums::Mode,
    pub indra: SpotId,
    pub last: SpotId,
    pub prev_area: AreaId,
    pub energy: i32,
    pub breach: bool,
    pub flasks: i32,
    pub ebih__waterfall__ctx__left_block: bool,
    pub ebih__waterfall__ctx__right_block: bool,
    pub ebih__ebih_east__ctx__platform1_moved: bool,
    pub ebih__ebih_east__ctx__platform2_moved: bool,
    pub ebih__drone_room__ctx__platform_moved: bool,
    // settings
    pub boomerang_steering: bool,
    pub major_glitches: bool,
    pub minor_glitches: bool,
    // items
    pub amashilama: bool,
    pub anuman: bool,
    pub apocalypse_bomb: bool,
    pub boomerang: bool,
    pub defeat_ebih_alu: bool,
    pub flask: i8,
    pub ice_axe: bool,
    pub infect: bool,
    pub ledge_grab: bool,
    pub mist_upgrade: bool,
    pub remote_drone: bool,
    pub slingshot_hook: bool,
    pub station_power: bool,
    pub switch_36_11: bool,
    pub switch_40_12: bool,
    pub wall_climb: bool,
    // other
    pub status: EnumMap<LocationId, Status>,
    visits: i32,
    skips: i32,
}

impl Default for Context {
    fn default() -> Context {
        Context {
            position: SpotId::Antarctica__West__Helipad,
            save: SpotId::Antarctica__West__Helipad,
            mode: enums::Mode::Indra,
            indra: SpotId::None,
            last: SpotId::None,
            prev_area: AreaId::Antarctica__West,
            energy: 0,
            breach: false,
            flasks: 0,
            ebih__waterfall__ctx__left_block: false,
            ebih__waterfall__ctx__right_block: false,
            ebih__ebih_east__ctx__platform1_moved: false,
            ebih__ebih_east__ctx__platform2_moved: false,
            ebih__drone_room__ctx__platform_moved: false,
            // settings
            boomerang_steering: Default::default(),
            major_glitches: Default::default(),
            minor_glitches: Default::default(),
            // items
            amashilama: Default::default(),
            anuman: Default::default(),
            apocalypse_bomb: Default::default(),
            boomerang: Default::default(),
            defeat_ebih_alu: Default::default(),
            flask: Default::default(),
            ice_axe: Default::default(),
            infect: Default::default(),
            ledge_grab: Default::default(),
            mist_upgrade: Default::default(),
            remote_drone: Default::default(),
            slingshot_hook: Default::default(),
            station_power: Default::default(),
            switch_36_11: Default::default(),
            switch_40_12: Default::default(),
            wall_climb: Default::default(),
            // other
            status: Default::default(),
            visits: Default::default(),
            skips: Default::default(),
        }
    }
}

impl context::Ctx for Context {
    type World = graph::World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;
    const NUM_ITEMS: i32 = 16;

    fn has(&self, item: Item) -> bool {
        match item {
            Item::Amashilama => self.amashilama,
            Item::Anuman => self.anuman,
            Item::Apocalypse_Bomb => self.apocalypse_bomb,
            Item::Boomerang => self.boomerang,
            Item::Defeat_Ebih_Alu => self.defeat_ebih_alu,
            Item::Flask => self.flask >= 1,
            Item::Ice_Axe => self.ice_axe,
            Item::Infect => self.infect,
            Item::Ledge_Grab => self.ledge_grab,
            Item::Mist_Upgrade => self.mist_upgrade,
            Item::Remote_Drone => self.remote_drone,
            Item::Slingshot_Hook => self.slingshot_hook,
            Item::Station_Power => self.station_power,
            Item::Switch_36_11 => self.switch_36_11,
            Item::Switch_40_12 => self.switch_40_12,
            Item::Wall_Climb => self.wall_climb,
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
            Item::Amashilama => self.amashilama.into(),
            Item::Anuman => self.anuman.into(),
            Item::Apocalypse_Bomb => self.apocalypse_bomb.into(),
            Item::Boomerang => self.boomerang.into(),
            Item::Defeat_Ebih_Alu => self.defeat_ebih_alu.into(),
            Item::Flask => self.flask.into(),
            Item::Ice_Axe => self.ice_axe.into(),
            Item::Infect => self.infect.into(),
            Item::Ledge_Grab => self.ledge_grab.into(),
            Item::Mist_Upgrade => self.mist_upgrade.into(),
            Item::Remote_Drone => self.remote_drone.into(),
            Item::Slingshot_Hook => self.slingshot_hook.into(),
            Item::Station_Power => self.station_power.into(),
            Item::Switch_36_11 => self.switch_36_11.into(),
            Item::Switch_40_12 => self.switch_40_12.into(),
            Item::Wall_Climb => self.wall_climb.into(),
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
            Item::Amashilama => {
                self.amashilama = true;
                rules::action_save__glacier__revival__save_point(self);
            }
            Item::Anuman => {
                self.anuman = true;
            }
            Item::Apocalypse_Bomb => {
                self.apocalypse_bomb = true;
            }
            Item::Boomerang => {
                self.boomerang = true;
            }
            Item::Defeat_Ebih_Alu => {
                self.defeat_ebih_alu = true;
            }
            Item::Flask => {
                self.flask += 1;
                rules::action_flasks__1(self);
            }
            Item::Ice_Axe => {
                self.ice_axe = true;
            }
            Item::Infect => {
                self.infect = true;
                rules::action_energy__max_energy(self);
            }
            Item::Ledge_Grab => {
                self.ledge_grab = true;
            }
            Item::Mist_Upgrade => {
                self.mist_upgrade = true;
            }
            Item::Remote_Drone => {
                self.remote_drone = true;
            }
            Item::Slingshot_Hook => {
                self.slingshot_hook = true;
            }
            Item::Station_Power => {
                self.station_power = true;
            }
            Item::Switch_36_11 => {
                self.switch_36_11 = true;
            }
            Item::Switch_40_12 => {
                self.switch_40_12 = true;
            }
            Item::Wall_Climb => {
                self.wall_climb = true;
            }
            Item::Health_Node => rules::action_energy__max_energy(self),
            _ => (),
        }
    }

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position(&mut self, pos: SpotId) {
        let area = get_area(pos);
        match area {
            AreaId::Antarctica__East => {
                if get_area(self.position) != area {
                    self.save = SpotId::Antarctica__East__Save_Point;
                }
            }
            AreaId::Ebih__Base_Camp => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Boss_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Building_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Bunker_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__By_Garage => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Cave => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Drone_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Ebih_East => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Ebih_West => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Garage => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_21_1_5 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_25_10_12 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_25_2_6 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Tent_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Waterfall => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            _ => (),
        }
        self.position = pos;
    }

    fn reload_game(&mut self) {
        self.reset_all();
    }

    fn reset_all(&mut self) {
        self.ebih__ebih_east__ctx__platform1_moved = false;
        self.ebih__ebih_east__ctx__platform2_moved = false;
        self.ebih__drone_room__ctx__platform_moved = false;
    }

    fn reset_region(&mut self, region_id: RegionId) {}
    fn reset_area(&mut self, area_id: AreaId) {
        match area_id {
            AreaId::Ebih__Ebih_East => {
                self.ebih__ebih_east__ctx__platform1_moved = false;
                self.ebih__ebih_east__ctx__platform2_moved = false;
            }
            AreaId::Ebih__Drone_Room => {
                self.ebih__drone_room__ctx__platform_moved = false;
            }
            _ => (),
        }
    }
    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
            Currency::Energy(c) => self.energy >= *c,
            Currency::Flasks(c) => self.flasks >= *c,
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
            Currency::Energy(c) => self.energy -= *c,
            Currency::Flasks(c) => self.flasks -= *c,
        }
    }

    fn visit(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Visited;
        self.visits += 1;
    }
    fn skip(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Skipped;
        self.skips += 1;
    }
    fn reset(&mut self, loc_id: LocationId) {
        match self.status[loc_id] {
            Status::Visited => self.visits -= 1,
            Status::Skipped => self.skips -= 1,
            _ => (),
        }
        self.status[loc_id] = Status::None;
    }

    fn todo(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::None
    }
    fn visited(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Visited
    }
    fn skipped(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Skipped
    }

    fn all_spot_checks(&self, id: SpotId) -> bool {
        let r = spot_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_area_checks(&self, id: AreaId) -> bool {
        let r = area_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_region_checks(&self, id: RegionId) -> bool {
        let r = region_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn local_travel_time(&self, dest: SpotId) -> i32 {
        movements::local_travel_time(self, self.position, dest)
    }

    fn count_visits(&self) -> i32 {
        self.visits
    }
    fn count_skips(&self) -> i32 {
        self.skips
    }
    fn progress(&self) -> i32 {
        if self.visits <= 0 {
            0
        } else {
            self.visits * 100 / (Self::World::NUM_LOCATIONS - self.skips)
        }
    }
}

impl Context {
    pub fn position(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.position,
            },
        }
    }
    pub fn save(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.save,
            },
        }
    }
    pub fn mode(&self) -> enums::Mode {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.mode,
            },
        }
    }
    pub fn indra(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.indra,
            },
        }
    }
    pub fn last(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.last,
            },
        }
    }
    pub fn prev_area(&self) -> AreaId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.prev_area,
            },
        }
    }
    pub fn energy(&self) -> i32 {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.energy,
            },
        }
    }
    pub fn breach(&self) -> bool {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.breach,
            },
        }
    }
    pub fn flasks(&self) -> i32 {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.flasks,
            },
        }
    }
    pub fn ebih__waterfall__ctx__left_block(&self) -> bool {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.ebih__waterfall__ctx__left_block,
            },
        }
    }
    pub fn ebih__waterfall__ctx__right_block(&self) -> bool {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.ebih__waterfall__ctx__right_block,
            },
        }
    }
    pub fn ebih__ebih_east__ctx__platform1_moved(&self) -> bool {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.ebih__ebih_east__ctx__platform1_moved,
            },
        }
    }
    pub fn ebih__ebih_east__ctx__platform2_moved(&self) -> bool {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.ebih__ebih_east__ctx__platform2_moved,
            },
        }
    }
    pub fn ebih__drone_room__ctx__platform_moved(&self) -> bool {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.ebih__drone_room__ctx__platform_moved,
            },
        }
    }
}
