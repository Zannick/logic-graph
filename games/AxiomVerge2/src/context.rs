//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_snake_case)]
#![allow(unused)]

use crate::graph::{self, *};
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::context;
use analyzer::world::World;
use enum_map::EnumMap;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use std::str::FromStr;
use yaml_rust::Yaml;

pub mod enums {
    use std::fmt;
    #[derive(
        Debug,
        PartialEq,
        Eq,
        Copy,
        Clone,
        Hash,
        Ord,
        PartialOrd,
        Default,
        serde_repr::Serialize_repr,
        serde_repr::Deserialize_repr,
    )]
    #[repr(u8)]
    pub enum Mode {
        #[default]
        Indra,
        Drone,
    }
    impl fmt::Display for Mode {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Mode::Indra => write!(f, "{}", "Indra"),
                Mode::Drone => write!(f, "{}", "Drone"),
            }
        }
    }
    impl std::str::FromStr for Mode {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Drone" => Ok(Mode::Drone),
                "Indra" => Ok(Mode::Indra),
                _ => Err(format!("Could not recognize as a Mode: {}", s)),
            }
        }
    }
}

pub mod data {
    #[allow(unused_imports)]
    use crate::context::enums;
    use crate::graph::*;
    pub fn breach(spot_id: SpotId) -> bool {
        match spot_id {
            SpotId::Giguna_Breach__Peak__Save_Point => true,
            _ => false,
        }
    }
    pub fn water(spot_id: SpotId) -> bool {
        match spot_id {
            SpotId::Amagi__Cave_Behind_Waterfall__Bottom => false,
            SpotId::Amagi__Cave_Behind_Waterfall__Middle => false,
            SpotId::Amagi__Cave_Behind_Waterfall__Top => false,
            SpotId::Amagi__Grid_31_19__East => true,
            SpotId::Amagi__Grid_31_19__West => true,
            SpotId::Amagi__Liru_Room__Bottom => true,
            SpotId::Amagi__Liru_Room__East_Passage => true,
            SpotId::Amagi__Liru_Room__Hidden_Enemies => true,
            SpotId::Amagi__Liru_Room__Hidden_Exit => true,
            SpotId::Amagi__Liru_Room__Platform_1_Left => true,
            SpotId::Amagi__Liru_Room__Platform_1_Right => true,
            SpotId::Amagi__Liru_Room__Platform_2_Left => true,
            SpotId::Amagi__Liru_Room__Platform_2_Right => true,
            SpotId::Amagi__Liru_Room__Platform_3_Left => true,
            SpotId::Amagi__Liru_Room__Platform_3_Right => true,
            SpotId::Amagi__Liru_Room__Platform_4_Left => true,
            SpotId::Amagi__Liru_Room__Platform_4_Right => true,
            SpotId::Amagi__Liru_Room__Shrine => true,
            SpotId::Amagi__Liru_Room__West_19 => true,
            SpotId::Amagi__Liru_Room__West_20 => true,
            SpotId::Amagi__Main_Area__Broken_Wall => true,
            SpotId::Amagi__Main_Area__Carving => false,
            SpotId::Amagi__Main_Area__Catwalk_Broken_Part => true,
            SpotId::Amagi__Main_Area__Catwalk_Center => true,
            SpotId::Amagi__Main_Area__Catwalk_East_Edge => true,
            SpotId::Amagi__Main_Area__Cliff => true,
            SpotId::Amagi__Main_Area__East_15 => false,
            SpotId::Amagi__Main_Area__East_19 => true,
            SpotId::Amagi__Main_Area__East_Ledge => true,
            SpotId::Amagi__Main_Area__Enemy_Side => true,
            SpotId::Amagi__Main_Area__Flat_Ruin => true,
            SpotId::Amagi__Main_Area__Half_Pillar => true,
            SpotId::Amagi__Main_Area__Platform_2 => true,
            SpotId::Amagi__Main_Area__Platform_3 => true,
            SpotId::Amagi__Main_Area__Save_Point => true,
            SpotId::Amagi__Main_Area__Secret_Outcropping => false,
            SpotId::Amagi__Main_Area__Secret_Waterfall => false,
            SpotId::Amagi__Main_Area__Shallow_End => true,
            SpotId::Amagi__Main_Area__Small_Cliff => true,
            SpotId::Amagi__Main_Area__Upper_Platform => true,
            SpotId::Amagi__Main_Area__Wall_Stuck_Spot => true,
            SpotId::Amagi__Main_Area__Waters_Edge => false,
            SpotId::Amagi__Main_Area__Way_Off_To_The_Side => false,
            SpotId::Amagi__Main_Area__West_15 => false,
            SpotId::Amagi__Main_Area__West_18 => true,
            SpotId::Amagi__Main_Area__West_19 => true,
            SpotId::Amagi__Main_Area__West_Mini_Hill => true,
            SpotId::Amagi__Main_Area__West_Shelf => true,
            SpotId::Amagi__Main_Area__West_Side => true,
            SpotId::Amagi__West_Lake__Cavern_Back_Teeth => true,
            SpotId::Amagi__West_Lake__Cavern_Chin => true,
            SpotId::Amagi__West_Lake__Cavern_Eye => true,
            SpotId::Amagi__West_Lake__Cavern_Front_Pillar => true,
            SpotId::Amagi__West_Lake__Cavern_Front_Teeth => true,
            SpotId::Amagi__West_Lake__Cavern_Jaw => true,
            SpotId::Amagi__West_Lake__Cavern_Lower_Trachea => true,
            SpotId::Amagi__West_Lake__Cavern_Middle_Pillar => true,
            SpotId::Amagi__West_Lake__Cavern_Neck => true,
            SpotId::Amagi__West_Lake__Cavern_Rear_Pillar => true,
            SpotId::Amagi__West_Lake__Cavern_Refill_Station => true,
            SpotId::Amagi__West_Lake__Cavern_Tear_Duct => true,
            SpotId::Amagi__West_Lake__East_15 => false,
            SpotId::Amagi__West_Lake__East_18 => true,
            SpotId::Amagi__West_Lake__East_19 => true,
            SpotId::Amagi__West_Lake__East_20 => true,
            SpotId::Amagi__West_Lake__East_Bank => true,
            SpotId::Amagi__West_Lake__East_Platform => true,
            SpotId::Amagi__West_Lake__East_Shore => false,
            SpotId::Amagi__West_Lake__Left_of_Enemy => true,
            SpotId::Amagi__West_Lake__Northeast_Platform => true,
            SpotId::Amagi__West_Lake__Northwest_Platform => true,
            SpotId::Amagi__West_Lake__Pillar => true,
            SpotId::Amagi__West_Lake__Pillar_Platform => true,
            SpotId::Amagi__West_Lake__Small_Hill => true,
            SpotId::Amagi__West_Lake__Some_Rock => true,
            SpotId::Amagi__West_Lake__Somewhat_Central_Platform => true,
            SpotId::Amagi__West_Lake__Stronghold_Ceiling_Left => true,
            SpotId::Amagi__West_Lake__Stronghold_Ceiling_Right => true,
            SpotId::Amagi__West_Lake__Stronghold_Front_Door => true,
            SpotId::Amagi__West_Lake__Stronghold_Front_Room => true,
            SpotId::Amagi__West_Lake__Stronghold_Item => true,
            SpotId::Amagi__West_Lake__Stronghold_Middle_Column => true,
            SpotId::Amagi__West_Lake__Stronghold_Rear_Wall => true,
            SpotId::Amagi__West_Lake__Stronghold_Top => true,
            SpotId::Amagi__West_Lake__Surface_Wall_Left => false,
            SpotId::Amagi__West_Lake__Surface_Wall_Right => false,
            SpotId::Amagi__West_Lake__Tentacle_Gap => true,
            SpotId::Amagi__West_Lake__Upper_Center_Platform => true,
            SpotId::Amagi__West_Lake__Water_Surface => false,
            SpotId::Amagi__West_Lake__West_15 => false,
            SpotId::Amagi__West_Lake__West_Bank => true,
            SpotId::Amagi__West_Lake__West_Cliff => true,
            SpotId::Amagi__West_Lake__West_Platform => true,
            SpotId::Amagi__West_Lake__West_Shore => false,
            _ => false,
        }
    }
    pub fn flipside(spot_id: SpotId) -> SpotId {
        match spot_id {
            _ => SpotId::None,
        }
    }
}

pub mod flags {
    use bitflags::bitflags;
    use serde::{self, Deserialize, Serialize};

    bitflags! {
        #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub struct ContextBits1 : u32 {
            const AMAGI__MAIN_AREA__CTX__COMBO = 1 << 0;
            const EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED = 1 << 1;
            const EBIH__GRID_25_10_12__CTX__DOOR_OPEN = 1 << 2;
            const EBIH__WATERFALL__CTX__WEST_DOOR_OPEN = 1 << 3;
            const EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED = 1 << 4;
            const EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED = 1 << 5;
            const EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED = 1 << 6;
            const GIGUNA__GIGUNA_NORTHEAST__CTX__DOOR_OPENED = 1 << 7;
            const GIGUNA__CARNELIAN__CTX__DOOR_OPENED = 1 << 8;
            const GIGUNA__CARNELIAN__CTX__UPPER_SUSAR = 1 << 9;
            const GIGUNA__CARNELIAN__CTX__LOWER_SUSAR = 1 << 10;
            const GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR = 1 << 11;
            const GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED = 1 << 12;
            const GIGUNA__RUINS_UPPER__CTX__DOORS_OPEN = 1 << 13;
            const BOOMERANG_STEERING = 1 << 14;
            const MAJOR_GLITCHES = 1 << 15;
            const MINOR_GLITCHES = 1 << 16;
            const AMAGI_DRAGON_EYE_PASSAGE = 1 << 17;
            const AMAGI_STRONGHOLD_BOULDER_1 = 1 << 18;
            const AMAGI_STRONGHOLD_BOULDER_2 = 1 << 19;
            const AMAGI_STRONGHOLD_WALL_1 = 1 << 20;
            const AMAGI_STRONGHOLD_WALL_2 = 1 << 21;
            const AMAGI_WEST_LAKE_SURFACE_WALL = 1 << 22;
            const AMASHILAMA = 1 << 23;
            const ANUMAN = 1 << 24;
            const APOCALYPSE_BOMB = 1 << 25;
            const BOOMERANG = 1 << 26;
            const COMPANIES_LAYOFF = 1 << 27;
            const DEAR_ERNEST = 1 << 28;
            const DEFEAT_EBIH_ALU = 1 << 29;
            const DEFEAT_MUS_A_M20 = 1 << 30;
            const DRONE_HOVER = 1 << 31;
        }
    }
    bitflags! {
        #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub struct ContextBits2 : u32 {
            const EBIH_WATERFALL_BLOCK_LEFT = 1 << 0;
            const EBIH_WATERFALL_BLOCK_RIGHT = 1 << 1;
            const FAST_TRAVEL = 1 << 2;
            const GIGUNA_NORTHEAST_GATE = 1 << 3;
            const HERETICS_TABLET = 1 << 4;
            const ICE_AXE = 1 << 5;
            const INFECTION_SPEED = 1 << 6;
            const LEDGE_GRAB = 1 << 7;
            const LETTER_FROM_TRACE = 1 << 8;
            const MAP_17_10 = 1 << 9;
            const NANITE_MIST = 1 << 10;
            const POWER_MATRIX = 1 << 11;
            const RECORD_LOSSES = 1 << 12;
            const REMOTE_DRONE = 1 << 13;
            const RESEARCHERS_MISSING = 1 << 14;
            const SHOCKWAVE = 1 << 15;
            const SLINGSHOT_HOOK = 1 << 16;
            const STATION_POWER = 1 << 17;
            const SWITCH_36_11 = 1 << 18;
            const SWITCH_40_12 = 1 << 19;
            const TERMINAL_BREAKTHROUGH_1 = 1 << 20;
            const UNDER_SIEGE = 1 << 21;
            const UNDERWATER_MOVEMENT = 1 << 22;
            const WALL_CLIMB = 1 << 23;
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum Status {
    #[default]
    None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct Context {
    // context vars
    pub position: SpotId,
    pub energy: i16,
    pub flasks: i8,
    pub refills: i8,
    pub mode: enums::Mode,
    pub save: SpotId,
    pub indra: SpotId,
    pub last: SpotId,
    pub prev_area: AreaId,
    // settings
    // items
    pub drone_melee_damage: i8,
    pub drone_melee_speed: i8,
    pub flask: i8,
    pub health_upgrade: i8,
    pub infect: i8,
    pub infection_range: i8,
    pub melee_damage: i8,
    pub melee_speed: i8,
    pub nano_points: i8,
    pub ranged_damage: i8,
    pub ranged_speed: i8,
    // bitflags
    pub cbits1: flags::ContextBits1,
    pub cbits2: flags::ContextBits2,
    // other
    pub status: EnumMap<LocationId, Status>,

    visits: u32,
    skips: u32,
}

impl Default for Context {
    fn default() -> Context {
        Context {
            position: SpotId::Antarctica__West__Helipad,
            save: SpotId::Antarctica__West__Helipad,
            indra: SpotId::None,
            last: SpotId::None,
            prev_area: AreaId::Antarctica__West,
            energy: 0,
            flasks: 0,
            refills: 0,
            mode: enums::Mode::Indra,
            // settings
            // items
            drone_melee_damage: Default::default(),
            drone_melee_speed: Default::default(),
            flask: Default::default(),
            health_upgrade: Default::default(),
            infect: Default::default(),
            infection_range: Default::default(),
            melee_damage: Default::default(),
            melee_speed: Default::default(),
            nano_points: Default::default(),
            ranged_damage: Default::default(),
            ranged_speed: Default::default(),
            // bitflags
            cbits1: Default::default(),
            cbits2: Default::default(),
            // other
            status: Default::default(),
            visits: Default::default(),
            skips: Default::default(),
        }
    }
}

impl context::Ctx for Context {
    type World = graph::World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;
    type MovementState = movements::MovementState;
    const NUM_ITEMS: u32 = 50;

    fn has(&self, item: Item) -> bool {
        match item {
            Item::Amagi_Dragon_Eye_Passage => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_DRAGON_EYE_PASSAGE),
            Item::Amagi_Stronghold_Boulder_1 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_1),
            Item::Amagi_Stronghold_Boulder_2 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_2),
            Item::Amagi_Stronghold_Wall_1 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_1),
            Item::Amagi_Stronghold_Wall_2 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_2),
            Item::Amagi_West_Lake_Surface_Wall => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_WEST_LAKE_SURFACE_WALL),
            Item::Amashilama => self.cbits1.contains(flags::ContextBits1::AMASHILAMA),
            Item::Anuman => self.cbits1.contains(flags::ContextBits1::ANUMAN),
            Item::Apocalypse_Bomb => self.cbits1.contains(flags::ContextBits1::APOCALYPSE_BOMB),
            Item::Boomerang => self.cbits1.contains(flags::ContextBits1::BOOMERANG),
            Item::Companies_Layoff => self.cbits1.contains(flags::ContextBits1::COMPANIES_LAYOFF),
            Item::Dear_Ernest => self.cbits1.contains(flags::ContextBits1::DEAR_ERNEST),
            Item::Defeat_Ebih_Alu => self.cbits1.contains(flags::ContextBits1::DEFEAT_EBIH_ALU),
            Item::Defeat_MUS_A_M20 => self.cbits1.contains(flags::ContextBits1::DEFEAT_MUS_A_M20),
            Item::Drone_Hover => self.cbits1.contains(flags::ContextBits1::DRONE_HOVER),
            Item::Drone_Melee_Damage => self.drone_melee_damage >= 1,
            Item::Drone_Melee_Speed => self.drone_melee_speed >= 1,
            Item::Ebih_Waterfall_Block_Left => self
                .cbits2
                .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_LEFT),
            Item::Ebih_Waterfall_Block_Right => self
                .cbits2
                .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_RIGHT),
            Item::Fast_Travel => self.cbits2.contains(flags::ContextBits2::FAST_TRAVEL),
            Item::Flask => self.flask >= 1,
            Item::Giguna_Northeast_Gate => self
                .cbits2
                .contains(flags::ContextBits2::GIGUNA_NORTHEAST_GATE),
            Item::Health_Upgrade => self.health_upgrade >= 1,
            Item::Heretics_Tablet => self.cbits2.contains(flags::ContextBits2::HERETICS_TABLET),
            Item::Ice_Axe => self.cbits2.contains(flags::ContextBits2::ICE_AXE),
            Item::Infect => self.infect >= 1,
            Item::Infection_Range => self.infection_range >= 1,
            Item::Infection_Speed => self.cbits2.contains(flags::ContextBits2::INFECTION_SPEED),
            Item::Ledge_Grab => self.cbits2.contains(flags::ContextBits2::LEDGE_GRAB),
            Item::Letter_from_Trace => self.cbits2.contains(flags::ContextBits2::LETTER_FROM_TRACE),
            Item::Map_17_10 => self.cbits2.contains(flags::ContextBits2::MAP_17_10),
            Item::Melee_Damage => self.melee_damage >= 1,
            Item::Melee_Speed => self.melee_speed >= 1,
            Item::Nanite_Mist => self.cbits2.contains(flags::ContextBits2::NANITE_MIST),
            Item::Nano_Points => self.nano_points >= 1,
            Item::Power_Matrix => self.cbits2.contains(flags::ContextBits2::POWER_MATRIX),
            Item::Ranged_Damage => self.ranged_damage >= 1,
            Item::Ranged_Speed => self.ranged_speed >= 1,
            Item::Record_Losses => self.cbits2.contains(flags::ContextBits2::RECORD_LOSSES),
            Item::Remote_Drone => self.cbits2.contains(flags::ContextBits2::REMOTE_DRONE),
            Item::Researchers_Missing => self
                .cbits2
                .contains(flags::ContextBits2::RESEARCHERS_MISSING),
            Item::Shockwave => self.cbits2.contains(flags::ContextBits2::SHOCKWAVE),
            Item::Slingshot_Hook => self.cbits2.contains(flags::ContextBits2::SLINGSHOT_HOOK),
            Item::Station_Power => self.cbits2.contains(flags::ContextBits2::STATION_POWER),
            Item::Switch_36_11 => self.cbits2.contains(flags::ContextBits2::SWITCH_36_11),
            Item::Switch_40_12 => self.cbits2.contains(flags::ContextBits2::SWITCH_40_12),
            Item::Terminal_Breakthrough_1 => self
                .cbits2
                .contains(flags::ContextBits2::TERMINAL_BREAKTHROUGH_1),
            Item::Under_Siege => self.cbits2.contains(flags::ContextBits2::UNDER_SIEGE),
            Item::Underwater_Movement => self
                .cbits2
                .contains(flags::ContextBits2::UNDERWATER_MOVEMENT),
            Item::Wall_Climb => self.cbits2.contains(flags::ContextBits2::WALL_CLIMB),
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
            Item::Amagi_Dragon_Eye_Passage => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_DRAGON_EYE_PASSAGE)
                .into(),
            Item::Amagi_Stronghold_Boulder_1 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_1)
                .into(),
            Item::Amagi_Stronghold_Boulder_2 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_2)
                .into(),
            Item::Amagi_Stronghold_Wall_1 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_1)
                .into(),
            Item::Amagi_Stronghold_Wall_2 => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_2)
                .into(),
            Item::Amagi_West_Lake_Surface_Wall => self
                .cbits1
                .contains(flags::ContextBits1::AMAGI_WEST_LAKE_SURFACE_WALL)
                .into(),
            Item::Amashilama => self.cbits1.contains(flags::ContextBits1::AMASHILAMA).into(),
            Item::Anuman => self.cbits1.contains(flags::ContextBits1::ANUMAN).into(),
            Item::Apocalypse_Bomb => self
                .cbits1
                .contains(flags::ContextBits1::APOCALYPSE_BOMB)
                .into(),
            Item::Boomerang => self.cbits1.contains(flags::ContextBits1::BOOMERANG).into(),
            Item::Companies_Layoff => self
                .cbits1
                .contains(flags::ContextBits1::COMPANIES_LAYOFF)
                .into(),
            Item::Dear_Ernest => self
                .cbits1
                .contains(flags::ContextBits1::DEAR_ERNEST)
                .into(),
            Item::Defeat_Ebih_Alu => self
                .cbits1
                .contains(flags::ContextBits1::DEFEAT_EBIH_ALU)
                .into(),
            Item::Defeat_MUS_A_M20 => self
                .cbits1
                .contains(flags::ContextBits1::DEFEAT_MUS_A_M20)
                .into(),
            Item::Drone_Hover => self
                .cbits1
                .contains(flags::ContextBits1::DRONE_HOVER)
                .into(),
            Item::Drone_Melee_Damage => self.drone_melee_damage.into(),
            Item::Drone_Melee_Speed => self.drone_melee_speed.into(),
            Item::Ebih_Waterfall_Block_Left => self
                .cbits2
                .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_LEFT)
                .into(),
            Item::Ebih_Waterfall_Block_Right => self
                .cbits2
                .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_RIGHT)
                .into(),
            Item::Fast_Travel => self
                .cbits2
                .contains(flags::ContextBits2::FAST_TRAVEL)
                .into(),
            Item::Flask => self.flask.into(),
            Item::Giguna_Northeast_Gate => self
                .cbits2
                .contains(flags::ContextBits2::GIGUNA_NORTHEAST_GATE)
                .into(),
            Item::Health_Upgrade => self.health_upgrade.into(),
            Item::Heretics_Tablet => self
                .cbits2
                .contains(flags::ContextBits2::HERETICS_TABLET)
                .into(),
            Item::Ice_Axe => self.cbits2.contains(flags::ContextBits2::ICE_AXE).into(),
            Item::Infect => self.infect.into(),
            Item::Infection_Range => self.infection_range.into(),
            Item::Infection_Speed => self
                .cbits2
                .contains(flags::ContextBits2::INFECTION_SPEED)
                .into(),
            Item::Ledge_Grab => self.cbits2.contains(flags::ContextBits2::LEDGE_GRAB).into(),
            Item::Letter_from_Trace => self
                .cbits2
                .contains(flags::ContextBits2::LETTER_FROM_TRACE)
                .into(),
            Item::Map_17_10 => self.cbits2.contains(flags::ContextBits2::MAP_17_10).into(),
            Item::Melee_Damage => self.melee_damage.into(),
            Item::Melee_Speed => self.melee_speed.into(),
            Item::Nanite_Mist => self
                .cbits2
                .contains(flags::ContextBits2::NANITE_MIST)
                .into(),
            Item::Nano_Points => self.nano_points.into(),
            Item::Power_Matrix => self
                .cbits2
                .contains(flags::ContextBits2::POWER_MATRIX)
                .into(),
            Item::Ranged_Damage => self.ranged_damage.into(),
            Item::Ranged_Speed => self.ranged_speed.into(),
            Item::Record_Losses => self
                .cbits2
                .contains(flags::ContextBits2::RECORD_LOSSES)
                .into(),
            Item::Remote_Drone => self
                .cbits2
                .contains(flags::ContextBits2::REMOTE_DRONE)
                .into(),
            Item::Researchers_Missing => self
                .cbits2
                .contains(flags::ContextBits2::RESEARCHERS_MISSING)
                .into(),
            Item::Shockwave => self.cbits2.contains(flags::ContextBits2::SHOCKWAVE).into(),
            Item::Slingshot_Hook => self
                .cbits2
                .contains(flags::ContextBits2::SLINGSHOT_HOOK)
                .into(),
            Item::Station_Power => self
                .cbits2
                .contains(flags::ContextBits2::STATION_POWER)
                .into(),
            Item::Switch_36_11 => self
                .cbits2
                .contains(flags::ContextBits2::SWITCH_36_11)
                .into(),
            Item::Switch_40_12 => self
                .cbits2
                .contains(flags::ContextBits2::SWITCH_40_12)
                .into(),
            Item::Terminal_Breakthrough_1 => self
                .cbits2
                .contains(flags::ContextBits2::TERMINAL_BREAKTHROUGH_1)
                .into(),
            Item::Under_Siege => self
                .cbits2
                .contains(flags::ContextBits2::UNDER_SIEGE)
                .into(),
            Item::Underwater_Movement => self
                .cbits2
                .contains(flags::ContextBits2::UNDERWATER_MOVEMENT)
                .into(),
            Item::Wall_Climb => self.cbits2.contains(flags::ContextBits2::WALL_CLIMB).into(),
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
            Item::Amagi_Dragon_Eye_Passage => {
                self.cbits1.insert(flags::ContextBits1::AMAGI_DRAGON_EYE_PASSAGE);
            },
            Item::Amagi_Stronghold_Boulder_1 => {
                self.cbits1.insert(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_1);
            },
            Item::Amagi_Stronghold_Boulder_2 => {
                self.cbits1.insert(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_2);
            },
            Item::Amagi_Stronghold_Wall_1 => {
                self.cbits1.insert(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_1);
            },
            Item::Amagi_Stronghold_Wall_2 => {
                self.cbits1.insert(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_2);
            },
            Item::Amagi_West_Lake_Surface_Wall => {
                self.cbits1.insert(flags::ContextBits1::AMAGI_WEST_LAKE_SURFACE_WALL);
            },
            Item::Amashilama => {
                self.cbits1.insert(flags::ContextBits1::AMASHILAMA);
                rules::action_save__glacier__revival__save_point(self);
            },
            Item::Anuman => {
                self.cbits1.insert(flags::ContextBits1::ANUMAN);
            },
            Item::Apocalypse_Bomb => {
                self.cbits1.insert(flags::ContextBits1::APOCALYPSE_BOMB);
            },
            Item::Boomerang => {
                self.cbits1.insert(flags::ContextBits1::BOOMERANG);
            },
            Item::Companies_Layoff => {
                self.cbits1.insert(flags::ContextBits1::COMPANIES_LAYOFF);
            },
            Item::Dear_Ernest => {
                self.cbits1.insert(flags::ContextBits1::DEAR_ERNEST);
            },
            Item::Defeat_Ebih_Alu => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_EBIH_ALU);
            },
            Item::Defeat_MUS_A_M20 => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_MUS_A_M20);
                rules::action_skip__amagi__west_lake__cavern_refill_station__break_wall_add_item__amagi_dragon_eye_passage(self);
            },
            Item::Drone_Hover => {
                self.cbits1.insert(flags::ContextBits1::DRONE_HOVER);
            },
            Item::Drone_Melee_Damage => {
                self.drone_melee_damage += 1;
            },
            Item::Drone_Melee_Speed => {
                self.drone_melee_speed += 1;
            },
            Item::Ebih_Waterfall_Block_Left => {
                self.cbits2.insert(flags::ContextBits2::EBIH_WATERFALL_BLOCK_LEFT);
            },
            Item::Ebih_Waterfall_Block_Right => {
                self.cbits2.insert(flags::ContextBits2::EBIH_WATERFALL_BLOCK_RIGHT);
            },
            Item::Fast_Travel => {
                self.cbits2.insert(flags::ContextBits2::FAST_TRAVEL);
            },
            Item::Flask => {
                self.flask += 1;
                rules::action_flasks__1(self);
            },
            Item::Giguna_Northeast_Gate => {
                self.cbits2.insert(flags::ContextBits2::GIGUNA_NORTHEAST_GATE);
            },
            Item::Health_Upgrade => {
                self.health_upgrade += 1;
            },
            Item::Heretics_Tablet => {
                self.cbits2.insert(flags::ContextBits2::HERETICS_TABLET);
            },
            Item::Ice_Axe => {
                self.cbits2.insert(flags::ContextBits2::ICE_AXE);
            },
            Item::Infect => {
                self.infect += 1;
                rules::action_energy__max_energy(self);
            },
            Item::Infection_Range => {
                self.infection_range += 1;
            },
            Item::Infection_Speed => {
                self.cbits2.insert(flags::ContextBits2::INFECTION_SPEED);
            },
            Item::Ledge_Grab => {
                self.cbits2.insert(flags::ContextBits2::LEDGE_GRAB);
            },
            Item::Letter_from_Trace => {
                self.cbits2.insert(flags::ContextBits2::LETTER_FROM_TRACE);
            },
            Item::Map_17_10 => {
                self.cbits2.insert(flags::ContextBits2::MAP_17_10);
            },
            Item::Melee_Damage => {
                self.melee_damage += 1;
            },
            Item::Melee_Speed => {
                self.melee_speed += 1;
            },
            Item::Nanite_Mist => {
                self.cbits2.insert(flags::ContextBits2::NANITE_MIST);
            },
            Item::Nano_Points => {
                self.nano_points += 1;
            },
            Item::Power_Matrix => {
                self.cbits2.insert(flags::ContextBits2::POWER_MATRIX);
            },
            Item::Ranged_Damage => {
                self.ranged_damage += 1;
            },
            Item::Ranged_Speed => {
                self.ranged_speed += 1;
            },
            Item::Record_Losses => {
                self.cbits2.insert(flags::ContextBits2::RECORD_LOSSES);
            },
            Item::Remote_Drone => {
                self.cbits2.insert(flags::ContextBits2::REMOTE_DRONE);
            },
            Item::Researchers_Missing => {
                self.cbits2.insert(flags::ContextBits2::RESEARCHERS_MISSING);
            },
            Item::Shockwave => {
                self.cbits2.insert(flags::ContextBits2::SHOCKWAVE);
            },
            Item::Slingshot_Hook => {
                self.cbits2.insert(flags::ContextBits2::SLINGSHOT_HOOK);
            },
            Item::Station_Power => {
                self.cbits2.insert(flags::ContextBits2::STATION_POWER);
            },
            Item::Switch_36_11 => {
                self.cbits2.insert(flags::ContextBits2::SWITCH_36_11);
            },
            Item::Switch_40_12 => {
                self.cbits2.insert(flags::ContextBits2::SWITCH_40_12);
            },
            Item::Terminal_Breakthrough_1 => {
                self.cbits2.insert(flags::ContextBits2::TERMINAL_BREAKTHROUGH_1);
            },
            Item::Under_Siege => {
                self.cbits2.insert(flags::ContextBits2::UNDER_SIEGE);
            },
            Item::Underwater_Movement => {
                self.cbits2.insert(flags::ContextBits2::UNDERWATER_MOVEMENT);
            },
            Item::Wall_Climb => {
                self.cbits2.insert(flags::ContextBits2::WALL_CLIMB);
            },
            Item::Health_Node => rules::action_energy__max_energy(self),
            Item::Power_Core => rules::action_refills__1(self),
            Item::Amagi_Stronghold_Wall_And_Boulder_1 => rules::action_skip__amagi__west_lake__stronghold_ceiling_left__knock_down_left_boulder_add_item__amagi_stronghold_wall_1_add_item__amagi_stronghold_boulder_1(self),
            Item::Amagi_Stronghold_Boulder_And_Wall_2 => rules::action_skip__amagi__west_lake__stronghold_ceiling_right__knock_down_right_boulder_add_item__amagi_stronghold_wall_2_add_item__amagi_stronghold_boulder_2(self),
            Item::Ebih_Waterfall_Both_Blocks => rules::action_skip__ebih__waterfall__alcove__block_left_skip__ebih__waterfall__alcove__block_right_skip__ebih__waterfall__alcove_left__block_left_skip__ebih__waterfall__alcove_right__block_right_add_item__ebih_waterfall_block_right_add_item__ebih_waterfall_block_left(self),
            _ => (),
        }
    }

    // test helper for items
    fn add_item(&mut self, item: Item) {
        match item {
            Item::Amagi_Dragon_Eye_Passage => {
                self.cbits1
                    .insert(flags::ContextBits1::AMAGI_DRAGON_EYE_PASSAGE);
            }
            Item::Amagi_Stronghold_Boulder_1 => {
                self.cbits1
                    .insert(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_1);
            }
            Item::Amagi_Stronghold_Boulder_2 => {
                self.cbits1
                    .insert(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_2);
            }
            Item::Amagi_Stronghold_Wall_1 => {
                self.cbits1
                    .insert(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_1);
            }
            Item::Amagi_Stronghold_Wall_2 => {
                self.cbits1
                    .insert(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_2);
            }
            Item::Amagi_West_Lake_Surface_Wall => {
                self.cbits1
                    .insert(flags::ContextBits1::AMAGI_WEST_LAKE_SURFACE_WALL);
            }
            Item::Amashilama => {
                self.cbits1.insert(flags::ContextBits1::AMASHILAMA);
            }
            Item::Anuman => {
                self.cbits1.insert(flags::ContextBits1::ANUMAN);
            }
            Item::Apocalypse_Bomb => {
                self.cbits1.insert(flags::ContextBits1::APOCALYPSE_BOMB);
            }
            Item::Boomerang => {
                self.cbits1.insert(flags::ContextBits1::BOOMERANG);
            }
            Item::Companies_Layoff => {
                self.cbits1.insert(flags::ContextBits1::COMPANIES_LAYOFF);
            }
            Item::Dear_Ernest => {
                self.cbits1.insert(flags::ContextBits1::DEAR_ERNEST);
            }
            Item::Defeat_Ebih_Alu => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_EBIH_ALU);
            }
            Item::Defeat_MUS_A_M20 => {
                self.cbits1.insert(flags::ContextBits1::DEFEAT_MUS_A_M20);
            }
            Item::Drone_Hover => {
                self.cbits1.insert(flags::ContextBits1::DRONE_HOVER);
            }
            Item::Drone_Melee_Damage => {
                self.drone_melee_damage += 1;
            }
            Item::Drone_Melee_Speed => {
                self.drone_melee_speed += 1;
            }
            Item::Ebih_Waterfall_Block_Left => {
                self.cbits2
                    .insert(flags::ContextBits2::EBIH_WATERFALL_BLOCK_LEFT);
            }
            Item::Ebih_Waterfall_Block_Right => {
                self.cbits2
                    .insert(flags::ContextBits2::EBIH_WATERFALL_BLOCK_RIGHT);
            }
            Item::Fast_Travel => {
                self.cbits2.insert(flags::ContextBits2::FAST_TRAVEL);
            }
            Item::Flask => {
                self.flask += 1;
            }
            Item::Giguna_Northeast_Gate => {
                self.cbits2
                    .insert(flags::ContextBits2::GIGUNA_NORTHEAST_GATE);
            }
            Item::Health_Upgrade => {
                self.health_upgrade += 1;
            }
            Item::Heretics_Tablet => {
                self.cbits2.insert(flags::ContextBits2::HERETICS_TABLET);
            }
            Item::Ice_Axe => {
                self.cbits2.insert(flags::ContextBits2::ICE_AXE);
            }
            Item::Infect => {
                self.infect += 1;
            }
            Item::Infection_Range => {
                self.infection_range += 1;
            }
            Item::Infection_Speed => {
                self.cbits2.insert(flags::ContextBits2::INFECTION_SPEED);
            }
            Item::Ledge_Grab => {
                self.cbits2.insert(flags::ContextBits2::LEDGE_GRAB);
            }
            Item::Letter_from_Trace => {
                self.cbits2.insert(flags::ContextBits2::LETTER_FROM_TRACE);
            }
            Item::Map_17_10 => {
                self.cbits2.insert(flags::ContextBits2::MAP_17_10);
            }
            Item::Melee_Damage => {
                self.melee_damage += 1;
            }
            Item::Melee_Speed => {
                self.melee_speed += 1;
            }
            Item::Nanite_Mist => {
                self.cbits2.insert(flags::ContextBits2::NANITE_MIST);
            }
            Item::Nano_Points => {
                self.nano_points += 1;
            }
            Item::Power_Matrix => {
                self.cbits2.insert(flags::ContextBits2::POWER_MATRIX);
            }
            Item::Ranged_Damage => {
                self.ranged_damage += 1;
            }
            Item::Ranged_Speed => {
                self.ranged_speed += 1;
            }
            Item::Record_Losses => {
                self.cbits2.insert(flags::ContextBits2::RECORD_LOSSES);
            }
            Item::Remote_Drone => {
                self.cbits2.insert(flags::ContextBits2::REMOTE_DRONE);
            }
            Item::Researchers_Missing => {
                self.cbits2.insert(flags::ContextBits2::RESEARCHERS_MISSING);
            }
            Item::Shockwave => {
                self.cbits2.insert(flags::ContextBits2::SHOCKWAVE);
            }
            Item::Slingshot_Hook => {
                self.cbits2.insert(flags::ContextBits2::SLINGSHOT_HOOK);
            }
            Item::Station_Power => {
                self.cbits2.insert(flags::ContextBits2::STATION_POWER);
            }
            Item::Switch_36_11 => {
                self.cbits2.insert(flags::ContextBits2::SWITCH_36_11);
            }
            Item::Switch_40_12 => {
                self.cbits2.insert(flags::ContextBits2::SWITCH_40_12);
            }
            Item::Terminal_Breakthrough_1 => {
                self.cbits2
                    .insert(flags::ContextBits2::TERMINAL_BREAKTHROUGH_1);
            }
            Item::Under_Siege => {
                self.cbits2.insert(flags::ContextBits2::UNDER_SIEGE);
            }
            Item::Underwater_Movement => {
                self.cbits2.insert(flags::ContextBits2::UNDERWATER_MOVEMENT);
            }
            Item::Wall_Climb => {
                self.cbits2.insert(flags::ContextBits2::WALL_CLIMB);
            }
            _ => (),
        }
    }

    // test helper for context vars
    fn parse_set_context(&mut self, ckey: &str, cval: &Yaml) -> Result<(), String> {
        match (ckey, cval) {
            ("position", Yaml::String(s)) => {
                self.set_position(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("position", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("energy", Yaml::String(s)) => {
                self.set_energy(i16::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("energy", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("flasks", Yaml::String(s)) => {
                self.set_flasks(i8::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("flasks", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("refills", Yaml::String(s)) => {
                self.set_refills(i8::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("refills", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("mode", Yaml::String(s)) => {
                self.set_mode(enums::Mode::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("mode", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("save", Yaml::String(s)) => {
                self.set_save(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("save", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("indra", Yaml::String(s)) => {
                self.set_indra(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("indra", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("last", Yaml::String(s)) => {
                self.set_last(SpotId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("last", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("prev_area", Yaml::String(s)) => {
                self.set_prev_area(AreaId::from_str(s).map_err(|e| format!("{}", e))?)
            }
            ("prev_area", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("amagi__main_area__ctx__combo", Yaml::Boolean(b)) => {
                self.set_amagi__main_area__ctx__combo(*b)
            }
            ("amagi__main_area__ctx__combo", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("ebih__base_camp__ctx__left_platform_moved", Yaml::Boolean(b)) => {
                self.set_ebih__base_camp__ctx__left_platform_moved(*b)
            }
            ("ebih__base_camp__ctx__left_platform_moved", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("ebih__grid_25_10_12__ctx__door_open", Yaml::Boolean(b)) => {
                self.set_ebih__grid_25_10_12__ctx__door_open(*b)
            }
            ("ebih__grid_25_10_12__ctx__door_open", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("ebih__waterfall__ctx__west_door_open", Yaml::Boolean(b)) => {
                self.set_ebih__waterfall__ctx__west_door_open(*b)
            }
            ("ebih__waterfall__ctx__west_door_open", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("ebih__ebih_east__ctx__platform1_moved", Yaml::Boolean(b)) => {
                self.set_ebih__ebih_east__ctx__platform1_moved(*b)
            }
            ("ebih__ebih_east__ctx__platform1_moved", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("ebih__ebih_east__ctx__platform2_moved", Yaml::Boolean(b)) => {
                self.set_ebih__ebih_east__ctx__platform2_moved(*b)
            }
            ("ebih__ebih_east__ctx__platform2_moved", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("ebih__drone_room__ctx__platform_moved", Yaml::Boolean(b)) => {
                self.set_ebih__drone_room__ctx__platform_moved(*b)
            }
            ("ebih__drone_room__ctx__platform_moved", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__giguna_northeast__ctx__door_opened", Yaml::Boolean(b)) => {
                self.set_giguna__giguna_northeast__ctx__door_opened(*b)
            }
            ("giguna__giguna_northeast__ctx__door_opened", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__carnelian__ctx__door_opened", Yaml::Boolean(b)) => {
                self.set_giguna__carnelian__ctx__door_opened(*b)
            }
            ("giguna__carnelian__ctx__door_opened", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__carnelian__ctx__upper_susar", Yaml::Boolean(b)) => {
                self.set_giguna__carnelian__ctx__upper_susar(*b)
            }
            ("giguna__carnelian__ctx__upper_susar", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__carnelian__ctx__lower_susar", Yaml::Boolean(b)) => {
                self.set_giguna__carnelian__ctx__lower_susar(*b)
            }
            ("giguna__carnelian__ctx__lower_susar", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__west_caverns__ctx__east_susar", Yaml::Boolean(b)) => {
                self.set_giguna__west_caverns__ctx__east_susar(*b)
            }
            ("giguna__west_caverns__ctx__east_susar", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__ruins_west__ctx__kishib_handled", Yaml::Boolean(b)) => {
                self.set_giguna__ruins_west__ctx__kishib_handled(*b)
            }
            ("giguna__ruins_west__ctx__kishib_handled", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("giguna__ruins_upper__ctx__doors_open", Yaml::Boolean(b)) => {
                self.set_giguna__ruins_upper__ctx__doors_open(*b)
            }
            ("giguna__ruins_upper__ctx__doors_open", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("boomerang_steering", Yaml::Boolean(b)) => self.set_boomerang_steering(*b),
            ("boomerang_steering", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("major_glitches", Yaml::Boolean(b)) => self.set_major_glitches(*b),
            ("major_glitches", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            ("minor_glitches", Yaml::Boolean(b)) => self.set_minor_glitches(*b),
            ("minor_glitches", _) => {
                return Err(format!(
                    "Key {:?} has value of disallowed type: {:?}",
                    ckey, cval
                ));
            }
            _ => {
                return Err(format!("Unrecognized context key: {:?}", ckey));
            }
        }
        Ok(())
    }

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position_raw(&mut self, pos: SpotId) {
        self.position = pos;
    }
    fn set_position(&mut self, pos: SpotId) {
        let area = get_area(pos);
        match area {
            AreaId::Amagi__Cave_Behind_Waterfall => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Amagi__Grid_31_19 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Amagi__Liru_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Amagi__Main_Area => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Amagi__West_Lake => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Antarctica__East => {
                if get_area(self.position) != area {
                    self.save = SpotId::Antarctica__East__Save_Point;
                }
            }
            AreaId::Ebih__Base_Camp => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Boss_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Building_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Bunker_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__By_Garage => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Cave => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Drone_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Ebih_East => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Ebih_West => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Garage => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_21_1_5 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_25_10_12 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_25_2_6 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Grid_26_10_11 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Observation_Tower_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Tent_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Ebih__Waterfall => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Building_Interior => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Carnelian => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Giguna_Base => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Giguna_Northeast => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Ruins_Center => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Ruins_East => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Ruins_Upper => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Ruins_West => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__Wasteland => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna__West_Caverns => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Giguna_Breach__Peak => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos_breach_entry__giguna_breach__peak__save_point(self, pos);
                }
            }
            AreaId::Glacier__Apocalypse_Entry => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Boomerang_Antechamber => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Boomerang_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Compass_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Dock_Outside => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Grid_31_9_12 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Grid_32_7_10 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Grid_37_38_9 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Grid_39_40_7_9 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Grid_42_10 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Grid_43_10_11 => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Lake_Main_Entrance => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Ledge_Grab_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Peak => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Revival => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__The_Big_Drop => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            AreaId::Glacier__Vertical_Room => {
                if get_area(self.position) != area {
                    rules::action_reset_old_area__newpos(self, pos);
                }
            }
            _ => (),
        }
        self.position = pos;
    }

    fn reload_game(&mut self) {
        self.reset_all();
        self.cbits1
            .remove(flags::ContextBits1::AMAGI__MAIN_AREA__CTX__COMBO);
    }

    fn reset_all(&mut self) {
        self.cbits1
            .remove(flags::ContextBits1::EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED);
        self.cbits1
            .remove(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED);
        self.cbits1
            .remove(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED);
        self.cbits1
            .remove(flags::ContextBits1::EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED);
        self.cbits1
            .remove(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__UPPER_SUSAR);
        self.cbits1
            .remove(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__LOWER_SUSAR);
        self.cbits1
            .remove(flags::ContextBits1::GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR);
        self.cbits1
            .remove(flags::ContextBits1::GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED);
    }

    fn reset_region(&mut self, region_id: RegionId) {}
    fn reset_area(&mut self, area_id: AreaId) {
        match area_id {
            AreaId::Ebih__Base_Camp => {
                self.cbits1
                    .remove(flags::ContextBits1::EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED);
            }
            AreaId::Ebih__Ebih_East => {
                self.cbits1
                    .remove(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED);
                self.cbits1
                    .remove(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED);
            }
            AreaId::Ebih__Drone_Room => {
                self.cbits1
                    .remove(flags::ContextBits1::EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED);
            }
            AreaId::Giguna__Carnelian => {
                self.cbits1
                    .remove(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__UPPER_SUSAR);
                self.cbits1
                    .remove(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__LOWER_SUSAR);
            }
            AreaId::Giguna__West_Caverns => {
                self.cbits1
                    .remove(flags::ContextBits1::GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR);
            }
            AreaId::Giguna__Ruins_West => {
                self.cbits1
                    .remove(flags::ContextBits1::GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED);
            }
            _ => (),
        }
    }
    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
            Currency::Energy(c) => self.energy >= *c,
            Currency::Flasks(c) => self.flasks >= *c,
            Currency::Refills(c) => self.refills >= *c,
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
            Currency::Energy(c) => self.energy -= *c,
            Currency::Flasks(c) => self.flasks -= *c,
            Currency::Refills(c) => self.refills -= *c,
        }
    }

    fn visit(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Visited;
        self.visits += 1;
    }
    fn skip(&mut self, loc_id: LocationId) {
        if self.status[loc_id] == Status::None {
            self.status[loc_id] = Status::Skipped;
            self.skips += 1;
        }
    }
    fn reset(&mut self, loc_id: LocationId) {
        match self.status[loc_id] {
            Status::Visited => self.visits -= 1,
            Status::Skipped => self.skips -= 1,
            _ => (),
        }
        self.status[loc_id] = Status::None;
    }

    fn todo(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::None
    }
    fn visited(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Visited
    }
    fn skipped(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Skipped
    }

    fn all_spot_checks(&self, id: SpotId) -> bool {
        let r = spot_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_area_checks(&self, id: AreaId) -> bool {
        let r = area_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_region_checks(&self, id: RegionId) -> bool {
        let r = region_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn get_movement_state(&self) -> movements::MovementState {
        movements::get_movement_state(self)
    }

    fn local_travel_time(&self, movement_state: movements::MovementState, dest: SpotId) -> u32 {
        movements::local_travel_time(self, movement_state, self.position, dest)
    }

    fn count_visits(&self) -> u32 {
        self.visits
    }
    fn count_skips(&self) -> u32 {
        self.skips
    }
    fn progress(&self) -> u32 {
        if self.visits <= 0 {
            0
        } else {
            self.visits * 100 / (Self::World::NUM_LOCATIONS - self.skips)
        }
    }

    fn diff(&self, old: &Context) -> String {
        let mut list: Vec<String> = Vec::new();

        if old.position != self.position {
            list.push(format!(
                "position: {:?} → {:?}",
                old.position, self.position
            ));
        }
        if old.energy != self.energy {
            list.push(format!("energy: {:?} → {:?}", old.energy, self.energy));
        }
        if old.flasks != self.flasks {
            list.push(format!("flasks: {:?} → {:?}", old.flasks, self.flasks));
        }
        if old.refills != self.refills {
            list.push(format!("refills: {:?} → {:?}", old.refills, self.refills));
        }
        if old.mode != self.mode {
            list.push(format!("mode: {:?} → {:?}", old.mode, self.mode));
        }
        if old.save != self.save {
            list.push(format!("save: {:?} → {:?}", old.save, self.save));
        }
        if old.indra != self.indra {
            list.push(format!("indra: {:?} → {:?}", old.indra, self.indra));
        }
        if old.last != self.last {
            list.push(format!("last: {:?} → {:?}", old.last, self.last));
        }
        if old.prev_area != self.prev_area {
            list.push(format!(
                "prev_area: {:?} → {:?}",
                old.prev_area, self.prev_area
            ));
        }
        if old.drone_melee_damage != self.drone_melee_damage {
            list.push(format!(
                "Drone_Melee_Damage: {:+}",
                self.drone_melee_damage - old.drone_melee_damage
            ));
        }
        if old.drone_melee_speed != self.drone_melee_speed {
            list.push(format!(
                "Drone_Melee_Speed: {:+}",
                self.drone_melee_speed - old.drone_melee_speed
            ));
        }
        if old.flask != self.flask {
            list.push(format!("Flask: {:+}", self.flask - old.flask));
        }
        if old.health_upgrade != self.health_upgrade {
            list.push(format!(
                "Health_Upgrade: {:+}",
                self.health_upgrade - old.health_upgrade
            ));
        }
        if old.infect != self.infect {
            list.push(format!("Infect: {:+}", self.infect - old.infect));
        }
        if old.infection_range != self.infection_range {
            list.push(format!(
                "Infection_Range: {:+}",
                self.infection_range - old.infection_range
            ));
        }
        if old.melee_damage != self.melee_damage {
            list.push(format!(
                "Melee_Damage: {:+}",
                self.melee_damage - old.melee_damage
            ));
        }
        if old.melee_speed != self.melee_speed {
            list.push(format!(
                "Melee_Speed: {:+}",
                self.melee_speed - old.melee_speed
            ));
        }
        if old.nano_points != self.nano_points {
            list.push(format!(
                "Nano_Points: {:+}",
                self.nano_points - old.nano_points
            ));
        }
        if old.ranged_damage != self.ranged_damage {
            list.push(format!(
                "Ranged_Damage: {:+}",
                self.ranged_damage - old.ranged_damage
            ));
        }
        if old.ranged_speed != self.ranged_speed {
            list.push(format!(
                "Ranged_Speed: {:+}",
                self.ranged_speed - old.ranged_speed
            ));
        }
        // bitflags
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI__MAIN_AREA__CTX__COMBO);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI__MAIN_AREA__CTX__COMBO);
        if n != p {
            list.push(format!(
                "{}AMAGI__MAIN_AREA__CTX__COMBO",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED);
        if n != p {
            list.push(format!(
                "{}EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::EBIH__GRID_25_10_12__CTX__DOOR_OPEN);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::EBIH__GRID_25_10_12__CTX__DOOR_OPEN);
        if n != p {
            list.push(format!(
                "{}EBIH__GRID_25_10_12__CTX__DOOR_OPEN",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::EBIH__WATERFALL__CTX__WEST_DOOR_OPEN);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::EBIH__WATERFALL__CTX__WEST_DOOR_OPEN);
        if n != p {
            list.push(format!(
                "{}EBIH__WATERFALL__CTX__WEST_DOOR_OPEN",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED);
        if n != p {
            list.push(format!(
                "{}EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED);
        if n != p {
            list.push(format!(
                "{}EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED);
        if n != p {
            list.push(format!(
                "{}EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__GIGUNA_NORTHEAST__CTX__DOOR_OPENED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__GIGUNA_NORTHEAST__CTX__DOOR_OPENED);
        if n != p {
            list.push(format!(
                "{}GIGUNA__GIGUNA_NORTHEAST__CTX__DOOR_OPENED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__DOOR_OPENED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__DOOR_OPENED);
        if n != p {
            list.push(format!(
                "{}GIGUNA__CARNELIAN__CTX__DOOR_OPENED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__UPPER_SUSAR);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__UPPER_SUSAR);
        if n != p {
            list.push(format!(
                "{}GIGUNA__CARNELIAN__CTX__UPPER_SUSAR",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__LOWER_SUSAR);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__LOWER_SUSAR);
        if n != p {
            list.push(format!(
                "{}GIGUNA__CARNELIAN__CTX__LOWER_SUSAR",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR);
        if n != p {
            list.push(format!(
                "{}GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED);
        if n != p {
            list.push(format!(
                "{}GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__RUINS_UPPER__CTX__DOORS_OPEN);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::GIGUNA__RUINS_UPPER__CTX__DOORS_OPEN);
        if n != p {
            list.push(format!(
                "{}GIGUNA__RUINS_UPPER__CTX__DOORS_OPEN",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::BOOMERANG_STEERING);
        let p = old.cbits1.contains(flags::ContextBits1::BOOMERANG_STEERING);
        if n != p {
            list.push(format!("{}BOOMERANG_STEERING", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::MAJOR_GLITCHES);
        let p = old.cbits1.contains(flags::ContextBits1::MAJOR_GLITCHES);
        if n != p {
            list.push(format!("{}MAJOR_GLITCHES", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::MINOR_GLITCHES);
        let p = old.cbits1.contains(flags::ContextBits1::MINOR_GLITCHES);
        if n != p {
            list.push(format!("{}MINOR_GLITCHES", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI_DRAGON_EYE_PASSAGE);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI_DRAGON_EYE_PASSAGE);
        if n != p {
            list.push(format!(
                "{}AMAGI_DRAGON_EYE_PASSAGE",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_1);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_1);
        if n != p {
            list.push(format!(
                "{}AMAGI_STRONGHOLD_BOULDER_1",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_2);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_BOULDER_2);
        if n != p {
            list.push(format!(
                "{}AMAGI_STRONGHOLD_BOULDER_2",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_1);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_1);
        if n != p {
            list.push(format!(
                "{}AMAGI_STRONGHOLD_WALL_1",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_2);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI_STRONGHOLD_WALL_2);
        if n != p {
            list.push(format!(
                "{}AMAGI_STRONGHOLD_WALL_2",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits1
            .contains(flags::ContextBits1::AMAGI_WEST_LAKE_SURFACE_WALL);
        let p = old
            .cbits1
            .contains(flags::ContextBits1::AMAGI_WEST_LAKE_SURFACE_WALL);
        if n != p {
            list.push(format!(
                "{}AMAGI_WEST_LAKE_SURFACE_WALL",
                if n { "+" } else { "-" }
            ));
        }
        let n = self.cbits1.contains(flags::ContextBits1::AMASHILAMA);
        let p = old.cbits1.contains(flags::ContextBits1::AMASHILAMA);
        if n != p {
            list.push(format!("{}AMASHILAMA", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::ANUMAN);
        let p = old.cbits1.contains(flags::ContextBits1::ANUMAN);
        if n != p {
            list.push(format!("{}ANUMAN", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::APOCALYPSE_BOMB);
        let p = old.cbits1.contains(flags::ContextBits1::APOCALYPSE_BOMB);
        if n != p {
            list.push(format!("{}APOCALYPSE_BOMB", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::BOOMERANG);
        let p = old.cbits1.contains(flags::ContextBits1::BOOMERANG);
        if n != p {
            list.push(format!("{}BOOMERANG", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::COMPANIES_LAYOFF);
        let p = old.cbits1.contains(flags::ContextBits1::COMPANIES_LAYOFF);
        if n != p {
            list.push(format!("{}COMPANIES_LAYOFF", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEAR_ERNEST);
        let p = old.cbits1.contains(flags::ContextBits1::DEAR_ERNEST);
        if n != p {
            list.push(format!("{}DEAR_ERNEST", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEFEAT_EBIH_ALU);
        let p = old.cbits1.contains(flags::ContextBits1::DEFEAT_EBIH_ALU);
        if n != p {
            list.push(format!("{}DEFEAT_EBIH_ALU", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DEFEAT_MUS_A_M20);
        let p = old.cbits1.contains(flags::ContextBits1::DEFEAT_MUS_A_M20);
        if n != p {
            list.push(format!("{}DEFEAT_MUS_A_M20", if n { "+" } else { "-" }));
        }
        let n = self.cbits1.contains(flags::ContextBits1::DRONE_HOVER);
        let p = old.cbits1.contains(flags::ContextBits1::DRONE_HOVER);
        if n != p {
            list.push(format!("{}DRONE_HOVER", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits2
            .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_LEFT);
        let p = old
            .cbits2
            .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_LEFT);
        if n != p {
            list.push(format!(
                "{}EBIH_WATERFALL_BLOCK_LEFT",
                if n { "+" } else { "-" }
            ));
        }
        let n = self
            .cbits2
            .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_RIGHT);
        let p = old
            .cbits2
            .contains(flags::ContextBits2::EBIH_WATERFALL_BLOCK_RIGHT);
        if n != p {
            list.push(format!(
                "{}EBIH_WATERFALL_BLOCK_RIGHT",
                if n { "+" } else { "-" }
            ));
        }
        let n = self.cbits2.contains(flags::ContextBits2::FAST_TRAVEL);
        let p = old.cbits2.contains(flags::ContextBits2::FAST_TRAVEL);
        if n != p {
            list.push(format!("{}FAST_TRAVEL", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits2
            .contains(flags::ContextBits2::GIGUNA_NORTHEAST_GATE);
        let p = old
            .cbits2
            .contains(flags::ContextBits2::GIGUNA_NORTHEAST_GATE);
        if n != p {
            list.push(format!(
                "{}GIGUNA_NORTHEAST_GATE",
                if n { "+" } else { "-" }
            ));
        }
        let n = self.cbits2.contains(flags::ContextBits2::HERETICS_TABLET);
        let p = old.cbits2.contains(flags::ContextBits2::HERETICS_TABLET);
        if n != p {
            list.push(format!("{}HERETICS_TABLET", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::ICE_AXE);
        let p = old.cbits2.contains(flags::ContextBits2::ICE_AXE);
        if n != p {
            list.push(format!("{}ICE_AXE", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::INFECTION_SPEED);
        let p = old.cbits2.contains(flags::ContextBits2::INFECTION_SPEED);
        if n != p {
            list.push(format!("{}INFECTION_SPEED", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::LEDGE_GRAB);
        let p = old.cbits2.contains(flags::ContextBits2::LEDGE_GRAB);
        if n != p {
            list.push(format!("{}LEDGE_GRAB", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::LETTER_FROM_TRACE);
        let p = old.cbits2.contains(flags::ContextBits2::LETTER_FROM_TRACE);
        if n != p {
            list.push(format!("{}LETTER_FROM_TRACE", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::MAP_17_10);
        let p = old.cbits2.contains(flags::ContextBits2::MAP_17_10);
        if n != p {
            list.push(format!("{}MAP_17_10", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::NANITE_MIST);
        let p = old.cbits2.contains(flags::ContextBits2::NANITE_MIST);
        if n != p {
            list.push(format!("{}NANITE_MIST", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::POWER_MATRIX);
        let p = old.cbits2.contains(flags::ContextBits2::POWER_MATRIX);
        if n != p {
            list.push(format!("{}POWER_MATRIX", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::RECORD_LOSSES);
        let p = old.cbits2.contains(flags::ContextBits2::RECORD_LOSSES);
        if n != p {
            list.push(format!("{}RECORD_LOSSES", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::REMOTE_DRONE);
        let p = old.cbits2.contains(flags::ContextBits2::REMOTE_DRONE);
        if n != p {
            list.push(format!("{}REMOTE_DRONE", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits2
            .contains(flags::ContextBits2::RESEARCHERS_MISSING);
        let p = old
            .cbits2
            .contains(flags::ContextBits2::RESEARCHERS_MISSING);
        if n != p {
            list.push(format!("{}RESEARCHERS_MISSING", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::SHOCKWAVE);
        let p = old.cbits2.contains(flags::ContextBits2::SHOCKWAVE);
        if n != p {
            list.push(format!("{}SHOCKWAVE", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::SLINGSHOT_HOOK);
        let p = old.cbits2.contains(flags::ContextBits2::SLINGSHOT_HOOK);
        if n != p {
            list.push(format!("{}SLINGSHOT_HOOK", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::STATION_POWER);
        let p = old.cbits2.contains(flags::ContextBits2::STATION_POWER);
        if n != p {
            list.push(format!("{}STATION_POWER", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::SWITCH_36_11);
        let p = old.cbits2.contains(flags::ContextBits2::SWITCH_36_11);
        if n != p {
            list.push(format!("{}SWITCH_36_11", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::SWITCH_40_12);
        let p = old.cbits2.contains(flags::ContextBits2::SWITCH_40_12);
        if n != p {
            list.push(format!("{}SWITCH_40_12", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits2
            .contains(flags::ContextBits2::TERMINAL_BREAKTHROUGH_1);
        let p = old
            .cbits2
            .contains(flags::ContextBits2::TERMINAL_BREAKTHROUGH_1);
        if n != p {
            list.push(format!(
                "{}TERMINAL_BREAKTHROUGH_1",
                if n { "+" } else { "-" }
            ));
        }
        let n = self.cbits2.contains(flags::ContextBits2::UNDER_SIEGE);
        let p = old.cbits2.contains(flags::ContextBits2::UNDER_SIEGE);
        if n != p {
            list.push(format!("{}UNDER_SIEGE", if n { "+" } else { "-" }));
        }
        let n = self
            .cbits2
            .contains(flags::ContextBits2::UNDERWATER_MOVEMENT);
        let p = old
            .cbits2
            .contains(flags::ContextBits2::UNDERWATER_MOVEMENT);
        if n != p {
            list.push(format!("{}UNDERWATER_MOVEMENT", if n { "+" } else { "-" }));
        }
        let n = self.cbits2.contains(flags::ContextBits2::WALL_CLIMB);
        let p = old.cbits2.contains(flags::ContextBits2::WALL_CLIMB);
        if n != p {
            list.push(format!("{}WALL_CLIMB", if n { "+" } else { "-" }));
        }
        for (loc_id, status) in self.status.iter() {
            if *status != old.status[loc_id] {
                list.push(format!("{:?}: {}", status, loc_id));
            }
        }

        if self.visits != old.visits {
            list.push(format!("Visits: {:+}", self.visits - old.visits));
        }

        if self.skips != old.skips {
            list.push(format!("Skips: {:+}", self.skips - old.skips));
        }

        list.join("\n")
    }
}

impl Context {
    // settings
    pub fn boomerang_steering(&self) -> bool {
        self.cbits1
            .contains(flags::ContextBits1::BOOMERANG_STEERING)
    }
    pub fn set_boomerang_steering(&mut self, val: bool) {
        self.cbits1
            .set(flags::ContextBits1::BOOMERANG_STEERING, val);
    }
    pub fn major_glitches(&self) -> bool {
        self.cbits1.contains(flags::ContextBits1::MAJOR_GLITCHES)
    }
    pub fn set_major_glitches(&mut self, val: bool) {
        self.cbits1.set(flags::ContextBits1::MAJOR_GLITCHES, val);
    }
    pub fn minor_glitches(&self) -> bool {
        self.cbits1.contains(flags::ContextBits1::MINOR_GLITCHES)
    }
    pub fn set_minor_glitches(&mut self, val: bool) {
        self.cbits1.set(flags::ContextBits1::MINOR_GLITCHES, val);
    }
    // context
    pub fn position(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.position,
                },
            },
        }
    }
    pub fn energy(&self) -> i16 {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.energy,
                },
            },
        }
    }
    pub fn set_energy(&mut self, val: i16) {
        self.energy = val;
    }
    pub fn flasks(&self) -> i8 {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.flasks,
                },
            },
        }
    }
    pub fn set_flasks(&mut self, val: i8) {
        self.flasks = val;
    }
    pub fn refills(&self) -> i8 {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.refills,
                },
            },
        }
    }
    pub fn set_refills(&mut self, val: i8) {
        self.refills = val;
    }
    pub fn mode(&self) -> enums::Mode {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.mode,
                },
            },
        }
    }
    pub fn set_mode(&mut self, val: enums::Mode) {
        self.mode = val;
    }
    pub fn save(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.save,
                },
            },
        }
    }
    pub fn set_save(&mut self, val: SpotId) {
        self.save = val;
    }
    pub fn indra(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.indra,
                },
            },
        }
    }
    pub fn set_indra(&mut self, val: SpotId) {
        self.indra = val;
    }
    pub fn last(&self) -> SpotId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.last,
                },
            },
        }
    }
    pub fn set_last(&mut self, val: SpotId) {
        self.last = val;
    }
    pub fn prev_area(&self) -> AreaId {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self.prev_area,
                },
            },
        }
    }
    pub fn set_prev_area(&mut self, val: AreaId) {
        self.prev_area = val;
    }
    pub fn amagi__main_area__ctx__combo(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::AMAGI__MAIN_AREA__CTX__COMBO),
                },
            },
        }
    }
    pub fn set_amagi__main_area__ctx__combo(&mut self, val: bool) {
        self.cbits1
            .set(flags::ContextBits1::AMAGI__MAIN_AREA__CTX__COMBO, val);
    }
    pub fn ebih__base_camp__ctx__left_platform_moved(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED),
                },
            },
        }
    }
    pub fn set_ebih__base_camp__ctx__left_platform_moved(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::EBIH__BASE_CAMP__CTX__LEFT_PLATFORM_MOVED,
            val,
        );
    }
    pub fn ebih__grid_25_10_12__ctx__door_open(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::EBIH__GRID_25_10_12__CTX__DOOR_OPEN),
                },
            },
        }
    }
    pub fn set_ebih__grid_25_10_12__ctx__door_open(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::EBIH__GRID_25_10_12__CTX__DOOR_OPEN,
            val,
        );
    }
    pub fn ebih__waterfall__ctx__west_door_open(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::EBIH__WATERFALL__CTX__WEST_DOOR_OPEN),
                },
            },
        }
    }
    pub fn set_ebih__waterfall__ctx__west_door_open(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::EBIH__WATERFALL__CTX__WEST_DOOR_OPEN,
            val,
        );
    }
    pub fn ebih__ebih_east__ctx__platform1_moved(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED),
                },
            },
        }
    }
    pub fn set_ebih__ebih_east__ctx__platform1_moved(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM1_MOVED,
            val,
        );
    }
    pub fn ebih__ebih_east__ctx__platform2_moved(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED),
                },
            },
        }
    }
    pub fn set_ebih__ebih_east__ctx__platform2_moved(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::EBIH__EBIH_EAST__CTX__PLATFORM2_MOVED,
            val,
        );
    }
    pub fn ebih__drone_room__ctx__platform_moved(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED),
                },
            },
        }
    }
    pub fn set_ebih__drone_room__ctx__platform_moved(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::EBIH__DRONE_ROOM__CTX__PLATFORM_MOVED,
            val,
        );
    }
    pub fn giguna__giguna_northeast__ctx__door_opened(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__GIGUNA_NORTHEAST__CTX__DOOR_OPENED),
                },
            },
        }
    }
    pub fn set_giguna__giguna_northeast__ctx__door_opened(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__GIGUNA_NORTHEAST__CTX__DOOR_OPENED,
            val,
        );
    }
    pub fn giguna__carnelian__ctx__door_opened(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__DOOR_OPENED),
                },
            },
        }
    }
    pub fn set_giguna__carnelian__ctx__door_opened(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__CARNELIAN__CTX__DOOR_OPENED,
            val,
        );
    }
    pub fn giguna__carnelian__ctx__upper_susar(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__UPPER_SUSAR),
                },
            },
        }
    }
    pub fn set_giguna__carnelian__ctx__upper_susar(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__CARNELIAN__CTX__UPPER_SUSAR,
            val,
        );
    }
    pub fn giguna__carnelian__ctx__lower_susar(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__CARNELIAN__CTX__LOWER_SUSAR),
                },
            },
        }
    }
    pub fn set_giguna__carnelian__ctx__lower_susar(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__CARNELIAN__CTX__LOWER_SUSAR,
            val,
        );
    }
    pub fn giguna__west_caverns__ctx__east_susar(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR),
                },
            },
        }
    }
    pub fn set_giguna__west_caverns__ctx__east_susar(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__WEST_CAVERNS__CTX__EAST_SUSAR,
            val,
        );
    }
    pub fn giguna__ruins_west__ctx__kishib_handled(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED),
                },
            },
        }
    }
    pub fn set_giguna__ruins_west__ctx__kishib_handled(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__RUINS_WEST__CTX__KISHIB_HANDLED,
            val,
        );
    }
    pub fn giguna__ruins_upper__ctx__doors_open(&self) -> bool {
        match self.position {
            _ => match get_area(self.position) {
                _ => match get_region(self.position) {
                    _ => self
                        .cbits1
                        .contains(flags::ContextBits1::GIGUNA__RUINS_UPPER__CTX__DOORS_OPEN),
                },
            },
        }
    }
    pub fn set_giguna__ruins_upper__ctx__doors_open(&mut self, val: bool) {
        self.cbits1.set(
            flags::ContextBits1::GIGUNA__RUINS_UPPER__CTX__DOORS_OPEN,
            val,
        );
    }
}
