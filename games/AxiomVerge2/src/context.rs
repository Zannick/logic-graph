//! AUTOGENERATED FOR Axiom Verge 2 - MODIFICATIONS WILL BE LOST

#![allow(non_snake_case)]
#![allow(unused)]

use crate::graph::{self, *};
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::context;
use analyzer::world::World;
use enum_map::EnumMap;

pub mod enums {
    use std::fmt;
    #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash, Ord, PartialOrd, Default)]
    pub enum Mode {
        #[default]
        None,
        Indra,
    }
    impl fmt::Display for Mode {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Mode::None => write!(f, "{}", "None"),
                Mode::Indra => write!(f, "{}", "Indra"),
            }
        }
    }
    impl std::str::FromStr for Mode {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Indra" => Ok(Mode::Indra),
                _ => Err(format!("Could not recognize as a Mode: {}", s)),
            }
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
pub enum Status {
    #[default]
    None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct Context {
    // context vars
    pub position: SpotId,
    pub save: SpotId,
    pub mode: enums::Mode,
    pub indra: SpotId,
    pub energy: i32,
    // settings
    pub boomerang_steering: bool,
    // items
    pub freight_elevator: bool,
    pub ice_axe: bool,
    pub notes_2053_02_27: bool,
    pub placeholder: bool,
    pub station_power: bool,
    // other
    pub status: EnumMap<LocationId, Status>,
    visits: i32,
    skips: i32,
}

impl context::Ctx for Context {
    type World = graph::World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;
    const NUM_ITEMS: i32 = 5;

    fn has(&self, item: Item) -> bool {
        match item {
            Item::Freight_Elevator => self.freight_elevator,
            Item::Ice_Axe => self.ice_axe,
            Item::Notes_2053_02_27 => self.notes_2053_02_27,
            Item::Placeholder => self.placeholder,
            Item::Station_Power => self.station_power,
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
            Item::Freight_Elevator => self.freight_elevator.into(),
            Item::Ice_Axe => self.ice_axe.into(),
            Item::Notes_2053_02_27 => self.notes_2053_02_27.into(),
            Item::Placeholder => self.placeholder.into(),
            Item::Station_Power => self.station_power.into(),
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
            Item::Freight_Elevator => {
                self.freight_elevator = true;
            }
            Item::Ice_Axe => {
                self.ice_axe = true;
            }
            Item::Notes_2053_02_27 => {
                self.notes_2053_02_27 = true;
            }
            Item::Placeholder => {
                self.placeholder = true;
            }
            Item::Station_Power => {
                self.station_power = true;
            }
            _ => (),
        }
    }

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position(&mut self, pos: SpotId) {
        match get_area(pos) {
            AreaId::Antarctica__East => {
                if get_area(self.position) != AreaId::Antarctica__East {
                    self.save = SpotId::Antarctica__East__Save_Point;
                }
            }
            _ => (),
        }
        self.position = pos;
    }

    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
            Currency::Energy(c) => self.energy >= *c,
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
            Currency::Energy(c) => self.energy -= *c,
        }
    }

    fn visit(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Visited;
        self.visits += 1;
    }
    fn skip(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Skipped;
        self.skips += 1;
    }
    fn reset(&mut self, loc_id: LocationId) {
        match self.status[loc_id] {
            Status::Visited => self.visits -= 1,
            Status::Skipped => self.skips -= 1,
            _ => (),
        }
        self.status[loc_id] = Status::None;
    }

    fn todo(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::None
    }
    fn visited(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Visited
    }
    fn skipped(&self, loc_id: LocationId) -> bool {
        self.status[loc_id] == Status::Skipped
    }

    fn all_spot_checks(&self, id: SpotId) -> bool {
        let r = spot_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_area_checks(&self, id: AreaId) -> bool {
        let r = area_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn all_region_checks(&self, id: RegionId) -> bool {
        let r = region_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None {
                return false;
            }
        }
        true
    }
    fn local_travel_time(&self, dest: SpotId) -> i32 {
        movements::local_travel_time(self, self.position, dest)
    }

    fn count_visits(&self) -> i32 {
        self.visits
    }
    fn count_skips(&self) -> i32 {
        self.skips
    }
    fn progress(&self) -> i32 {
        if self.visits <= 0 {
            0
        } else {
            self.visits * 100 / (Self::World::NUM_LOCATIONS - self.skips)
        }
    }
}

impl Context {
    pub fn new() -> Context {
        Context {
            position: SpotId::Antarctica__West__Helipad,
            save: SpotId::Antarctica__West__Helipad,
            mode: enums::Mode::Indra,
            indra: SpotId::Antarctica__West__Helipad,
            energy: 0,
            ..Context::default()
        }
    }

    pub fn position(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.position,
            },
        }
    }
    pub fn save(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.save,
            },
        }
    }
    pub fn mode(&self) -> enums::Mode {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.mode,
            },
        }
    }
    pub fn indra(&self) -> SpotId {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.indra,
            },
        }
    }
    pub fn energy(&self) -> i32 {
        match get_area(self.position) {
            _ => match get_region(self.position) {
                _ => self.energy,
            },
        }
    }
}
