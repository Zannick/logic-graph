%% include 'header.rs.jinja'

#![allow(non_snake_case)]

use crate::graph::*;
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use analyzer::context;
use enum_map::EnumMap;

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
pub enum Status {
    #[default] None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct Context {
%# TODO for perf: split into separate structs held in Cow, StateCtx, ItemCtx, SettingCtx, StatusCtx
    // context vars
%% for ctx, t in context_types.items()
    pub {{ ctx }}: {{ t }},
%% endfor
    // settings
%% for s, info in settings.items()
    pub {{ s }}: {{ info.rust_type }},
%% endfor
    // items
%% for item, ct in gl.item_max_counts().items()|sort
    pub {{ item|lower }}: {{ ct|get_int_type_for_max }},
%% endfor
    // other
%# I was not able to move this to analyzer due to the need to call enum derive for proper setup:
%# EnumArray<Status>::Array not implementing Clone for some reason otherwise
    pub status: EnumMap<LocationId, Status>,
}

impl context::Ctx for Context {
    type World = World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;

%# we might not need has/count, if we reference the parameter directly in rules
    fn has(&self, item: Item) -> bool {
        match item {
%% for item, ct in gl.item_max_counts().items()|sort
            Item::{{ item }} => self.{{ item|lower }}{% if ct > 1 %} >= 1{% endif %},
%% endfor
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
%% for item, ct in gl.item_max_counts().items()|sort
            Item::{{ item }} => self.{{ item|lower }}.into(),
%% endfor
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
%% for item, ct in gl.item_max_counts().items()|sort
            Item::{{ item }} => {
                self.{{ item|lower }}{% if ct > 1 %} += 1{% else %} = true{% endif %};
%# there's special code for collect for specific items that may go here
            },
%% endfor
            _ => (),
        }
    }
%# Uncollect just straight-up doesn't work in this model

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position(&mut self, pos: SpotId) {
%% for pltype in ['Region', 'Area']
%% if context_enter_rules[pltype|lower]
        match get_{{ pltype|lower }}(pos) {
%% for r, ctxs in context_enter_rules[pltype|lower].items()
            {{ pltype }}Id::{{ r }} => {
                if get_{{ pltype|lower }}(self.position) != {{ pltype }}Id::{{ r }} {
%% for c, val in ctxs.items()
                    self.{{ c }} = {{ val }};
%% endfor
                }
            },
%% endfor
            _ => (),
        }
%% endif
%% endfor
        self.position = pos;
    }

    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
%% for ptype in price_types
            Currency::{{ ptype|capitalize }}(c) => self.{{ ptype }} >= *c,
%% endfor
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
%% for ptype in price_types
            Currency::{{ ptype|capitalize }}(c) => self.{{ ptype }} -= *c,
%% endfor
        }
    }

    fn visit(&mut self, loc_id: LocationId) { self.status[loc_id] = Status::Visited; }
    fn skip(&mut self, loc_id: LocationId) { self.status[loc_id] = Status::Skipped; }
    fn todo(&self, loc_id: LocationId) -> bool { self.status[loc_id] == Status::None }
    fn visited(&self, loc_id: LocationId) -> bool { self.status[loc_id] == Status::Visited }
    fn skipped(&self, loc_id: LocationId) -> bool { self.status[loc_id] == Status::Skipped }

%% for ptype in ['Spot', 'Area', 'Region']
    fn all_{{ ptype|lower }}_checks(&self, id: {{ ptype }}Id) -> bool {
        let r = {{ ptype|lower }}_locations(id);
        self.status.as_slice()[r.start..r.end].iter().all(|&x| x == Status::Visited)
    }
%% endfor

    fn local_travel_time(&self, dest: SpotId) -> i32 {
        movements::local_travel_time(self, self.position, dest)
    }
}

impl Context {
    pub fn new() -> Context {
        Context {
%% for k, v in context_values.items()
            {{ k }}: {{ v|str_to_rusttype(context_types[k]) }},
%% endfor
            ..Context::default()
        }
    }
%# TODO: handle 'here' ctx overrides
}

