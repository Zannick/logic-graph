//! AUTOGENERATED FOR {{ game }} - DO NOT MODIFY
//!
//! Context (game state).

#![allow(non_snake_case)]

use crate::graph::*;
use crate::items::Item;
use analyzer::context;

#[derive(Copy, Clone, Debug)]
pub struct Context {
%% for ctx, t in context_types.items()
    pub {{ ctx }}: {{ t }},
%% endfor
%% for item, ct in gl.item_max_counts().items()|sort
    {{ item|lower }}: {{ ct|get_item_type_for_max }},
%% endfor
}

%# we might not need these, if we reference the parameter directly in rules
%# or whatnot
impl context::ItemContext for Context {
    type ItemId = Item;
    fn has(&self, item: &Item) -> bool {
        match item {
%% for item, ct in gl.item_max_counts().items()|sort
            Item::{{ item }} => self.{{ item|lower }}{% if ct > 1 %} >= 1{% endif %},
%% endfor
            _ => false,
        }
    }
    fn count(&self, item: &Item) -> i16 {
        match item {
%% for item, ct in gl.item_max_counts().items()|sort
            Item::{{ item }} => self.{{ item|lower }}.into(),
%% endfor
            _ => 0,
        }
    }
    fn collect(&mut self, item: &Item) {
        match item {
%% for item, ct in gl.item_max_counts().items()|sort
            Item::{{ item }} => {
                self.{{ item|lower }}{% if ct > 1 %} += 1{% else %} = true{% endif %};
%# there's special code for collect for specific items that may go here
            },
%% endfor
            _ => (),
        }
    }
}

impl context::PosContext for Context {
    type SpotId = Spot;
    fn position(&self) -> &Spot {
        &self.position
    }
    fn set_position(&mut self, pos: &Spot) {
        self.position = *pos;
    }
}
