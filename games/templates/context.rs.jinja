%% include 'header.rs.jinja'

#![allow(non_snake_case)]
#![allow(unused)]

use crate::graph::{self, *};
use crate::graph_enums::*;
use crate::items::Item;
use crate::movements;
use crate::prices::Currency;
use crate::rules;
use analyzer::context;
use analyzer::world::World;
use enum_map::EnumMap;
use yaml_rust::Yaml;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use std::str::FromStr;

pub mod enums {
use std::fmt;
%% from 'enum.rs.jinja' import enum
%% for etype, evars in context_str_values.items()
{{ enum(etype|camelize, evars|map('camelize')|list|sort, default=True, default_value=context_values[etype]|trim_type_prefix|camelize, allow_lower=True) }}
%% endfor
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Expectation {
%% for ctx, t in context_types.items()
    pub {{ ctx|camelize|camelize }}({{ t }}),
%% endfor
    // items
%% for item, ct in gl.item_max_counts.items()|sort
    {{ item|camelize }}({{ ct|get_int_type_for_max }}),
%% endfor
}

pub mod data {
    #[allow(unused_imports)]
    use crate::context::enums;
    use crate::graph_enums::*;
%% for c, overrides in data_values.items()
pub fn {{ c }}(spot_id: SpotId) -> {{ data_types[c] }} {
    match spot_id {
%% for sp, val in overrides.items()|sort
        {{ sp|target_id_from_id }} => {{ val|str_to_rusttype(data_types[c]) }},
%% endfor
        _ => {{ data_defaults[c]|str_to_rusttype(data_types[c]) }}
    }
}
%% endfor
}

pub mod flags {
use bitflags::bitflags;
use serde::{self, Serialize, Deserialize};

%% for size, vars, defaults in bfp.flag_groups
bitflags!{
    #[derive(Copy, Clone, Debug, {% if not defaults %}Default, {% endif %}PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ContextBits{{ loop.index }} : u{{ size }} {
%% for v in vars
        const {{ v|upper }} = {{ (2 ** loop.index0) | hex }};
%% endfor
    }
}
%% if defaults
impl Default for ContextBits{{ loop.index }} {
    fn default() -> ContextBits{{ loop.index }} {
        ContextBits{{ loop.index }}::{{ defaults|map('upper')|join(' | ContextBits' + (loop.index|string) + '::') }}
    }
}
%% endif
%% endfor
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum Status {
    #[default] None,
    Visited,
    Skipped,
}

#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct Context {
%# Splitting into separate Cow structs performs worse :(
    // context vars
%% for ctx, t in context_types.items() if ctx not in bfp.varmap
    pub {{ ctx }}: {{ t }},
%% endfor
    // settings
%% for s, info in settings.items() if s not in bfp.varmap
    pub {{ s }}: {{ info.rust_type }},
%% endfor
    // items
%% for item, ct in gl.item_max_counts.items()|sort if item not in bfp.varmap
    pub {{ item|lower }}: {{ ct|get_int_type_for_max }},
%% endfor
    // bitflags
%% for group in bfp.flag_groups
    pub cbits{{ loop.index }}: flags::ContextBits{{ loop.index }},
%% endfor
    // other
%# This is part of the core state, should be included when deduplicating
    pub status: EnumMap<LocationId, Status>,
%# Shrinking these to fit NUM_LOCATIONS only might make sense.
    visits: u32,
    skips: u32,
}

impl Default for Context {
    fn default() -> Context {
        Context {
%% for k, v in context_values.items() if k not in bfp.varmap
            {{ k }}: {{ v|str_to_rusttype(context_types[k]) }},
%% endfor
            // settings
%% for s, info in settings.items() if s not in bfp.varmap
            {{ s }}: Default::default(),
%% endfor
            // items
%% for item, ct in gl.item_max_counts.items()|sort if item not in bfp.varmap
            {{ item|lower }}: Default::default(),
%% endfor
            // bitflags
%% for group in bfp.flag_groups
            cbits{{ loop.index }}: Default::default(),
%% endfor
            // other
            status: Default::default(),
            visits: Default::default(),
            skips: Default::default(),
        }
    }
}

impl context::Ctx for Context {
    type World = graph::World;
    type ItemId = Item;
    type AreaId = AreaId;
    type RegionId = RegionId;
    type MovementState = movements::MovementState;
    type Expectation = Expectation;
    const NUM_ITEMS: u32 = {{ gl.item_max_counts|count }};

%# we might not need has/count, if we reference the parameter directly in rules
    fn has(&self, item: Item) -> bool {
        match item {
%% for item, ct in gl.item_max_counts.items()|sort
%% if item in bfp.varmap
            Item::{{ item }} => self.cbits{{ bfp.varmap[item] }}.contains(flags::ContextBits{{ bfp.varmap[item] }}::{{ item|upper }}),
%% else
            Item::{{ item }} => self.{{ item|lower }}{% if ct > 1 %} >= 1{% endif %},
%% endif
%% endfor
            _ => false,
        }
    }
    fn count(&self, item: Item) -> i16 {
        match item {
%% for item, ct in gl.item_max_counts.items()|sort
%% if item in bfp.varmap
            Item::{{ item }} => self.cbits{{ bfp.varmap[item] }}.contains(flags::ContextBits{{ bfp.varmap[item] }}::{{ item|upper }}).into(),
%% else
            Item::{{ item }} => self.{{ item|lower }}.into(),
%% endif
%% endfor
            _ => 0,
        }
    }
    fn collect(&mut self, item: Item) {
        match item {
%% for item, ct in gl.item_max_counts.items()|sort
            Item::{{ item }} => {
%% if item in bfp.varmap
                self.cbits{{ bfp.varmap[item] }}.insert(flags::ContextBits{{ bfp.varmap[item] }}::{{ item|upper }});
%% else
                self.{{ item|lower }}{% if ct > 1 %} += 1{% else %} = true{% endif %};
%% endif
%% if item in collect
                rules::action_{{ collect[item].action_id }}(self);
%% endif
            },
%% endfor
%% for item, info in collect.items()
%% if item not in gl.item_max_counts
            Item::{{ item }} => rules::action_{{ info.action_id }}(self),
%% endif
%% endfor
            _ => (),
        }
    }
%# Uncollect just straight-up doesn't work in this model

    // test helper for items
    fn add_item(&mut self, item: Item) {
        match item {
%% for item, ct in gl.item_max_counts.items()|sort
            Item::{{ item }} => {
%% if item in bfp.varmap
                self.cbits{{ bfp.varmap[item] }}.insert(flags::ContextBits{{ bfp.varmap[item] }}::{{ item|upper }});
%% else
                self.{{ item|lower }}{% if ct > 1 %} += 1{% else %} = true{% endif %};
%% endif
            },
%% endfor
            _ => ()
        }
    }

    // test helper for context vars
    fn parse_set_context(&mut self, ckey: &str, cval: &Yaml) -> Result<(), String> {
        match (ckey, cval) {
%% for ctx, t in context_types.items()
%% if t in int_types
            ("{{ ctx }}", Yaml::Integer(i)) => self.set_{{ ctx }}({{ t }}::try_from(*i).map_err(|e| format!("{}", e))?),
%% elif t == "bool"
            ("{{ ctx }}", Yaml::Boolean(b)) => self.set_{{ ctx }}(*b),
%% else
            ("{{ ctx }}", Yaml::String(s)) => self.set_{{ ctx }}({{ t }}::from_str(s).map_err(|e| format!("{}", e))?),
%% endif
            ("{{ ctx }}", _) => { return Err(format!("Key {:?} has value of disallowed type: {:?}", ckey, cval)); },
%% endfor
%% for s, info in settings.items()
%% if info.rust_type in int_types
            ("{{ s }}", Yaml::Integer(i)) => self.set_{{ s }}({{ info.rust_type }}::try_from(*i).map_err(|e| format!("{}", e))?),
%% elif info.rust_type == "bool"
            ("{{ s }}", Yaml::Boolean(b)) => self.set_{{ s }}(*b),
%% else
            ("{{ s }}", Yaml::String(s)) => self.set_{{ s }}({{ info.rust_type }}::from_str(s).map_err(|e| format!("{}", e))?),
%% endif
            ("{{ s }}", _) => { return Err(format!("Key {:?} has value of disallowed type: {:?}", ckey, cval)); },
%% endfor
            _ => { return Err(format!("Unrecognized context key: {:?}", ckey)); }
        }
        Ok(())
    }

    fn parse_expect_context(ckey: &str, cval: &Yaml) -> Result<Expectation, String> {
        Ok(match (ckey, cval) {
%% for ctx, t in context_types.items()
%% if t in int_types
            ("{{ ctx }}", Yaml::Integer(i)) => Expectation::{{ ctx|camelize|camelize }}({{ t }}::try_from(*i).map_err(|e| format!("{}", e))?),
%% elif t == "bool"
            ("{{ ctx }}", Yaml::Boolean(b)) => Expectation::{{ ctx|camelize|camelize }}(*b),
%% else
            ("{{ ctx }}", Yaml::String(s)) => Expectation::{{ ctx|camelize|camelize }}({{ t }}::from_str(s).map_err(|e| format!("{}", e))?),
%% endif
            ("{{ ctx }}", _) => { return Err(format!("Key {:?} has value of disallowed type: {:?}", ckey, cval)); },
%% endfor
%% for item, ct in gl.item_max_counts.items()|sort
%% if ct == 1
            ("{{ item }}", Yaml::Boolean(b)) => Expectation::{{ item|camelize }}(*b),
            ("{{ item }}", Yaml::Integer(i)) => Expectation::{{ item|camelize }}(*i > 0),
%% else
            ("{{ item }}", Yaml::Integer(i)) => Expectation::{{ item|camelize }}({{ ct|get_int_type_for_max }}::try_from(*i).map_err(|e| format!("{}", e))?),
%% endif
            ("{{ item }}", _) => { return Err(format!("Key {:?} has value of disallowed type: {:?}", ckey, cval)); },
%% endfor
            _ => { return Err(format!("Unrecognized/disallowed expect context key: {:?}", ckey)); }
        })
    }

    fn assert_expectations(&self, exps: &Vec<Self::Expectation>) -> Result<(), String> {
        let mut errs = Vec::new();
        for exp in exps {
            match exp {
%% for ctx in context_types
                Expectation::{{ ctx|camelize|camelize }}(e) => {
                    let v = self.{{ ctx }}();
                    if v != *e {
                        errs.push(format!("Expected {} = {}, got: {}", "{{ ctx }}", e, v));
                    }
                }
%% endfor
%% for item, ct in gl.item_max_counts.items()|sort
            Expectation::{{ item|camelize }}(e) => {
                let v = self.{% if ct == 1 %}has{% else %}count{% endif %}(Item::{{ item }});
                if v != (*e).into() {
                    errs.push(format!("Expected {} = {}, got: {}", "{{ item }}", e, v));
                }
            }
%% endfor
            }
        }
        if errs.is_empty() {
            Ok(())
        } else {
            Err(errs.join("\n"))
        }
    }

    fn position(&self) -> SpotId {
        self.position
    }
    fn set_position_raw(&mut self, pos: SpotId) {
        self.position = pos;
    }
    fn set_position(&mut self, pos: SpotId) {
%% for pltype in ['Region', 'Area']
%% if context_position_watchers[pltype|lower]
        let {{ pltype|lower }} = get_{{ pltype|lower }}(pos);
        match {{ pltype|lower }} {
%% for r in context_position_watchers[pltype|lower]|sort
            {{ pltype }}Id::{{ r }} => {
                if get_{{ pltype|lower }}(self.position) != {{ pltype|lower }} {
%% for c, val in context_trigger_rules.enter[pltype|lower].get(r, {}).items()
%% if c in bfp.varmap
                    self.cbits{{ bfp.varmap[c] }}.{% if val and val != 'false' %}insert{% else %}remove{% endif %}(flags::ContextBits{{ bfp.varmap[c] }}::{{ c|upper }});
%% else
                    self.{{ c }} = {{ val }};
%% endif
%% endfor
%% for other_region in context_resetters[pltype|lower].get(r, ())
%% for c, val in context_trigger_rules.reset[pltype|lower][other_region].items()
%% if c in bfp.varmap
                    self.cbits{{ bfp.varmap[c] }}.{% if val and val != 'false' %}insert{% else %}remove{% endif %}(flags::ContextBits{{ bfp.varmap[c] }}::{{ c|upper }});
%% else
                    self.{{ c }} = {{ val }};
%% endif
%% endfor
%% endfor
%% if id_lookup[r].action_id
                    rules::action_{{ id_lookup[r].action_id }}(self, pos);
%% endif
                }
            },
%% endfor
            _ => (),
        }
%% endif
%% endfor
        self.position = pos;
    }

    fn reload_game(&mut self) {
        self.reset_all();
%% for pltype in ['Region', 'Area']
%% for ctxs in context_trigger_rules.load[pltype|lower].values()
%% for c, val in ctxs.items()
%% if c in bfp.varmap
        self.cbits{{ bfp.varmap[c] }}.{% if val and val != 'false' %}insert{% else %}remove{% endif %}(flags::ContextBits{{ bfp.varmap[c] }}::{{ c|upper }});
%% else
        self.{{ c }} = {{ val }};
%% endif
%% endfor
%% endfor
%% endfor
    }

    fn reset_all(&mut self) {
%% for pltype in ['Region', 'Area']
%% for ctxs in context_trigger_rules.reset[pltype|lower].values()
%% for c, val in ctxs.items()
%% if c in bfp.varmap
        self.cbits{{ bfp.varmap[c] }}.{% if val and val != 'false' %}insert{% else %}remove{% endif %}(flags::ContextBits{{ bfp.varmap[c] }}::{{ c|upper }});
%% else
        self.{{ c }} = {{ val }};
%% endif
%% endfor
%% endfor
%% endfor
    }

%% for pltype in ['Region', 'Area']
    fn reset_{{ pltype|lower }}(&mut self, {{ pltype|lower }}_id: {{ pltype }}Id) {
%% if context_trigger_rules.reset[pltype|lower]
        match {{ pltype|lower }}_id {
%% for r, ctxs in context_trigger_rules.reset[pltype|lower].items()
            {{ pltype }}Id::{{ r }} => {
%% for c, val in ctxs.items()
%% if c in bfp.varmap
                self.cbits{{ bfp.varmap[c] }}.{% if val and val != 'false' %}insert{% else %}remove{% endif %}(flags::ContextBits{{ bfp.varmap[c] }}::{{ c|upper }});
%% else
                self.{{ c }} = {{ val }};
%% endif
%% endfor
            }
%% endfor
            _ => (),
        }
%% endif
    }
%% endfor

    fn can_afford(&self, cost: &Currency) -> bool {
        match cost {
            Currency::Free => true,
%% for ptype in price_types
            Currency::{{ ptype|capitalize }}(c) => self.{{ ptype }} >= *c,
%% endfor
        }
    }
    fn spend(&mut self, cost: &Currency) {
        match cost {
            Currency::Free => (),
%% for ptype in price_types
            Currency::{{ ptype|capitalize }}(c) => self.{{ ptype }} -= *c,
%% endfor
        }
    }

    fn visit(&mut self, loc_id: LocationId) {
        self.status[loc_id] = Status::Visited;
        self.visits += 1;
    }
    fn skip(&mut self, loc_id: LocationId) {
        if self.status[loc_id] == Status::None {
            self.status[loc_id] = Status::Skipped;
            self.skips += 1;
        }
    }
    fn reset(&mut self, loc_id: LocationId) {
        match self.status[loc_id] {
            Status::Visited => self.visits -= 1,
            Status::Skipped => self.skips -= 1,
            _ => (),
        }
        self.status[loc_id] = Status::None;
    }
    
    fn todo(&self, loc_id: LocationId) -> bool { self.status[loc_id] == Status::None }
    fn visited(&self, loc_id: LocationId) -> bool { self.status[loc_id] == Status::Visited }
    fn skipped(&self, loc_id: LocationId) -> bool { self.status[loc_id] == Status::Skipped }

%% for ptype in ['Spot', 'Area', 'Region']
    fn all_{{ ptype|lower }}_checks(&self, id: {{ ptype }}Id) -> bool {
        let r = {{ ptype|lower }}_locations(id);
        for status in self.status.as_slice()[r.start..r.end].iter() {
            if status == &Status::None { return false; }
        }
        true
    }
%% endfor

    fn get_movement_state(&self) -> movements::MovementState {
        movements::get_movement_state(self)
    }

    fn local_travel_time(&self, movement_state: movements::MovementState, dest: SpotId) -> u32 {
        movements::local_travel_time(movement_state, self.position, dest)
    }

    fn count_visits(&self) -> u32 {
        self.visits
    }
    fn count_skips(&self) -> u32 {
        self.skips
    }
    fn progress(&self) -> u32 {
        if self.visits <= 0 {
            0
        } else {
            self.visits * 100 / (Self::World::NUM_LOCATIONS - self.skips)
        }
    }

    fn diff(&self, old: &Context) -> String {
        let mut list: Vec<String> = Vec::new();

%% for ctx, t in context_types.items() if ctx not in bfp.varmap
        if old.{{ ctx }} != self.{{ ctx }} {
            list.push(format!("{{ ctx }}: {:?} → {:?}", old.{{ ctx }}, self.{{ ctx }}));
        }
%% endfor
%% for s, info in settings.items() if s not in bfp.varmap
        if old.{{ s }} != self.{{ s }} {
            list.push(format!("{{ s }}: {:?} → {:?}", old.{{ s }}, self.{{ s }}));
        }
%% endfor
%% for item, ct in gl.item_max_counts.items()|sort if item not in bfp.varmap
        if old.{{ item|lower }} != self.{{ item|lower }} {
%% if ct == 1
            list.push(format!("{}{{ item }}", if self.{{ item|lower }} { "+" } else { "-" }));
%% else
            list.push(format!("{{ item }}: {:+}", self.{{ item|lower }} - old.{{ item|lower }}));
%% endif
        }
%% endfor
    // bitflags
%% for _, vars, _ in bfp.flag_groups
%% set ci = loop.index
%% for v in vars
        let n = self.cbits{{ ci }}.contains(flags::ContextBits{{ ci }}::{{ v|upper }});
        let p = old.cbits{{ ci }}.contains(flags::ContextBits{{ ci }}::{{ v|upper }});
        if n != p {
            list.push(format!("{}{{ v|upper }}", if n { "+" } else { "-" }));
        }
%% endfor
%% endfor

        for (loc_id, status) in self.status.iter() {
            if *status != old.status[loc_id] {
                list.push(format!("{:?}: {}", status, loc_id));
            }
        }
        
        if self.visits != old.visits {
            list.push(format!("Visits: {:+}", self.visits - old.visits));
        }

        if self.skips != old.skips {
            list.push(format!("Skips: {:+}", self.skips - old.skips));
        }

        if list.is_empty() {
            String::from("NONE")
        } else {
            list.join("\n")
        }
    }
}

impl Context {
    // settings
%% for s, info in settings.items()
    pub fn {{ s }}(&self) -> {{ info.rust_type }} {
%% if s in bfp.varmap
        self.cbits{{ bfp.varmap[s] }}.contains(flags::ContextBits{{ bfp.varmap[s] }}::{{ s|upper }})
%% else
        self.{{ s }}
%% endif
    }
    pub fn set_{{ s }}(&mut self, val: {{ info.rust_type }}) {
%% if s in bfp.varmap
        self.cbits{{ bfp.varmap[s] }}.set(flags::ContextBits{{ bfp.varmap[s] }}::{{ s|upper }}, val);
%% else
        self.{{ s }} = val;
%% endif
    }
%% endfor

    // context
%% for ctx, t in context_types.items()
    pub fn {{ ctx }}(&self) -> {{ t }} {
%#- Spots have priority over areas which have priority over regions
        match self.position {
%% for spot, override in context_here_overrides[ctx]['spot'].items()
            {{ spot|target_id_from_id }} => {{ override }},
%% endfor
            _ => match get_area(self.position) {
%% for area, override in context_here_overrides[ctx]['area'].items()
                AreaId::{{ area }} => {{ override }},
%% endfor
                _ => match get_region(self.position) {
%% for region, override in context_here_overrides[ctx]['region'].items()
                    RegionId::{{ region }} => {{ override }},
%% endfor
%% if ctx in bfp.varmap
                    _ => self.cbits{{ bfp.varmap[ctx] }}.contains(flags::ContextBits{{ bfp.varmap[ctx] }}::{{ ctx|upper }})
%% else
                    _ => self.{{ ctx }}
%% endif
                }
            }
        }
    }
%% if ctx != 'position'
    pub fn set_{{ ctx }}(&mut self, val: {{ t }}) {
%% if ctx in bfp.varmap
        self.cbits{{ bfp.varmap[ctx] }}.set(flags::ContextBits{{ bfp.varmap[ctx] }}::{{ ctx|upper }}, val);
%% else
        self.{{ ctx }} = val;
%% endif
    }
%% endif
%% endfor
}

