    %% include 'header.rs.jinja'

use crate::context::{flags, Context};
use crate::graph::World;
use analyzer::context::ContextWrapper;
use analyzer::estimates::ContextScorer;
use analyzer::route::route_from_yaml_string;
use analyzer::settings::*;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use yaml_rust::{Yaml, YamlLoader};

fn read_key_value(
    world: &mut World,
    ctx: &mut Context,
    key: &Yaml,
    val: &Yaml,
) -> Result<(), String> {
    match key.as_str() {
        Some("rules") => {
            for (rkey, rval) in val.as_hash().expect("rules YAML should be a key-value map") {
                match rkey.as_str() {
%% for rule in rules
                    Some("{{ rule }}" | "{{ rule[1:] }}") => {
                        world.rule_{{ rule|construct_id }} = parse_str_into(rkey, rval)?
                    }
%% endfor
                    _ => return Err(format!("Unrecognized or unparseable rule key: '{:?}'", rkey)),
                }
            }
        }
%% for s, info in settings.items()
        Some("{{ s }}") => {
%% if s in bfp.varmap
            ctx.cbits{{ bfp.varmap[s] }}.set(flags::ContextBits{{ bfp.varmap[s] }}::{{ s|upper }},
                parse_bool(key, val)?
            );
%% else
            ctx.{{ s }} = parse_{% if info['type'] in ('bool', 'int') %}{{ info['type'] }}{% else %}str_into{% endif %}(key, val)?;
%% endif
        }
%% endfor
        _ => {
            return Err(format!("Unrecognized or unparseable key: '{:?}'", key));
        }
    }
    Ok(())
}

pub fn load_settings(filename: Option<&PathBuf>) -> (Box<World>, Context, Vec<ContextWrapper<Context>>) {
    let mut world: Box<World> = Box::default();
    analyzer::world::World::condense_graph(world.as_mut());
    let mut ctx = Context::default();
    let mut vec = Vec::new();
    let route_key = Yaml::String(String::from("routes"));
    if let Some(filename) = filename {
        let mut file = File::open(filename).unwrap_or_else(|e| panic!("Couldn't open file \"{:?}\": {:?}", filename, e));
        let mut settings = String::new();
        file.read_to_string(&mut settings)
            .unwrap_or_else(|e| panic!("Couldn't read from file \"{:?}\": {:?}", filename, e));
        let yaml = YamlLoader::load_from_str(&settings).expect("YAML parse error");
        let mut errs = Vec::new();
        let mut route_strs = Vec::new();
        for (key, value) in yaml[0]
            .as_hash()
            .expect("YAML file should be a key-value map")
        {
            if key == &route_key {
                if let Some(v) = value.as_vec() {
                    route_strs.extend(v.iter());
                } else {
                    errs.push(format!("routes must be list of strings, but was {:?}", value));
                }
            } else if let Err(e) = read_key_value(world.as_mut(), &mut ctx, key, value) {
                errs.push(e);
            }
        }
        if !route_strs.is_empty() {
            // This is duplicative, but yaml routes are also inefficient.
            let shortest_paths = ContextScorer::shortest_paths_tree_only(world.as_ref(), &ctx);
            for s in route_strs {
                match route_from_yaml_string(world.as_ref(), &ctx, s, &shortest_paths) {
                    Ok(c) => vec.push(c),
                    Err(e) => errs.push(e),
                }
            }
        }
        if !errs.is_empty() {
            panic!("Errors reading YAML file: {}\n{} total errors", errs.join("\n"), errs.len());
        }
    }
    (world, ctx, vec)
}

