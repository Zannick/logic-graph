%% include 'header.rs.jinja'

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::context::*;
use crate::items::Item;
use crate::prices::Currency;
use crate::rules;
use analyzer::context::Ctx;
use analyzer::world;
use enum_map::{Enum, EnumMap, enum_map};
use std::fmt;
use std::option::Option;

%% from 'enum.rs.jinja' import enum
{{ enum('RegionId', regions) }}
{{ enum('AreaId', gl.areas()|list) }}
{{ enum('SpotId', gl.spots()|list, True) }}
{{ enum('LocationId', gl.locations()|list) }}
{{ enum('ExitId', gl.exits()|list) }}
{{ enum('ActionId', gl.actions()|list) }}
{{ enum('CanonId', canon_places, True) }}

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum History {
    Warp(SpotId),
    Get(LocationId),
    Move(ExitId),
    Activate(ActionId),
}

%# All of this is going in unchanged--perhaps it should be a library type
%# with generics? But that kind of mostly negates the use of traits with
%# associated types... Maybe a macro...
#[derive(Copy, Clone)]
pub struct Location {
    id: LocationId,
    item: Item,
    canonical: CanonId,
    time: i8,
    exit_id: Option<ExitId>,
    price: Currency,
}

impl world::Accessible for Location {
    type Context = Context;
    fn can_access(&self, ctx: &Context) -> bool {
        ctx.can_afford(&self.price) && match self.id {
%% for loc in gl.locations()
            LocationId::{{ loc.id }} => {% if loc.access_id %}rules::access_{{ loc.access_id }}(&ctx)
                {%- else %}true{% endif %},
%% endfor
        }
    }
}

impl world::Location for Location {
    type LocId = LocationId;
    type CanonId = CanonId;
    type ExitId = ExitId;
    type Currency = Currency;

    fn id(&self) -> &LocationId { &self.id }
    fn item(&self) -> &Item { &self.item }
    fn canon_id(&self) -> &CanonId { &self.canonical }
    fn exit_id(&self) -> &Option<ExitId> { &self.exit_id }
    fn time(&self) -> i8 { self.time }
    fn price(&self) -> &Currency { &self.price }
}

#[derive(Copy, Clone)]
pub struct Exit {
    id: ExitId,
    time: i8,
    dest: SpotId,
    price: Currency,
    loc_id: Option<LocationId>,
}

impl world::Accessible for Exit {
    type Context = Context;
    fn can_access(&self, ctx: &Context) -> bool {
        ctx.can_afford(&self.price) && match self.id {
%% for ex in gl.exits()
            ExitId::{{ ex.id }} => {% if ex.access_id %}rules::access_{{ ex.access_id }}(&ctx)
                {%- else %}true{% endif %},
%% endfor
        }
    }
}

impl world::Exit for Exit {
    type ExitId = ExitId;
    type SpotId = SpotId;
    type LocId = LocationId;

    fn id(&self) -> &ExitId { &self.id }
    fn dest(&self) -> &SpotId { &self.dest }
    fn connect(&mut self, dest: &SpotId) { self.dest = *dest; }
    fn loc_id(&self) -> &Option<LocationId> { &self.loc_id }
    fn time(&self) -> i8 { self.time }
}

#[derive(Copy, Clone)]
pub struct Action {
    id: ActionId,
    access_rule: fn(&Context) -> bool,
    activate: fn(&mut Context),
    time: i8,
}

impl world::Accessible for Action {
    type Context = Context;
    fn can_access(&self, ctx: &Context) -> bool {
        match self.id {
%% for act in gl.actions()
            ActionId::{{ act.id }} => {% if act.access_id %}rules::access_{{ act.access_id }}(&ctx)
                {%- else %}true{% endif %},
%% endfor
        }
    }
}
impl world::Action for Action {
    type ActionId = ActionId;
    fn id(&self) -> &ActionId { &self.id }
    fn time(&self) -> i8 { self.time }
    fn perform(&self, ctx: &mut Context) {
        match self.id {
%% for act in gl.actions()
            ActionId::{{ act.id }} => rules::action_{{ act.action_id }}(ctx),
%% endfor
        }
    }
}

#[derive(Copy, Clone)]
pub struct Spot<'a> {
    id: SpotId,
    // slices here to the real things held in World
    locations: &'a [Location],
    exits: &'a [Exit],
    actions: &'a [Action],
}

impl<'a> world::Spot for Spot<'a> {
    type SpotId = SpotId;
    type Location = Location;
    type Exit = Exit;
    type Action = Action;

    fn id(&self) -> &SpotId { &self.id }
    fn locations(&self) -> &'a [Location] { &self.locations }
    fn exits(&self) -> &'a [Exit] { &self.exits }
    fn actions(&self) -> &'a [Action] { &self.actions }
}

#[derive(Copy, Clone)]
pub struct Area<'a> {
    id: AreaId,
    spots: &'a [Spot<'a>],
    exits: &'a [Exit],
}

impl<'a> world::Area for Area<'a> {
    type AreaId = AreaId;
    type Spot = Spot<'a>;
    fn id(&self) -> &AreaId { &self.id }
    fn spots(&self) -> &'a [Spot<'a>] { &self.spots }
    fn exits(&self) -> &'a [Exit] { &self.exits }
}

#[derive(Clone)]
pub struct World<'a> {
    // These are arrays that group the items together by their parent.
    // Using EnumMap for this ONLY WORKS if the keys are properly ordered to group
    // nearby things together.
    // For entrance rando, we would need to have a layer of indirection:
    // list_index: EnumMap<EnumType, usize>,
    // list: EnumArray<ObjType>,
    locations: EnumMap<LocationId, Location>,
    exits: EnumMap<ExitId, Exit>,
    actions: EnumMap<ActionId, Action>,
    spots: EnumMap<SpotId, Spot<'a>>,
}

impl<'a> world::World for World<'a> {
    type Location = Location;
    type Exit = Exit;
    type Action = Action;
    type Spot = Spot<'a>;
    type Area = Area<'a>;

    fn get_location(&self, loc_id: &LocationId) -> &Location { &self.locations[*loc_id] }
    fn get_exit(&self, ex_id: &ExitId) -> &Exit { &self.exits[*ex_id] }
    fn get_action(&self, act_id: &ActionId) -> &Action { &self.actions[*act_id] }
    fn get_spot(&self, sp_id: &SpotId) -> &Spot<'a> { &self.spots[*sp_id] }

    fn on_collect(&self, item_id: &Item, ctx: &mut Context) {
        match item_id {
%% for item, info in collect.items()
            Item::{{ item }} => rules::action_{{ info.action_id }}(ctx),
%% endfor
            _ => (),
        }
    }
}

pub fn build_locations() -> EnumMap<LocationId, Location> {
    enum_map! {
%% for loc in gl.locations()
    LocationId::{{ loc.id }} => Location {
        id: LocationId::{{ loc.id }},
        canonical: CanonId::{{ loc.canon or 'None' }},
        item: Item::{{ loc.item or 'None' }},
        price: Currency::{% if loc.price and loc.price > 0 -%}
            {{ (loc.costs or price_types[0])|capitalize }}({{ loc.price }})
            {%- else %}Free{% endif %},
        time: {% if loc.to is defined %}{# hybrid #}
            {%- if loc.item_time is defined %}{{ loc.item_time }}{% else %}1{% endif %}
            {%- elif loc.time is defined %}{{ loc.time }}{% else %}1{% endif %},
        exit_id: {% if loc.to is defined %}Some(ExitId::{{ loc.id }}){% else %}None{% endif %},
    },
%% endfor
} }

pub fn build_exits() -> EnumMap<ExitId, Exit> {
    enum_map! {
%% for ex in gl.exits()
    ExitId::{{ ex.id }} => Exit {
        id: ExitId::{{ ex.id }},
        time: {{ ex.time if ex.time is defined else 1 }},
        dest: SpotId::{{ ex|get_exit_target }},
        price: Currency::{% if ex.price and ex.price > 0 -%}
            {{ (ex.costs or price_types[0])|capitalize }}({{ ex.price }})
            {%- else %}Free{% endif %},
        loc_id: {% if ex.item is defined %}Some(LocationId::{{ ex.id }}){% else %}None{% endif %},
    },
%% endfor
} }

pub fn build_actions() -> EnumMap<ActionId, Action> {
    enum_map! {
%% for a in gl.actions()
    ActionId::{{ a.id }} => Action {
        id: ActionId::{{ a.id }},
        access_rule: rules::access_{{ a.access_id }},
        activate: rules::action_{{ a.action_id }},
        time: {{ a.time if a.time is defined else 1 }},
    },
%% endfor
} }

pub fn build_spots<'a>(
        locs: &'a EnumMap<LocationId, Location>,
        exits: &'a EnumMap<ExitId, Exit>,
        actions: &'a EnumMap<ActionId, Action>) -> EnumMap<SpotId, Spot<'a>> {
    enum_map! {
        SpotId::None => Spot {
            id: SpotId::None,
            locations: &locs.as_slice()[0..0],
            exits: &exits.as_slice()[0..0],
            actions: &actions.as_slice()[0..0],
        },
%% for sp in gl.spots()
        SpotId::{{ sp.id }} => Spot {
            id: SpotId::{{ sp.id }},
            locations: &locs.as_slice()[{% if sp.loc_ids %}LocationId::{{ sp.loc_ids|min }}.into_usize()..=LocationId::{{ sp.loc_ids|max }}.into_usize(){% else %}0..0{% endif %}],
            exits: &exits.as_slice()[{% if sp.exit_ids %}ExitId::{{ sp.exit_ids|min }}.into_usize()..=ExitId::{{ sp.exit_ids|max }}.into_usize(){% else %}0..0{% endif %}],
            actions: &actions.as_slice()[{% if sp.action_ids %}ActionId::{{ sp.action_ids|min }}.into_usize()..=ActionId::{{ sp.action_ids|max }}.into_usize(){% else %}0..0{% endif %}],
        },
%% endfor
    }
}
