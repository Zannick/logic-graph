%% include 'header.rs.jinja'

#![allow(non_camel_case_types)]

use crate::context::Context;
use crate::items::Item;
use crate::prices::Currency;
use analyzer::context::Ctx;
use analyzer::world;
use enum_map::EnumMap;
use std::fmt;

%% from 'enum.rs.jinja' import enum
{{ enum('RegionId', regions) }}
{{ enum('AreaId', gl.areas()|list) }}
{{ enum('SpotId', gl.spots()|list) }}
{{ enum('LocationId', gl.locations()|list) }}
{{ enum('ExitId', gl.exits()|list) }}
{{ enum('ActionId', gl.actions()|list) }}
{{ enum('CanonId', canon_places, True) }}

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum History {
    Warp(SpotId),
    Get(LocationId),
    Move(ExitId),
    Activate(ActionId),
}

%# All of this is going in unchanged--perhaps it should be a library type
%# with generics? But that kind of mostly negates the use of traits with
%# associated types...
#[derive(Copy, Clone)]
struct Location {
    id: LocationId,
    item: Item,
    canonical: CanonId,
    time: i8,
    price: Currency,

    access_rule: fn(&Context) -> bool,
}

impl world::Location for Location {
    type LocId = LocationId;
    type CanonId = CanonId;
    type Context = Context;

    fn id(&self) -> &LocationId { &self.id }
    fn item(&self) -> &Item { &self.item }
    fn clear_item(&mut self) { self.item = Item::None; }

    fn get_canon_id(&self) -> &CanonId { &self.canonical }

    fn can_access(&self, ctx: &Context) -> bool {
        ctx.can_afford(&self.price) && (self.access_rule)(ctx)
    }

    fn take(&mut self, ctx: &mut Context) {
        ctx.collect(&self.item);
        ctx.spend(&self.price);
        ctx.elapsed += self.time.into();
        self.clear_item();
    }
}

#[derive(Copy, Clone)]
struct Exit {
    id: ExitId,
    time: i8,
    dest: SpotId,
    access_rule: fn(&Context) -> bool,
}

impl world::Exit for Exit {
    type ExitId = ExitId;
    type SpotId = SpotId;
    type Context = Context;

    fn id(&self) -> &ExitId { &self.id }
    fn dest(&self) -> &SpotId { &self.dest }
    fn connect(&mut self, dest: &SpotId) { self.dest = *dest; }
    fn can_access(&self, ctx: &Context) -> bool { (self.access_rule)(ctx) }
}

#[derive(Copy, Clone)]
struct Hybrid {
    id: ExitId,
    item: Item,
    canonical: CanonId,
    time: i8,
    price: Currency,
    dest: SpotId,
    access_rule: fn(&Context) -> bool,
}

#[derive(Copy, Clone)]
struct Action {
    id: ActionId,
    access_rule: fn(&Context) -> bool,
    activate: fn(&mut Context),
    time: i8,
}

#[derive(Copy, Clone)]
struct Spot<'a> {
    id: SpotId,
    // we can hold slices here to the real things held in World
    locations: &'a [Location],
    exits: &'a [Exit],
    hybrids: &'a [Hybrid],
}

#[derive(Clone)]
struct World<'a> {
    state: Context,
    // These are arrays that group the items together by their parent.
    // Using EnumMap for this ONLY WORKS if the keys are properly ordered to group
    // nearby things together.
    // For entrance rando, we would need to have a layer of indirection:
    // list_index: EnumMap<EnumType, usize>,
    // list: EnumArray<ObjType>,
    locations: EnumMap<LocationId, Location>,
    exits: EnumMap<ExitId, Exit>,
    spots: EnumMap<SpotId, Spot<'a>>,
}

impl<'a> world::World for World<'a> {
    type Location = Location;
    type Exit = Exit;
    type Spot = Spot<'a>;
    type Context = Context;

    fn get_location(&self, locid: &LocationId) -> &Location {
        &self.locations[*locid]
    }
    fn get_location_mut(&mut self, locid: &LocationId) -> &mut Location {
        &mut self.locations[*locid]
    }
}

