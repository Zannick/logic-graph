%% include 'header.rs.jinja'

use analyzer::access::*;
use analyzer::cli::*;
use analyzer::route::PartialRoute;
use analyzer::solutions::SolutionSuffix;
use analyzer::world::World;
use analyzer::CommonHasher;
use clap::Parser;
use lib{{ package }}::observe::ObservationMatcher;
use lib{{ package }}::settings;
use log4rs;
use std::collections::HashSet;
use std::path::PathBuf;

#[cfg(all(feature = "jemalloc", not(target_env = "msvc")))]
#[global_allocator]
static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;

#[cfg(feature = "jemalloc")]
#[allow(non_upper_case_globals)]
#[export_name = "malloc_conf"]
pub static malloc_conf: &[u8] = b"prof:true,prof_active:true,lg_prof_sample:19\0";

fn main() -> Result<(), std::io::Error> {
    let args = Cli::parse();
    log4rs::init_file(
        args.logconfig().unwrap_or(&PathBuf::from("../log4rs.yml")),
        Default::default()
    ).unwrap();
    let (world, context, routes) =
        settings::load_settings(args.settings_file());
    if let Err(items) = can_win_just_items(world.as_ref(), &context) {
        panic!("Available items not enough to complete ruleset {}: missing {:?}",
               world.ruleset(), items);
    }
    run::<_, _,
          ObservationMatcher<SolutionSuffix<_>, HashSet<SolutionSuffix<_>, CommonHasher>>,
          ObservationMatcher<PartialRoute<_>, Option<PartialRoute<_>>>,
    >(world.as_ref(), context, routes, &args)
}
