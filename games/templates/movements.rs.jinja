%% include 'header.rs.jinja'

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use crate::context::Context;
use crate::graph_enums::*;
use crate::rules;
use analyzer::context::Ctx;

#[derive(Debug, PartialEq, Eq, Copy, Clone, Default)]
enum Movement {
    #[default] Default,
%% for m in non_default_movements
    {{ m|camelize }},
%% endfor
}

fn has_movement(ctx: &Context, m: Movement) -> bool {
    match m {
        Movement::Default => true,
%% for m in non_default_movements
        Movement::{{ m|camelize }} => rules::access_{{ movements[m].access_id }}(ctx),
%% endfor
    }
}

pub type MovementState = [bool; {{ non_default_movements|count }}];

pub fn get_movement_state(ctx: &Context) -> MovementState {
    [
%% for mtype in non_default_movements
        has_movement(ctx, Movement::{{ mtype|camelize }}),
%% endfor
    ]
}

pub fn local_travel_time(ctx: &Context, movement_state: MovementState, src: SpotId, dest: SpotId) -> u32 {
    match (movement_state, src, dest) {
%% for k, table in movement_tables.items()|sort
%% for (s, d), f in table.items()|sort
    {% if f|count > 1 %}// {{ f|map('round', 6)|list }}
{% endif -%}
    ([{{ k|map('lower')|join(', ') }}], SpotId::{{ s }}, SpotId::{{ d }}) => {{ ((f|sum)*1000)|int }},
%% endfor
%% endfor
        _ => u32::MAX,
    }
}

trait LocalTravel {
    fn local_travel_time(&self, dest: Self, movement_state: MovementState) -> u32;
    fn local_movements(&self, movement_state: MovementState) -> Vec<(BigSpotId, u32)>;
    fn is_connected_to(&self, dest: Self) -> bool;
    fn free_movement(&self, dest: Self) -> Option<u32>;
    fn best_movements(&self, dest: Self) -> (Option<u32>, Vec<(MovementState, u32)>);
}

%% for r in regions
impl LocalTravel for {{ r.id }}SpotId {
    fn local_travel_time(&self, dest: Self, movement_state: MovementState) -> u32 {
        match (movement_state, *self, dest) {
%% for k, table in movement_tables_by_region[r.id].items()|sort
%% for (s, d), f in table.items()|sort
    {% if f|count > 1 %}// {{ f|map('round', 6)|list }}
{% endif -%}
    ([{{ k|map('lower')|join(', ') }}], {{ r.id }}SpotId::{{ s }}, {{ r.id }}SpotId::{{ d }}) => {{ ((f|sum)*1000)|int }},
%% endfor
%% endfor
        _ => u32::MAX,
        }
    }

    fn local_movements(&self, movement_state: MovementState) -> Vec<(BigSpotId, u32)> {
        match (movement_state, *self) {
%% for k, table in movement_tables_by_region[r.id].items()|sort
%% for a in r.areas
%% for s in a.spots
            ([{{ k|map('lower')|join(', ') }}], {{ r.id }}SpotId::{{ s.id }}) => vec![
%% for d in a.spots
%% if (s.id, d.id) in table
                (BigSpotId::{{ r.id }}({{ r.id }}SpotId::{{ d.id }}), {{ ((table[(s.id, d.id)]|sum)*1000)|int }}),
%% endif
%% endfor
            ],
%% endfor
%% endfor
%% endfor
            _ => Vec::new()
        }
    }

    fn is_connected_to(&self, dest: Self) -> bool {
        match (*self, dest) {
%% for a in r.areas
%% for s in a.spots
%% for t in (s.local or ())
%% if s != t
            ({{ r.id }}SpotId::{{ s.id }}, {{ r.id }}SpotId::{{ t.to|get_spot_reference(s) }}) => true,
%% endif
%% endfor
%% endfor
%% endfor
            _ => false,
        }
    }

    fn free_movement(&self, dest: Self) -> Option<u32> {
        match (*self, dest) {
%% for (s, t), (time, mvmts) in movements_rev_lookup_by_region[r.id].items()|sort
            ({{ r.id }}SpotId::{{ s }}, {{ r.id }}SpotId::{{ t }}) =>
                {% if time < 0 %}None{% else %}Some({{ (time*1000)|int }}){% endif %},
%% endfor
            _ => None,
        }
    }

    fn best_movements(&self, dest: Self) -> (Option<u32>, Vec<(MovementState, u32)>) {
        match (*self, dest) {
%% for (s, t), (time, mvmts) in movements_rev_lookup_by_region[r.id].items()|sort
            ({{ r.id }}SpotId::{{ s }}, {{ r.id }}SpotId::{{ t }}) => (
                {% if time < 0 %}None{% else %}Some({{ (time*1000)|int }}){% endif %},
                vec![
%% for m, mt in mvmts
                    ([{{ m|map('lower')|join(', ') }}], {{ (mt*1000)|int }}),
%% endfor
                ]),
%% endfor
            _ => (None, Vec::new()),
        }
    }
}
%% endfor

pub fn local_movements(movement_state: MovementState, src: BigSpotId) -> Vec<(BigSpotId, u32)> {
    match src {
        BigSpotId::None => Vec::new(),
%% for r in regions
        BigSpotId::{{ r.id }}(s) => s.local_movements(movement_state),
%% endfor
    }
}

pub fn local_travel_time_b(movement_state: MovementState, src: BigSpotId, dest: BigSpotId) -> u32 {
    match (src, dest) {
%% for r in regions
        (BigSpotId::{{ r.id }}(s), BigSpotId::{{ r.id }}(d)) => s.local_travel_time(d, movement_state),
%% endfor
        _ => u32::MAX,
    }
}

pub fn are_spots_connected(src: SpotId, dest: SpotId) -> bool {
    match (src, dest) {
%% for s in gl.spots()
%% for t in (s.local or ())
%% if s != t
        (SpotId::{{ s.id }}, SpotId::{{ t.to|get_spot_reference(s) }}) => true,
%% endif
%% endfor
%% endfor
        _ => false,
    }
}

pub fn are_spots_connected_b(src: BigSpotId, dest: BigSpotId) -> bool {
    match (src, dest) {
%% for r in region
        (BigSpotId::{{ r.id }}(s), BigSpotId::{{ r.id }}(d)) -> s.is_connected_to(d),
%% endfor
        _ => false,
    }
}

pub fn base_edges() -> Vec<(SpotId, SpotId, u32)> {
    vec![
%% for (s, t), dist in base_distances.items()|sort
%% if s != t
        (SpotId::{{ s }}, SpotId::{{ t }}, {{ (base_distances[(s, t)] * 1000)|int }}),
%% endif
%% endfor
    ]
}

pub fn base_edges_b() -> Vec<(BigSpotId, BigSpotId, u32)> {
    vec![
%% for (s, t), dist in base_distances.items()|sort
%% if s != t
        (BigSpotId::{{ s|region_id_from_id }}({{ s|region_id_from_id }}SpotId::{{ s }}),
         BigSpotId::{{ t|region_id_from_id }}({{ t|region_id_from_id }}SpotId::{{ t }}),
         {{ (base_distances[(s, t)] * 1000)|int }}),
%% endif
%% endfor
    ]
}

pub fn free_movement(sp1: SpotId, sp2: SpotId) -> Option<u32> {
    match (sp1, sp2) {
%% for (s, t), (time, mvmts) in movements_rev_lookup.items()|sort
        (SpotId::{{ s }}, SpotId::{{ t }}) =>
            {% if time < 0 %}None{% else %}Some({{ (time*1000)|int }}){% endif %},
%% endfor
        _ => None,
    }
}

pub fn free_movement_b(src: BigSpotId, dest: BigSpotId) -> Option<u32> {
    match (src, dest) {
%% for r in region
        (BigSpotId::{{ r.id }}(s), BigSpotId::{{ r.id }}(d)) -> s.free_movement(d),
%% endfor
        _ => None,
    }
}

pub fn best_movements(sp1: SpotId, sp2: SpotId) -> (Option<u32>, Vec<(MovementState, u32)>) {
    match (sp1, sp2) {
%% for (s, t), (time, mvmts) in movements_rev_lookup.items()|sort
        (SpotId::{{ s }}, SpotId::{{ t }}) => (
            {% if time < 0 %}None{% else %}Some({{ (time*1000)|int }}){% endif %},
            vec![
%% for m, mt in mvmts
                ([{{ m|map('lower')|join(', ') }}], {{ (mt*1000)|int }}),
%% endfor
            ]),
%% endfor
        _ => (None, Vec::new()),
    }
}

pub fn best_movements_b(src: BigSpotId, dest: BigSpotId) -> (Option<u32>, Vec<(MovementState, u32)>) {
    match (src, dest) {
%% for r in region
        (BigSpotId::{{ r.id }}(s), BigSpotId::{{ r.id }}(d)) -> s.best_movements(d),
%% endfor
        _ => (None, Vec::new()),
    }
}