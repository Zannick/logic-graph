import argparse
from collections import namedtuple, Counter, defaultdict
from functools import cache, cached_property
import itertools
import logging
import os
import re
import subprocess
import sys
import yaml
# TODO: pyspellchecker to check for issues with item names

logging.basicConfig(level=logging.INFO, format='{relativeCreated:09.2f} {levelname}: {message}', style='{')

from grammar import parseRule, parseAction, StringVisitor
from ItemVisitor import ItemVisitor
from Utils import base_dir, construct_id, n1

MAIN_FILENAME = 'Game.yaml'
GAME_FIELDS = {'name', 'objectives', 'movements', 'warps', 'checks', 'start', 'load',
               'helpers', 'collect'}
# To be validated later
REGION_FIELDS = {'name', 'short', 'here'}
AREA_FIELDS = {'name', 'enter', 'exits', 'spots'}
SPOT_FIELDS = {'name', 'coord', 'actions', 'locations', 'exits', 'hybrid'}

# To be replaced with standard functions instead of helpers
BUILTINS = {
    '$max' : 'cmp::max',
    '$min' : 'cmp::max',
    '$all_checks' : 'undef::all_checks',
}

def load_regions_from_file(file):
    try:
        with open(file) as f:
            return list(yaml.safe_load_all(f))
    except Exception as e:
        raise Exception(f'Error reading from {file}') from e
    # TODO: validate fields


def load_game_yaml(game_dir):
    yfiles = [file for file in os.listdir(game_dir) if file.endswith('.yaml')]
    game_file = os.path.join(game_dir, MAIN_FILENAME)
    if MAIN_FILENAME not in yfiles:
        raise Exception(f'Game not found: expecting {game_file}')
    yfiles.remove(MAIN_FILENAME)
    with open(os.path.join(game_dir, MAIN_FILENAME)) as f:
        game = yaml.safe_load(f)
    unexp = game.keys() - GAME_FIELDS
    if unexp:
        raise Exception(f'Unexpected top-level fields in {game_file}: {", ".join(sorted(unexp))}')
    game['regions'] = list(itertools.chain.from_iterable(
        load_regions_from_file(os.path.join(game_dir, file))
        for file in sorted(yfiles)))
    return game


def _parseExpression(logic, name, category, sep=':'):
    rule = 'boolExpr'
    if ':' in name:
        rule, name = name.split(':', 1)
    return parseRule(rule, logic, name=f'{category}{sep}{name}')


def get_item_type_for_max(count):
    if count == 1:
        return 'bool'
    if count < 128:
        return 'i8'
    return 'i16'  # max 32767


def get_func_name(helper_key):
    return helper_key[helper_key.find('$'):].split('(', 1)[0]


def typenameof(val):
    if isinstance(val, str):
        if '>' in val:
            return 'Spot'
        # arguably even anything that's a string could be an enum instead
        # but we'd have to organize all the possible values
        return "&'static str"
    if isinstance(val, bool):
        return 'bool'
    if isinstance(val, int):
        return 'i32'
    # nothing should hit this and be valid
    return type(val).__name__


def write_enum(file, ename, id_names, allow_none=False):
    linefmt = ename + '::{} => write!(f, "{{}}", "{}"),'
    lines = (linefmt.format(id, name) for id, name in id_names)
    return file.write(f'#[derive(Debug, PartialEq, Eq, enum_map::Enum'
                      f'{", Default" if allow_none else ""})]\n'
                      f'pub enum {ename} {{\n'
                      f'{"#[default] None, " if allow_none else ""}'
                      f'{", ".join(map(str, n1(id_names)))},\n}}\n'
                      f'impl fmt::Display for {ename} {{\n'
                      'fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n'
                      'match self {\n'
                      f'{linefmt.format("None", "None") if allow_none else ""}\n'
                      f'{" ".join(lines)}\n'
                      '}\n}\n}\n\n')


class GameLogic(object):

    def __init__(self, game):
        self.game = game
        self.game_dir = os.path.join(base_dir, 'games', game)
        self.header = f'//! AUTOGENERATED FOR {self.game} - DO NOT MODIFY\n//!\n'
        self._misc_errors = []

        self._info = gameinfo = load_game_yaml(self.game_dir)
        self.helpers = {name: _parseExpression(logic, name, 'helpers')
                        for name, logic in gameinfo['helpers'].items()}
        self.allowed_funcs = {get_func_name(hname) for hname in self.helpers} | BUILTINS.keys()
        self.objectives = {name: _parseExpression(logic, name, 'objectives')
                           for name, logic in gameinfo['objectives'].items()}
        self.collect = {name: parseAction(logic, name, 'collect')
                        for name, logic in gameinfo['collect'].items()}

        # these are {name: {...}} dicts
        self.movements = gameinfo['movements']
        for name, info in self.movements.items():
            if 'req' in info:
                info['pr'] = _parseExpression(info['req'], name, 'movements')

        self.warps = gameinfo['warps']
        for name, info in self.warps.items():
            if 'req' in info:
                info['pr'] = _parseExpression(info['req'], name, 'warps')

        # these are dicts {name: blah, req: blah} (at whatever level)
        self.regions = gameinfo['regions']
        self.canon_places = defaultdict(list)
        for region in self.regions:
            rname = region.get('short', region['name'])
            region['id'] = construct_id(rname)
            for area in region['areas']:
                aname = area['name']
                area['region'] = rname
                area['id'] = construct_id(rname, aname)
                area['fullname'] = f'{rname} > {aname}'

                for e in area.get('exits', ()):
                    e['area'] = aname
                    e['region'] = rname
                    e['id'] = construct_id(rname, aname, 'ex', e['to'])
                    e['fullname'] = f'{area["fullname"]} ==> {e["to"]}'
                    if 'req' in e:
                        e['pr'] = _parseExpression(
                                e['req'], e['to'], area['fullname'], ' ==> ')

                for spot in area['spots']:
                    sname = spot['name']
                    spot['area'] = aname
                    spot['region'] = rname
                    spot['id'] = construct_id(rname, aname, sname)
                    spot['fullname'] = f'{rname} > {aname} > {sname}'
                    # hybrid spots are exits but have names
                    for loc in spot.get('locations', []) + spot.get('hybrid', []):
                        loc['spot'] = sname
                        loc['area'] = aname
                        loc['region'] = rname
                        loc['id'] = construct_id(rname, aname, sname, loc['name'])
                        loc['fullname'] = f'{spot["fullname"]} {loc["name"]}'
                        if 'canon' in loc:
                            self.canon_places[loc['canon']].append(loc)
                        if 'req' in loc:
                            loc['pr'] = _parseExpression(
                                    loc['req'], loc['name'], spot['fullname'], ' ')
                    # We need a counter for exits in case of alternates
                    ec = Counter()
                    for eh in spot.get('exits', []):
                        eh['spot'] = sname
                        eh['area'] = aname
                        eh['region'] = rname
                        ec[eh['to']] += 1
                        eh['id'] = construct_id(rname, aname, sname, 'ex',
                                                f'{eh["to"]}_{ec[eh["to"]]}')
                        eh['fullname'] = f'{spot["fullname"]} ==> {eh["to"]} ({ec[eh["to"]]})'
                        if 'req' in eh:
                            eh['pr'] = _parseExpression(
                                    eh['req'], eh['to'], spot['fullname'], ' ==> ')
                    for act in spot.get('actions', ()):
                        act['spot'] = sname
                        act['area'] = aname
                        act['region'] = rname
                        act['id'] = construct_id(rname, aname, sname, act['name'])
                        act['fullname'] = f'{spot["fullname"]} {act["name"]}'
                        if 'req' in act:
                            act['pr'] = _parseExpression(
                                    act['req'], act['name'] + ' req', spot['fullname'], ' ')
                        act['act'] = parseAction(
                                act['do'], name=f'{act["fullname"]}:do')


    def areas(self):
        return itertools.chain.from_iterable(r['areas'] for r in self.regions)


    def spots(self):
        return itertools.chain.from_iterable(a['spots'] for a in self.areas())


    def locations(self):
        return itertools.chain.from_iterable(s.get('locations', []) for s in self.spots())


    def exits(self):
        return itertools.chain.from_iterable(s.get('exits', []) + s.get('hybrid', [])
                                             for s in self.spots())

    def actions(self):
        return itertools.chain.from_iterable(s.get('actions', []) for s in self.spots())


    def all_points(self):
        for region in self.regions:
            for area in region['areas']:
                yield from area.get('exits', ())
                for spot in area['spots']:
                    yield from spot.get('locations', ())
                    yield from spot.get('exits', ())
                    yield from spot.get('hybrid', ())
                    yield from spot.get('actions', ())


    def all_parse_results(self):
        yield from self.helpers.values()
        yield from self.objectives.values()
        yield from self.collect.values()
        yield from (info['pr'] for info in self.movements.values() if 'pr' in info)
        yield from (info['pr'] for info in self.warps.values() if 'pr' in info)
        for pt in self.all_points():
            if 'pr' in pt:
                yield pt['pr']
            if 'act' in pt:
                yield pt['act']


    @cached_property
    def errors(self):
        e = list(itertools.chain.from_iterable(pr.errors for pr in self.all_parse_results()))
        # Check vanilla items
        for pt in self.all_points():
            if 'item' in pt and pt['item'] is None:
                e.append(f'{pt["id"]} specified with empty item')
            elif 'item' in pt and pt['item'] != construct_id(pt['item']):
                e.append(f'Invalid item name {item!r} at {pt["id"]}; '
                         f'did you mean {construct_id(pt["item"])!r}?')
        # Check used functions
        for func in BUILTINS.keys() & self.helpers.keys():
            e.append(f'Cannot use reserved name {func!r} as helper')
        for pr in self.all_parse_results():
            for t in pr.parser.getTokenStream().tokens:
                if pr.parser.symbolicNames[t.type] == 'FUNC' and t.text not in self.allowed_funcs:
                    e.append(f'{pr.name}: Unrecognized function {t.text}')
        # Do things that will fill _misc_errors
        self.context_values
        e.extend(self._misc_errors)
        return e


    @cached_property
    def vanilla_items(self):
        return {pt['item'] for pt in self.all_points()
                if 'item' in pt}


    @cached_property
    def rule_items(self):
        return {t.text
                for pr in self.all_parse_results()
                for t in pr.parser.getTokenStream().tokens
                if pr.parser.symbolicNames[t.type] == 'ITEM'}


    @cached_property
    def item_stats(self):
        self._i_visitor = visitor = ItemVisitor()
        for pr in self.all_parse_results():
            visitor.visit(pr.tree, name=pr.name)
        return visitor.item_uses, visitor.item_max_counts


    def item_uses(self):
        return self.item_stats[0]


    def item_max_counts(self):
        return self.item_stats[1]


    @cached_property
    def context_values(self):
        def _check_types(v1, v2, ctx, *names):
            t1 = typenameof(v1)
            t2 = typenameof(v2)
            if t1 != t2:
                self._misc_errors.append(
                    f'context value type mismatch: {ctx} defined as {v1} ({t1}) '
                    'and reused in {" > ".join(names)} as {v2} ({t2})')

        # gameinfo: start
        # regions/areas: here, start, enter
        gc = dict(self._info['start'])
        def _handle_start(ctx, val, *names):
            if ctx[0] == '_':
                ctx = construct_id(*names, ctx[1:]).lower()
            if ctx in gc:
                self._misc_errors.append(
                    f'Duplicate context parameter {ctx} in {" > ".join(names)}: '
                    'not allowed in "start" section')
            else:
                gc[ctx] = val

        def _handle_enter(ctx, val, *names):
            if ctx[0] == '_':
                ctx = construct_id(*names, ctx[1:]).lower()
            if ctx in gc:
                _check_types(gc[ctx], val, ctx, *names)
            else:
                gc[ctx] = val

        def _handle_here(ctx, val, *names):
            if ctx[0] == '_':
                self._misc_errors.append(
                    f'"here" overrides cannot be local: {" > ".join(names)} {ctx}')
            elif ctx not in gc:
                self._misc_errors.append(
                    f'"here" overrides must be predefined: {" > ".join(names)} {ctx}')
            else:
                _check_types(gc[ctx], val, ctx, *names)

        for region in self.regions:
            for ctx, val in region.get('start', {}).items():
                _handle_start(ctx, val, region['name'])
            for ctx, val in region.get('enter', {}).items():
                _handle_enter(ctx, val, region['name'])
            for ctx, val in region.get('here', {}).items():
                _handle_here(ctx, val, region['name'])
        for area in self.areas():
            for ctx, val in area.get('start', {}).items():
                _handle_start(ctx, val, area['region'], area['name'])
            for ctx, val in area.get('enter', {}).items():
                _handle_enter(ctx, val, area['region'], area['name'])
            for ctx, val in area.get('here', {}).items():
                _handle_here(ctx, val, area['region'], area['name'])

        return gc

    @cached_property
    def context_types(self):
        d = {'position': 'Spot', 'elapsed': 'i32'}
        d.update((ctx, typenameof(val)) for ctx, val in self.context_values.items())
        return d


    def emit_helpers(self):
        with open(os.path.join(self.game_dir, 'src', 'helpers.rs'), 'w') as f:
            f.write(self.header)
            f.write(f'//! Macro definitions for helpers.\n')
            for name, pr in self.helpers.items():
                args = []
                name = name[name.find('$'):]
                if '(' in name:
                    name, args = name.split('(', 1)
                    args = args[:-1].split(',')
                id = construct_id('helper', name)
                f.write(f'\n/// {name}\n'
                        f'/// {pr.text}\n'
                        f'#[macro_export]\n'
                        f'macro_rules! {id} {{\n'
                        f'    ({", ". join("$" + a + ":expr" for a in args)}) => {{{{\n'
                        f'        println!("{{}}", "{StringVisitor().visit(pr.tree)}");\n')
                for a in args:
                    f.write(f'        println!("{a} := {{}}", ${a});\n')
                f.write(f'    }}}}\n'
                        f'}}\n')


    def emit_items(self):
        with open(os.path.join(self.game_dir, 'src', 'items.rs'), 'w') as f:
            f.write(self.header)
            f.write('//! Collectibles.\n\n'
                    '#![allow(non_camel_case_types)]\n\n'
                    'use std::fmt;\n\n')
            items = self.vanilla_items | self.rule_items
            write_enum(f, 'Item', sorted(zip(items, items)), True)


    def emit_graph(self):
        with open(os.path.join(self.game_dir, 'src', 'graph.rs'), 'w') as f:
            f.write(self.header)
            f.write('//! Graph definitions.\n\n'
                    '#![allow(non_camel_case_types)]\n\n'
                    'use std::fmt;\n\n')
            regions = sorted((r['id'], r['name']) for r in self.regions)
            areas = sorted((a['id'], a['fullname']) for a in self.areas())
            spots = sorted((s['id'], s['fullname']) for s in self.spots())
            locations = sorted((l['id'], l['fullname']) for l in self.locations())
            exits = sorted((e['id'], e['fullname']) for e in self.exits())
            actions = sorted((a['id'], a['fullname']) for a in self.actions())
            canons = sorted((construct_id(c), c) for c in self.canon_places)
            write_enum(f, 'Region', regions)
            write_enum(f, 'Area', areas)
            write_enum(f, 'Spot', spots)
            write_enum(f, 'Location', locations)
            write_enum(f, 'Exit', exits)
            write_enum(f, 'Action', actions)
            write_enum(f, 'Canon', canons, True)


    def emit_context(self):
        with open(os.path.join(self.game_dir, 'src', 'context.rs'), 'w') as f:
            f.write(self.header)
            f.write('//! Context (game state).\n\n'
                    '#![allow(non_snake_case)]\n\n'
                    'use analyzer::context;\n'
                    'use crate::items::Item;\nuse crate::graph::*;\n\n'
                    'pub struct Context {\n')
            for ctx, t in self.context_types.items():
                f.write(f'{ctx}: {t},\n')
            itypes = [(item, get_item_type_for_max(ct))
                      for item, ct in sorted(self.item_max_counts().items())]
            for item, itype in itypes:
                f.write(f'{item.lower()}: {itype},\n')
            f.write('}\n\n'
                    'impl context::ItemContext<Item> for Context {\n'
                    'fn has(&self, item: &Item) -> bool {\n'
                    'match item {\n')
            # TODO: we may not need these... we could potentially reference the
            # properties directly in the given rules
            for item, itype in itypes:
                if itype == 'bool':
                    f.write(f'Item::{item} => self.{item.lower()},\n')
                else:
                    f.write(f'Item::{item} => self.{item.lower()} >= 1,\n')
            f.write('_ => false,\n'
                    '}\n}\n'
                    'fn count(&self, item: &Item) -> i16 {\n'
                    'match item {\n')
            for item in self.item_max_counts():
                f.write(f'Item::{item} => self.{item.lower()}.into(),\n')
            f.write('_ => 0,\n'
                    '}\n}\n}\n\n'
                    'impl context::PosContext<Spot> for Context {\n'
                    'fn position(&self) -> &Spot { &self.position }\n'
                    'fn set_position(&mut self, pos: Spot) { self.position = pos; }\n'
                    '}\n')




if __name__ == '__main__':
    cmd = argparse.ArgumentParser()
    cmd.add_argument('game', help='Which game to build the graph for')
    args = cmd.parse_args()

    gl = GameLogic(args.game)
    if gl.errors:
        print('\n'.join(gl.errors))
        sys.exit(1)
    gl.emit_helpers()
    gl.emit_graph()
    gl.emit_items()
    gl.emit_context()

    srcdir = os.path.join(gl.game_dir, 'src')
    files = os.listdir(srcdir)
    cmd = ['rustfmt'] + [f for f in files if f.endswith('.rs')]
    subprocess.run(cmd, cwd=srcdir)
